# Milestone v1.0: End-to-End Authentication & User Sync

**Status:** ✅ SHIPPED 2026-01-28
**Phases:** 1-3
**Total Plans:** 5

## Overview

This milestone delivered request-time user synchronization for Populatte. The journey started with Clerk JWT configuration (prerequisite for all code), moved to the core backend sync implementation (guard enhancement, type updates, upsert verification), and concluded with a frontend API client for type-safe authenticated requests. By completion, every authenticated request has access to the local User entity without manual lookups.

## Phases

### Phase 1: Prerequisites

**Goal**: Clerk JWT tokens contain user profile data and database layer handles concurrent requests atomically
**Depends on**: Nothing (first phase)
**Plans**: 1 plan

Plans:
- [x] 01-01: Extend schema, implement upsert, add env validation, configure Clerk JWT

**Details:**
- User schema extended with `lastSyncedAt`, `deletedAt`, `source` columns
- Partial unique index on `clerkId` excludes soft-deleted records
- Atomic `upsert()` method with `setWhere` optimization
- Joi validation schema fails app startup on missing env vars
- Clerk JWT session token configured with email, firstName, lastName, imageUrl claims

### Phase 2: Backend Sync

**Goal**: Authenticated requests have full User entity attached; controllers never manually fetch users
**Depends on**: Phase 1
**Plans**: 2 plans

Plans:
- [x] 02-01: Extend ClerkService claims, fix SyncUserUseCase upsert, create health module
- [x] 02-02: Enhance ClerkAuthGuard with sync logic, update types/decorator/controller

**Details:**
- ClerkService extracts full JWT payload (sub, email, firstName, lastName, imageUrl)
- SyncUserUseCase simplified to single atomic upsert call
- Health monitoring with GET /health endpoint and SyncFailureIndicator (5% threshold)
- ClerkAuthGuard performs compare-first sync (fetch, compare, conditionally upsert)
- AuthenticatedRequest.user changed from `{clerkId: string}` to full `User` entity
- CurrentUser decorator returns type-safe User entity
- Sync failures return 503 ServiceUnavailableException

### Phase 3: Frontend Client

**Goal**: Frontend has type-safe API client with automatic authentication
**Depends on**: Phase 2
**Plans**: 2 plans

Plans:
- [x] 03-01: Fetch wrapper with token injection, 401 retry, error types, and dependency install
- [x] 03-02: Zod validation, TanStack Query hooks, error UX, and layout integration

**Details:**
- Dual fetch wrappers: client-side (useApiClient with 401 retry) and server-side (createServerApiClient, no retry)
- Custom ApiError class with error classification utilities (isAuthError, isSyncError, isRetryableError)
- TanStack Query v5 with smart retry (no 4xx, exponential backoff for 5xx/network)
- Zod schemas for runtime API response validation
- useMe() hook for user profile fetching with 5-minute stale time
- Error UX: toast notifications, global loading indicator, error boundaries, 404/403 pages
- Root layout wired: ClerkProvider > ThemeProvider > QueryProvider > (GlobalLoadingIndicator + Auth + Toaster)

---

## Milestone Summary

**Key Decisions:**
- Request-time sync creates users — eliminates race condition where user authenticates before webhook
- Sync on every request (compare-first) — keeps user metadata fresh
- Guard syncs, controller consumes — zero-database-lookup controller pattern
- Dual sync paths — Guard (request-time, compare-first) vs SyncUserUseCase (webhook, unconditional upsert)
- Fetch wrapper over Axios — simpler, aligns with Next.js patterns
- Token refresh + retry on 401 — better UX than immediate redirect
- Separate client/server fetch wrappers — different token acquisition, env vars, retry strategies
- Clerk skipCache (not forceRefresh) — correct Clerk API for fresh tokens
- Zod safeParse for runtime validation — explicit error handling with detailed logging
- Factory pattern for endpoint functions — composable with any fetch implementation
- Smart retry in QueryClient — no 4xx retry, exponential backoff for 5xx/network
- useState for stable QueryClient — prevents cache loss on re-render

**Issues Resolved:**
- DATABASE_URL vs SUPABASE_URL confusion in database config
- npm vs pnpm dependency resolution in monorepo
- SyncUserUseCase find+update/create replaced with atomic upsert (Phase 1 verifier blocker)
- Clerk forceRefresh API doesn't exist — switched to skipCache
- TypeScript isolatedModules + emitDecoratorMetadata requires import type for decorator signatures

**Issues Deferred:**
- None — all issues resolved during milestone execution

**Technical Debt Incurred:**
- CFG-01 (Clerk JWT claims) requires human re-verification if Clerk Dashboard template changes (low severity)

---

_For current project status, see .planning/ROADMAP.md_
