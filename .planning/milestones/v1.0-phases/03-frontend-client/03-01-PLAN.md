---
phase: 03-frontend-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/lib/api/types.ts
  - apps/web/lib/api/client.ts
  - apps/web/lib/api/client.server.ts
  - apps/web/lib/api/error-handler.ts
  - apps/web/.env.local
  - apps/web/.env.example
autonomous: true

must_haves:
  truths:
    - "Client-side fetch wrapper injects Clerk Bearer token into Authorization header"
    - "Server-side fetch wrapper injects Clerk Bearer token using auth() from @clerk/nextjs/server"
    - "401 response triggers token refresh via getToken({forceRefresh: true}) and retries request once"
    - "If retry also fails with 401, user is redirected to sign-in"
    - "503 responses are identified as sync failures for downstream retry handling"
    - "4xx errors are never retried"
  artifacts:
    - path: "apps/web/lib/api/types.ts"
      provides: "ApiError class and ApiResponse type for typed error handling"
    - path: "apps/web/lib/api/client.ts"
      provides: "Client-side fetch wrapper with useAuth() token injection and 401 retry"
    - path: "apps/web/lib/api/client.server.ts"
      provides: "Server-side fetch wrapper with auth() token injection"
    - path: "apps/web/lib/api/error-handler.ts"
      provides: "Error classification (isRetryable, isAuthError, isSyncError) and user-friendly messages"
  key_links:
    - from: "apps/web/lib/api/client.ts"
      to: "@clerk/nextjs useAuth()"
      via: "getToken() call for Bearer token"
      pattern: "getToken"
    - from: "apps/web/lib/api/client.server.ts"
      to: "@clerk/nextjs/server auth()"
      via: "getToken() call for server-side Bearer token"
      pattern: "auth\\(\\)"
    - from: "apps/web/lib/api/client.ts"
      to: "apps/web/lib/api/error-handler.ts"
      via: "import for error classification on non-ok responses"
      pattern: "ApiError"
---

<objective>
Build the core API client infrastructure: dual fetch wrappers (client-side and server-side) with automatic Clerk token injection, 401 retry logic with token refresh, and typed error handling.

Purpose: This is the foundation layer that all API endpoint functions and TanStack Query hooks will build on. Without this, the frontend cannot make authenticated requests to the backend.
Output: Installable dependencies, typed API client for both CSR and SSR, error classification utilities, and environment variable configuration.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-client/03-CONTEXT.md
@.planning/phases/03-frontend-client/03-RESEARCH.md
@apps/web/package.json
@apps/web/app/layout.tsx
@apps/web/middleware.ts
@apps/web/tsconfig.json
@apps/web/.env.example
@apps/api/src/core/entities/user.entity.ts
@apps/api/src/presentation/controllers/user.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create API error types with env configuration</name>
  <files>
    apps/web/package.json
    apps/web/lib/api/types.ts
    apps/web/lib/api/error-handler.ts
    apps/web/.env.local
    apps/web/.env.example
  </files>
  <action>
    **Step 1 - Install dependencies** (run from apps/web/):

    ```bash
    cd apps/web
    npm install @tanstack/react-query@latest zod@latest
    npm install -D @tanstack/react-query-devtools@latest
    pnpm dlx shadcn@latest add sonner
    ```

    Note: The sonner command via shadcn CLI will create `components/ui/sonner.tsx` automatically. Accept defaults.

    **Step 2 - Create API error types** at `apps/web/lib/api/types.ts`:

    Create an `ApiError` class that extends Error with:
    - `status: number` (HTTP status code)
    - `statusText: string`
    - `data?: unknown` (optional response body for validation errors)
    - Constructor takes `{ status, statusText, message, data? }`
    - Static factory method `fromResponse(response: Response, data?: unknown): ApiError`

    Create type `ApiRequestOptions` extending `RequestInit` with:
    - `skipAuth?: boolean` (for public endpoints that don't need token)

    **Step 3 - Create error handler** at `apps/web/lib/api/error-handler.ts`:

    Create utility functions (NOT a class - these are pure functions):
    - `isAuthError(error: unknown): boolean` - checks if error is ApiError with status 401
    - `isSyncError(error: unknown): boolean` - checks if error is ApiError with status 503
    - `isRetryableError(error: unknown): boolean` - returns true for 5xx and network errors, false for 4xx
    - `getErrorMessage(error: unknown): string` - returns user-friendly message:
      - 401: "Your session has expired. Please sign in again."
      - 403: "You don't have permission to perform this action."
      - 404: "The requested resource was not found."
      - 503: "Syncing your account, please wait..."
      - Other 5xx: "Something went wrong. Please try again later."
      - Network error: "Unable to connect. Please check your internet connection."
      - Default: "An unexpected error occurred."

    **Step 4 - Update env files**:

    Add to `.env.local` (append, don't overwrite existing Clerk keys):
    ```
    # API Configuration
    NEXT_PUBLIC_API_URL=http://localhost:3001
    API_URL=http://localhost:3001
    ```

    Add same variables to `.env.example` with placeholder values:
    ```
    # API Configuration
    NEXT_PUBLIC_API_URL=http://localhost:3001
    API_URL=http://localhost:3001
    ```
  </action>
  <verify>
    - `npm ls @tanstack/react-query` shows v5+ installed
    - `npm ls zod` shows v3.24+ installed
    - `npm ls @tanstack/react-query-devtools` shows v5+ installed
    - File exists: `apps/web/components/ui/sonner.tsx`
    - File exists: `apps/web/lib/api/types.ts` with ApiError class
    - File exists: `apps/web/lib/api/error-handler.ts` with all 4 functions
    - `.env.local` contains NEXT_PUBLIC_API_URL
    - `.env.example` contains NEXT_PUBLIC_API_URL and API_URL
    - `cd apps/web && npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
    Dependencies installed, ApiError class and error handler utilities exist with full type safety, env vars configured for both client and server API URLs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dual fetch wrappers with token injection and 401 retry</name>
  <files>
    apps/web/lib/api/client.ts
    apps/web/lib/api/client.server.ts
  </files>
  <action>
    **Step 1 - Create client-side fetch wrapper** at `apps/web/lib/api/client.ts`:

    This is a React hook (`useApiClient`) since it needs `useAuth()` from Clerk.

    ```
    'use client'
    ```

    Import `useAuth` from `@clerk/nextjs`.
    Import `ApiError` from `./types`.

    Create and export `useApiClient()` hook that returns an object with a single `fetch` method:

    The `fetch(endpoint: string, options?: RequestInit)` method:
    1. Gets token via `const { getToken } = useAuth()`
    2. Calls `getToken()` to get current token
    3. Makes fetch to `${process.env.NEXT_PUBLIC_API_URL}${endpoint}` with:
       - Merged headers: `Content-Type: application/json`, spread `options?.headers`, and `Authorization: Bearer ${token}` (only if token exists)
       - Spread remaining options
    4. If response is not ok:
       - Parse response body as JSON (wrap in try/catch, fall back to undefined)
       - If status === 401:
         - Call `getToken({ forceRefresh: true })` to refresh token (Clerk's `forceRefresh` option forces a new token from Clerk's servers)
         - Retry the fetch with the new token (same endpoint, same options, new Authorization header)
         - If retry also returns 401: throw `ApiError.fromResponse(retryResponse)` (caller handles redirect)
         - If retry succeeds: return retry response
       - For all other non-ok responses: throw `ApiError.fromResponse(response, body)`
    5. Return the response

    IMPORTANT: The `useApiClient` hook must call `useAuth()` at the top level of the hook (not inside the fetch function). The `getToken` function reference is stable and can be used inside the returned fetch method.

    Also export a standalone `createApiClient(getToken: () => Promise<string | null>)` function (NOT a hook) that accepts a getToken function. This allows usage in callbacks and non-component contexts where hooks can't be called. Same logic as the hook version but receives getToken as parameter.

    **Step 2 - Create server-side fetch wrapper** at `apps/web/lib/api/client.server.ts`:

    No `'use client'` directive (this is a server file).

    Import `auth` from `@clerk/nextjs/server`.
    Import `ApiError` from `./types`.

    Create and export `async function createServerApiClient()`:
    1. Calls `const { getToken } = await auth()`
    2. Returns an object with a `fetch(endpoint: string, options?: RequestInit)` method:
       - Gets token via `await getToken()`
       - Makes fetch to `${process.env.API_URL}${endpoint}` (no NEXT_PUBLIC_ prefix -- server-only var)
       - Adds headers: `Content-Type: application/json`, merged with options.headers, plus `Authorization: Bearer ${token}`
       - No 401 retry logic on server side (server tokens are always fresh from Clerk)
       - If response is not ok: parse body, throw `ApiError.fromResponse(response, body)`
       - Return response

    **Key differences between client and server:**
    - Client uses `NEXT_PUBLIC_API_URL` (browser-accessible), server uses `API_URL` (server-only)
    - Client has 401 retry with forceRefresh, server does not (tokens are fresh per-request)
    - Client is a React hook or factory function, server is an async factory function
  </action>
  <verify>
    - File exists: `apps/web/lib/api/client.ts` with `useApiClient` hook export and `createApiClient` function export
    - File exists: `apps/web/lib/api/client.server.ts` with `createServerApiClient` function export
    - `client.ts` has `'use client'` directive at top
    - `client.server.ts` does NOT have `'use client'` directive
    - `client.ts` imports `useAuth` from `@clerk/nextjs`
    - `client.server.ts` imports `auth` from `@clerk/nextjs/server`
    - `client.ts` contains `getToken({ forceRefresh: true })` for 401 retry
    - `cd apps/web && npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
    Client-side fetch wrapper automatically injects Clerk Bearer token and retries once on 401 with token refresh. Server-side fetch wrapper injects token using auth(). Both throw typed ApiError for non-ok responses. Both use correct env var (NEXT_PUBLIC_API_URL for client, API_URL for server).
  </done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes with zero errors
2. `npm ls @tanstack/react-query zod` confirms both installed
3. All files exist: lib/api/types.ts, lib/api/client.ts, lib/api/client.server.ts, lib/api/error-handler.ts
4. `components/ui/sonner.tsx` exists (from shadcn CLI)
5. No `any` types used anywhere (grep confirms)
6. Client wrapper uses `NEXT_PUBLIC_API_URL`, server wrapper uses `API_URL`
</verification>

<success_criteria>
- API client infrastructure is complete and type-safe
- Client-side wrapper: token injection + 401 retry with forceRefresh
- Server-side wrapper: token injection without retry
- Error types allow downstream code to classify errors (auth, sync, retryable)
- Dependencies installed for Plan 03-02 (TanStack Query, zod, sonner)
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-client/03-01-SUMMARY.md`
</output>
