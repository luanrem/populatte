# Milestone v2.0: Data Ingestion Engine

**Status:** SHIPPED 2026-01-29
**Phases:** 1-10
**Total Plans:** 12

## Overview

This milestone added a robust Excel file ingestion pipeline to the existing NestJS backend. The journey started by establishing domain abstractions and database schema (foundation), then introduced transaction support and SheetJS-powered parsing strategies (the core ingestion engine), then wired the orchestration layer and use case (business logic), and finally exposed everything through a validated HTTP endpoint (presentation layer). By completion, the API accepts multipart file uploads, parses Excel data through strategy-selected parsers, and atomically persists normalized JSONB rows with full source traceability. No frontend changes -- backend only.

## Phases

### Phase 1: Domain Foundation and Database Schema

**Goal**: Domain abstractions and persistent storage exist for batches and rows, following established Clean Architecture patterns
**Depends on**: Nothing (first phase)
**Plans**: 2 plans

Plans:
- [x] 01-01-PLAN.md — Core layer entities (Batch, Row) and abstract repository contracts
- [x] 01-02-PLAN.md — Drizzle schemas, mappers, repository implementations, DrizzleModule registration, migration

**Details:**
- Created Batch and Row domain entities with enums (BatchMode, BatchStatus, RowStatus)
- BatchRepository and RowRepository abstract classes with persistence contracts
- Drizzle schemas for ingestion_batches and ingestion_rows tables with FK relationships
- Chunked bulk insert at 5,000 rows per INSERT to stay under PostgreSQL 65,534 parameter limit
- Repository mappers normalize undefined to null before JSONB storage

---

### Phase 2: Transaction Support and Excel Parsing Strategies

**Goal**: Atomic transaction infrastructure is operational and both Excel parsing strategies correctly transform files into normalized ParsedRow arrays
**Depends on**: Phase 1
**Plans**: 2 plans

Plans:
- [x] 02-01-PLAN.md — Transaction infrastructure (CLS + Drizzle adapter), SheetJS CDN install, shared Excel types/helpers/strategy interface
- [x] 02-02-PLAN.md — ListModeStrategy, ProfileModeStrategy implementations, ExcelModule registration

**Details:**
- @nestjs-cls/transactional with Drizzle adapter for CLS-scoped transactions
- SheetJS 0.20.3 installed from CDN (not npm registry) for security
- ListModeStrategy: header-based parsing with sheet_to_json
- ProfileModeStrategy: cell-address keys for lossless flattening
- ExcelModule with Symbol-based DI tokens for strategy injection

---

### Phase 3: Ingestion Service

**Goal**: IngestionService selects the correct parsing strategy based on mode and coordinates the parse-then-persist flow without any if/else parsing logic
**Depends on**: Phase 2
**Plans**: 1 plan

Plans:
- [x] 03-01-PLAN.md — IngestionService with strategy selection and parse-persist orchestration

**Details:**
- Strategy selection based on BatchMode parameter
- Parse-then-persist orchestration with column metadata extraction
- No transaction management in service layer (deferred to use case @Transactional)

---

### Phase 4: Ingestion Module

**Goal**: IngestionModule wires strategies and ingestion service for NestJS dependency injection
**Depends on**: Phase 3
**Plans**: 1 plan

Plans:
- [x] 04-01-PLAN.md — IngestionModule setup with ExcelModule import and service export

**Details:**
- IngestionModule imports ExcelModule to access strategy tokens
- Exports IngestionService for use case injection
- Positioned after TransactionModule in AppModule imports

---

### Phase 5: CreateBatch Use Case

**Goal**: Transactional use case validates project ownership, orchestrates ingestion, and guarantees atomic commit/rollback of batch + rows
**Depends on**: Phase 4
**Plans**: 1 plan

Plans:
- [x] 05-01-PLAN.md — CreateBatchUseCase with ownership validation and transactional orchestration

**Details:**
- findByIdOnly queries without userId/deletedAt filters for separate error messages (404 vs 403)
- @Transactional() on execute() wraps all operations in single CLS-scoped transaction
- BatchStatus.Processing replaces PendingReview for active ingestion lifecycle

---

### Phase 6: Transaction Rollback Test

**Goal**: Integration test proves that a failed row insert rolls back the batch insert, preventing orphaned batches
**Depends on**: Phase 5
**Plans**: 1 plan

Plans:
- [x] 06-01-PLAN.md — Integration test with happy-path and rollback-path scenarios for CreateBatchUseCase

**Details:**
- Mock @Transactional decorator with pass-through for test isolation
- Jest config with roots array discovers both src/ and test/ directories
- Validates atomic rollback behavior through error propagation

---

### Phase 7: Batch Endpoint

**Goal**: HTTP endpoint accepts multipart file uploads with authentication, delegating to the use case
**Depends on**: Phase 5
**Plans**: 1 plan

Plans:
- [x] 07-01-PLAN.md — BatchController with Multer interceptor, Zod DTO, BatchModule wiring, and AppModule import

**Details:**
- POST /projects/:projectId/batches with multipart/form-data
- FilesInterceptor with Multer for file handling
- ClerkAuthGuard protection
- BatchModule imports IngestionModule for use case access

---

### Phase 8: Upload Size Limits

**Goal**: Multer enforces file size and count limits at the interceptor level, rejecting oversized uploads before any parsing
**Depends on**: Phase 7
**Plans**: 1 plan

Plans:
- [x] 08-01-PLAN.md — Multer limits configuration and Content-Length middleware

**Details:**
- Max 5MB per file, max 50 files per request
- Content-Length middleware for early rejection (includes 100KB overhead for multipart boundaries)
- MulterExceptionFilter for HTTP 413 responses
- Environment-driven config for runtime flexibility

---

### Phase 9: File Content Validation

**Goal**: Magic-byte inspection validates that uploaded files are genuine Excel/ZIP archives before SheetJS processes them
**Depends on**: Phase 7
**Plans**: 1 plan

Plans:
- [x] 09-01-PLAN.md — Magic-byte validation pipe/guard for Excel file verification

**Details:**
- FileContentValidationPipe with magic-byte inspection
- Supports .xlsx (ZIP PK signature), .xls (OLE2), and .csv (UTF-8 text heuristic)
- Fail-fast: rejects entire batch on first invalid file
- Server-side logging with hex bytes for spoofed file diagnosis

---

### Phase 10: Batch DTO Validation

**Goal**: Zod v4 schema validates the mode field and the controller delegates to use case without containing business logic
**Depends on**: Phase 7
**Plans**: 1 plan

Plans:
- [x] 10-01-PLAN.md — CreateBatchDto Zod schema and controller delegation wiring

**Details:**
- Zod v4 message parameter for custom enum errors
- safeParse pattern for manual validation (type-safe, no unsafe assertions)
- Controller remains thin — delegates entirely to use case

---

## Milestone Summary

**Key Decisions:**
- Strategy Pattern for ingestion (Open/Closed principle: add new strategies without modifying service)
- Cell-address keys for profile mode (simplest lossless flattening; Key-Value heuristic deferred)
- Atomic batch transactions (all-or-nothing insert prevents partial data corruption)
- SheetJS from CDN only (npm registry version has Prototype Pollution vulnerability)
- DRIZZLE_CLIENT Symbol token via factory provider for transaction adapter
- Manual magic-byte inspection instead of file-type npm package (ESM compatibility)
- Fail-fast validation rejects entire batch on first invalid file
- safeParse pattern for manual Zod validation in multipart form context

**Issues Resolved:**
- PostgreSQL 65,534 parameter limit handled via 5,000-row chunked inserts
- SheetJS CDN install with pnpm lockfile stability verified
- NestJS decorator static limitation for Multer limits (documented as intentional)
- ESM compatibility issue with file-type package (manual magic-byte inspection instead)

**Issues Deferred:**
- Key-Value heuristic detection for profile mode (cell-address keys for MVP)
- Streaming/chunked upload for large files (optimization milestone)
- Row-level error reporting / partial success (entire batch is atomic for MVP)
- PDF and Notion ingestion strategies (future extension via Strategy Pattern)

**Technical Debt Incurred:**
- Pre-existing ESLint errors in v1.0 code (6 issues across sync-user, cell-access, main, webhook files)
- Pre-existing TypeScript error in list-mode.strategy.ts (Object.entries type issue)
- ContentLengthMiddleware cannot log userId (runs before auth guard — architectural trade-off)
- FilesInterceptor limits hardcoded (NestJS decorator limitation, documented as intentional)

---

_For current project status, see .planning/ROADMAP.md_
