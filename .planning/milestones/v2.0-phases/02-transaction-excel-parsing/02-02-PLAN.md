---
phase: 02-transaction-excel-parsing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/api/src/infrastructure/excel/strategies/list-mode.strategy.ts
  - apps/api/src/infrastructure/excel/strategies/profile-mode.strategy.ts
  - apps/api/src/infrastructure/excel/excel.module.ts
autonomous: true

must_haves:
  truths:
    - "ListModeStrategy parses a single Excel file buffer into N ParsedRow objects with first-row headers as keys"
    - "ListModeStrategy rejects input when more than 1 file is provided"
    - "ListModeStrategy parses all sheets in the workbook, not just the first"
    - "ProfileModeStrategy parses N Excel file buffers into N ParsedRow objects (one per sheet) with cell-address keys"
    - "ProfileModeStrategy accepts 1 to N files"
    - "Both strategies set sourceFileName on every parsed row"
    - "Both strategies normalize undefined cell values to null"
    - "Both strategies pass cellDates: true to XLSX.read() for date handling"
    - "Both strategies build a type map (CellTypeMap) for the batch entity"
    - "ExcelModule exports both strategies via Symbol tokens"
  artifacts:
    - path: "apps/api/src/infrastructure/excel/strategies/list-mode.strategy.ts"
      provides: "ListModeStrategy implementing ExcelParsingStrategy"
      contains: "class ListModeStrategy"
    - path: "apps/api/src/infrastructure/excel/strategies/profile-mode.strategy.ts"
      provides: "ProfileModeStrategy implementing ExcelParsingStrategy"
      contains: "class ProfileModeStrategy"
    - path: "apps/api/src/infrastructure/excel/excel.module.ts"
      provides: "NestJS module exporting both strategies via Symbol tokens"
      contains: "ExcelModule"
  key_links:
    - from: "apps/api/src/infrastructure/excel/strategies/list-mode.strategy.ts"
      to: "apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts"
      via: "implements ExcelParsingStrategy"
      pattern: "implements ExcelParsingStrategy"
    - from: "apps/api/src/infrastructure/excel/strategies/profile-mode.strategy.ts"
      to: "apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts"
      via: "implements ExcelParsingStrategy"
      pattern: "implements ExcelParsingStrategy"
    - from: "apps/api/src/infrastructure/excel/excel.module.ts"
      to: "apps/api/src/infrastructure/excel/excel.constants.ts"
      via: "Symbol token providers"
      pattern: "LIST_MODE_STRATEGY.*PROFILE_MODE_STRATEGY"
    - from: "apps/api/src/infrastructure/excel/strategies/list-mode.strategy.ts"
      to: "apps/api/src/infrastructure/excel/helpers/cell-access.helper.ts"
      via: "Type map building"
      pattern: "CellAccessHelper"
---

<objective>
Implement ListModeStrategy and ProfileModeStrategy that transform Excel file buffers into normalized ParsedRow arrays, and register both in ExcelModule with Symbol-based DI tokens.

Purpose: These are the two parsing strategies that power the ingestion engine. ListMode handles the common case (one spreadsheet with headers), ProfileMode handles the per-entity case (one file per entity, cell-address keys). Together they fulfill REQ-02, REQ-03, and REQ-09.

Output: Two working strategy implementations and an ExcelModule that exports them for injection by the ingestion service (Phase 3).
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-transaction-excel-parsing/02-RESEARCH.md
@.planning/phases/02-transaction-excel-parsing/02-CONTEXT.md
@.planning/phases/02-transaction-excel-parsing/02-01-SUMMARY.md

@apps/api/src/infrastructure/excel/types/parsed-row.ts
@apps/api/src/infrastructure/excel/types/cell-type-map.ts
@apps/api/src/infrastructure/excel/types/index.ts
@apps/api/src/infrastructure/excel/helpers/cell-access.helper.ts
@apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts
@apps/api/src/infrastructure/excel/excel.constants.ts
@apps/api/src/core/entities/batch.entity.ts
@apps/api/src/core/entities/row.entity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ListModeStrategy and ProfileModeStrategy</name>
  <files>
    apps/api/src/infrastructure/excel/strategies/list-mode.strategy.ts
    apps/api/src/infrastructure/excel/strategies/profile-mode.strategy.ts
  </files>
  <action>
**Implement both Excel parsing strategies.** Both implement `ExcelParsingStrategy` from Plan 01, return `ParseResult` (rows + typeMap), and use `CellAccessHelper` for strict-mode-safe cell access.

---

**ListModeStrategy (`list-mode.strategy.ts`):**

Decorated with `@Injectable()`. Implements `ExcelParsingStrategy`.

`validateFileCount(count: number)`:
- Throw `BadRequestException` (from `@nestjs/common`) if `count !== 1`. Message: `'List mode requires exactly 1 file'`. This fulfills REQ-09.

`parse(files: Array<{ buffer: Buffer; originalName: string }>)`:
1. Call `this.validateFileCount(files.length)`.
2. Get the single file: `const file = files[0]!` (safe after validation).
3. Read workbook: `XLSX.read(file.buffer, { type: 'buffer', cellDates: true, cellNF: true })` -- Pitfall 6 (dates) and Pitfall 18 (use .read not .readFile).
4. Initialize `rows: ParsedRow[]` and `typeMap: CellTypeMap = {}`.
5. Iterate ALL sheets: `for (const sheetName of workbook.SheetNames)` -- CONTEXT.md: all sheets are parsed.
6. For each sheet:
   a. Get sheet: `const sheet = workbook.Sheets[sheetName]!`
   b. Convert to JSON: `XLSX.utils.sheet_to_json<Record<string, unknown>>(sheet, { defval: null, raw: false, blankrows: false })`
      - `defval: null` -- empty cells become null (CONTEXT.md: key present with null value)
      - `raw: false` -- uses formatted values (cell.w), preserving date display format (CONTEXT.md: dates in original Excel display format)
      - `blankrows: false` -- skip completely empty rows
   c. If `jsonData.length === 0`, log warning and `continue` to next sheet (CONTEXT.md: empty sheets succeed with 0 rows).
   d. Map each row to ParsedRow:
      - `rowIndex`: `index + 2` (first data row is Excel row 2, since row 1 is header; 1-indexed)
      - `sheetName`: current sheet name
      - `sourceFileName`: `file.originalName`
      - `data`: the JSON row object. **Normalize undefined to null**: iterate keys and set any `undefined` values to `null`.
   e. Build type map for this sheet using `CellAccessHelper.buildTypeMap(sheet, 'column')`. Merge into the overall typeMap (later sheets overwrite if same column names exist -- acceptable for MVP).
7. Return `{ rows, typeMap }`.

**Key data normalization rules from CONTEXT.md:**
- Empty cells = `null` (handled by `defval: null`)
- Strings stored as-is, no trimming
- Dates in original display format (handled by `raw: false` which uses `cell.w`)
- Numbers stored as raw values (`raw: false` gives formatted strings -- NOTE: this conflicts with "numbers as numbers". Use `raw: true` for native types, but then dates become numbers. Resolution: Use `raw: false` for string safety since CONTEXT.md says "dates in original display format". However CONTEXT.md also says "native JSON types preserved". The best approach: Use `raw: true` to get native types, then post-process to convert Date objects to their display format string using `cell.w`. Actually, the simplest correct approach: use `{ raw: true }` (preserving native types) combined with `cellDates: true` (dates as Date objects). Then in the data normalization step, convert Date objects to their formatted string using the sheet cell's `.w` property. This preserves numbers as numbers and dates as display strings.)

**Revised approach for data:**
- Use `XLSX.utils.sheet_to_json(sheet, { defval: null, blankrows: false })` -- NO `raw: false` (default is `raw: true`, preserving native types)
- With `cellDates: true`, date cells are Date objects in the JSON output
- Post-process: iterate the row data. For each value that is a `Date` instance, look up the corresponding cell's `.w` (formatted text) property and replace the Date with that string. This gives "dates in original display format" while keeping numbers as numbers and booleans as booleans.
- To look up `.w`: For row at index `rowIdx` and column header `key`, find the header's column index, then access the cell at (rowIdx + 1, colIdx) -- or simpler, just call `.toString()` on Date objects if `.w` lookup is too complex. Use the date's toISOString() as fallback.

**Actually, simplest correct approach:**
- Use `raw: false` in sheet_to_json. This gives all values as strings (cell.w formatted text).
- This satisfies "dates in original display format" and preserves exact cell content.
- BUT it violates "native JSON types preserved (numbers as numbers)".

**Final decision (Claude's discretion per CONTEXT.md):** Use `raw: true` (native types). Dates come as Date objects via `cellDates: true`. Convert Date objects to ISO string (`date.toISOString()`) for JSON serialization. This preserves numbers as numbers, booleans as booleans, and dates as standardized strings. The type map tells consumers what the original type was.

---

**ProfileModeStrategy (`profile-mode.strategy.ts`):**

Decorated with `@Injectable()`. Implements `ExcelParsingStrategy`.

`validateFileCount(count: number)`:
- Throw `BadRequestException` if `count < 1`. Message: `'Profile mode requires at least 1 file'`. Accepts 1 to N files (REQ-09).

`parse(files: Array<{ buffer: Buffer; originalName: string }>)`:
1. Call `this.validateFileCount(files.length)`.
2. Initialize `rows: ParsedRow[]` and `typeMap: CellTypeMap = {}`.
3. Iterate each file:
   a. Read workbook: `XLSX.read(file.buffer, { type: 'buffer', cellDates: true, cellNF: true })`.
   b. Iterate ALL sheets in the workbook (CONTEXT.md: all sheets parsed).
   c. For each sheet:
      - Get sheet range: `XLSX.utils.decode_range(sheet['!ref'] || 'A1')`
      - Build cell-address data: iterate all cells (R, C), encode address with `XLSX.utils.encode_cell({ r: R, c: C })`, get value with `CellAccessHelper.getCellValue(sheet, address)`. Result: `Record<string, unknown>` where keys are "A1", "B2", etc.
      - If all cell values are null (empty sheet), log warning and `continue` (CONTEXT.md: empty sheets succeed with 0 rows).
      - Create one ParsedRow per sheet (RESEARCH.md recommendation: each sheet = separate ParsedRow):
        - `rowIndex`: 1 (profile mode: single conceptual row per sheet)
        - `sheetName`: current sheet name
        - `sourceFileName`: `file.originalName`
        - `data`: the cell-address-keyed object
      - Build type map: `CellAccessHelper.buildTypeMap(sheet, 'cell')`. Merge into overall typeMap.
4. Return `{ rows, typeMap }`.

**Date handling in ProfileMode:** Since ProfileMode uses CellAccessHelper.getCellValue() which returns `cell.v`, Date objects will appear as values. Convert Date instances to ISO strings, same as ListMode.

**Shared concerns for both strategies:**
- Use `import * as XLSX from 'xlsx'` (Pitfall 18: ESM/CJS)
- Never use `XLSX.readFile()` (Pitfall 18: server buffers only)
- Always pass `{ cellDates: true, cellNF: true }` (Pitfall 6: dates as numbers)
- Normalize `undefined` to `null` in all data (CONTEXT.md)
- Use `Logger` from `@nestjs/common` for warnings about empty sheets (Pitfall 14)
- Error messages include file name (CONTEXT.md: error messages are specific)

**What to avoid:**
- Do NOT handle merged cells specially -- MVP documents this limitation (Pitfall 8 from research)
- Do NOT attempt formula evaluation -- use cached `.v` values (Pitfall 9)
- Do NOT add a parse timeout -- the 5MB upload limit constrains decompression (Pitfall 7, deferred per research)
- Do NOT use `header: 1` in ListMode sheet_to_json -- default behavior auto-detects first row as header
  </action>
  <verify>
1. `cd apps/api && npx tsc --noEmit` compiles without errors
2. Both strategy files exist and implement ExcelParsingStrategy
3. `grep -r "cellDates: true" apps/api/src/infrastructure/excel/strategies/` confirms both strategies use cellDates
4. `grep -r "BadRequestException" apps/api/src/infrastructure/excel/strategies/` confirms file count validation
5. `grep -r "sourceFileName" apps/api/src/infrastructure/excel/strategies/` confirms traceability
  </verify>
  <done>
ListModeStrategy parses single file buffer into N ParsedRow objects with header keys across all sheets, rejects >1 file. ProfileModeStrategy parses N files into ParsedRow objects with cell-address keys (one per sheet), accepts 1..N files. Both set sourceFileName, use cellDates: true, normalize undefined to null, build type maps. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExcelModule with Symbol-based providers</name>
  <files>
    apps/api/src/infrastructure/excel/excel.module.ts
  </files>
  <action>
**Create `apps/api/src/infrastructure/excel/excel.module.ts`** that registers both strategies with Symbol-based DI tokens and exports them.

```typescript
import { Module } from '@nestjs/common';
import { LIST_MODE_STRATEGY, PROFILE_MODE_STRATEGY } from './excel.constants';
import { ListModeStrategy } from './strategies/list-mode.strategy';
import { ProfileModeStrategy } from './strategies/profile-mode.strategy';

@Module({
  providers: [
    {
      provide: LIST_MODE_STRATEGY,
      useClass: ListModeStrategy,
    },
    {
      provide: PROFILE_MODE_STRATEGY,
      useClass: ProfileModeStrategy,
    },
  ],
  exports: [LIST_MODE_STRATEGY, PROFILE_MODE_STRATEGY],
})
export class ExcelModule {}
```

Key points:
- Each strategy gets its own Symbol token (Pitfall 12: prevents DI overwrite)
- Both tokens are exported so other modules (Phase 3: IngestionModule) can inject them
- Do NOT register ExcelModule in AppModule yet -- Phase 3's IngestionModule will import it
- Do NOT use `@Global()` -- only modules that genuinely need strategies will import ExcelModule

**What to avoid:**
- Do NOT use string tokens like `'LIST_MODE'` -- Symbol tokens prevent collisions
- Do NOT add ExcelModule to AppModule imports -- it will be imported by IngestionModule in Phase 3
  </action>
  <verify>
1. `cd apps/api && npx tsc --noEmit` compiles without errors
2. `cd apps/api && pnpm run build` succeeds (NestJS build with all modules)
3. `grep "LIST_MODE_STRATEGY" apps/api/src/infrastructure/excel/excel.module.ts` confirms Symbol token usage
4. `grep "exports" apps/api/src/infrastructure/excel/excel.module.ts` confirms both tokens exported
  </verify>
  <done>
ExcelModule registers ListModeStrategy and ProfileModeStrategy with distinct Symbol tokens. Both strategies are exported for downstream injection. NestJS build passes. Module is ready for import by Phase 3's IngestionModule.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/api && npx tsc --noEmit` -- all new files compile under strict TypeScript
2. `cd apps/api && pnpm run build` -- NestJS build succeeds
3. Both strategies implement ExcelParsingStrategy interface
4. ListModeStrategy rejects >1 file with BadRequestException
5. ProfileModeStrategy accepts 1..N files
6. Both strategies use `cellDates: true, cellNF: true` in XLSX.read()
7. Both strategies set `sourceFileName` on every ParsedRow
8. Both strategies normalize undefined values to null
9. ExcelModule exports both strategies via Symbol tokens
10. Type maps are built using CellAccessHelper
</verification>

<success_criteria>
- ListModeStrategy: single file -> N ParsedRow objects with header-based keys, all sheets parsed
- ProfileModeStrategy: N files -> N ParsedRow objects (per sheet) with cell-address keys
- File count validation: list rejects >1, profile rejects <1
- sourceFileName set on every row for traceability
- cellDates: true ensures dates are not raw numbers
- undefined normalized to null in all data
- Type maps built for batch entity metadata
- ExcelModule exports both strategies via Symbol tokens
- Full TypeScript + NestJS build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-transaction-excel-parsing/02-02-SUMMARY.md`
</output>
