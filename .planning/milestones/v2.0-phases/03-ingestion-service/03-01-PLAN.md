---
phase: 03-ingestion-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/infrastructure/excel/ingestion.service.ts
autonomous: true

must_haves:
  truths:
    - "IngestionService selects ListModeStrategy when mode is BatchMode.ListMode"
    - "IngestionService selects ProfileModeStrategy when mode is BatchMode.ProfileMode"
    - "IngestionService throws an error for unknown batch modes"
    - "IngestionService delegates file count validation to the selected strategy"
    - "IngestionService delegates parsing to the selected strategy and never imports xlsx"
    - "IngestionService creates a batch record via BatchRepository with correct fields"
    - "IngestionService persists rows via RowRepository.createMany with correct mapping from ParsedRow to CreateRowData"
    - "IngestionService converts ParseResult.typeMap to ColumnMetadata[] via buildColumnMetadata"
    - "IngestionService returns IngestResult with batchId and rowCount"
    - "IngestionService does NOT use @Transactional() decorator (transaction boundary is at use case layer)"
  artifacts:
    - path: "apps/api/src/infrastructure/excel/ingestion.service.ts"
      provides: "IngestionService with strategy selection and parse-persist orchestration"
      contains: "class IngestionService"
      exports: ["IngestionService", "IngestInput", "IngestResult"]
  key_links:
    - from: "apps/api/src/infrastructure/excel/ingestion.service.ts"
      to: "apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts"
      via: "Inject Symbol tokens for strategy instances"
      pattern: "LIST_MODE_STRATEGY.*PROFILE_MODE_STRATEGY"
    - from: "apps/api/src/infrastructure/excel/ingestion.service.ts"
      to: "apps/api/src/core/repositories/batch.repository.ts"
      via: "Constructor injection of abstract BatchRepository"
      pattern: "BatchRepository"
    - from: "apps/api/src/infrastructure/excel/ingestion.service.ts"
      to: "apps/api/src/core/repositories/row.repository.ts"
      via: "Constructor injection of abstract RowRepository"
      pattern: "RowRepository"
    - from: "apps/api/src/infrastructure/excel/ingestion.service.ts"
      to: "apps/api/src/core/entities/batch.entity.ts"
      via: "Uses BatchMode, ColumnMetadata, CreateBatchData types"
      pattern: "BatchMode.*ColumnMetadata"
---

<objective>
Implement IngestionService that selects the correct parsing strategy based on BatchMode and orchestrates the parse-then-persist flow without containing any parsing logic.

Purpose: This is the orchestration layer that connects Phase 2's parsing strategies with Phase 1's persistence repositories. It coordinates: strategy selection -> file validation -> parsing -> batch creation -> row persistence, keeping each concern in its proper layer.

Output: A single `ingestion.service.ts` file with `IngestionService` class, `IngestInput` interface, and `IngestResult` interface.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-ingestion-service/03-RESEARCH.md

@apps/api/src/core/entities/batch.entity.ts
@apps/api/src/core/entities/row.entity.ts
@apps/api/src/core/repositories/batch.repository.ts
@apps/api/src/core/repositories/row.repository.ts
@apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts
@apps/api/src/infrastructure/excel/excel.constants.ts
@apps/api/src/infrastructure/excel/types/parsed-row.ts
@apps/api/src/infrastructure/excel/types/cell-type-map.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IngestionService with IngestInput/IngestResult interfaces</name>
  <files>
    apps/api/src/infrastructure/excel/ingestion.service.ts
  </files>
  <action>
**Create `apps/api/src/infrastructure/excel/ingestion.service.ts`** with the service class and supporting interfaces.

**Interfaces (exported, defined at top of file):**

```typescript
export interface IngestInput {
  projectId: string;
  userId: string;
  mode: BatchMode;
  files: ExcelFileInput[];
}

export interface IngestResult {
  batchId: string;
  rowCount: number;
}
```

**Class: `IngestionService`**

Decorated with `@Injectable()` from `@nestjs/common`.

**Constructor injection (4 dependencies):**
1. `@Inject(LIST_MODE_STRATEGY) private readonly listModeStrategy: ExcelParsingStrategy` -- Symbol token from `excel.constants.ts`
2. `@Inject(PROFILE_MODE_STRATEGY) private readonly profileModeStrategy: ExcelParsingStrategy` -- Symbol token from `excel.constants.ts`
3. `private readonly batchRepository: BatchRepository` -- abstract class from Core layer, resolved by DrizzleModule (@Global)
4. `private readonly rowRepository: RowRepository` -- abstract class from Core layer, resolved by DrizzleModule (@Global)

**Method: `public async ingest(input: IngestInput): Promise<IngestResult>`**

Orchestration flow (NO parsing logic, NO transaction management):
1. Select strategy: `const strategy = this.getStrategy(input.mode);`
2. Validate file count: `strategy.validateFileCount(input.files.length);` -- delegates to strategy (throws BadRequestException if invalid)
3. Parse files: `const parseResult = strategy.parse(input.files);` -- delegates to strategy
4. Build column metadata: `const columnMetadata = this.buildColumnMetadata(parseResult.typeMap);`
5. Create batch record:
   ```typescript
   const batch = await this.batchRepository.create({
     projectId: input.projectId,
     userId: input.userId,
     mode: input.mode,
     fileCount: input.files.length,
     rowCount: parseResult.rows.length,
     columnMetadata,
   });
   ```
   The argument matches `CreateBatchData` from `batch.entity.ts`. `batchRepository.create()` returns `Promise<Batch>`.
6. Map parsed rows to CreateRowData:
   ```typescript
   const rowData: CreateRowData[] = parseResult.rows.map((row) => ({
     batchId: batch.id,
     data: row.data,
     status: RowStatus.Valid,
     validationMessages: [],
     sourceFileName: row.sourceFileName,
     sourceSheetName: row.sheetName,
     sourceRowIndex: row.rowIndex,
   }));
   ```
   Note: `status` and `validationMessages` are optional in `CreateRowData` but we set explicit defaults for clarity. All rows default to `RowStatus.Valid` for MVP.
7. Persist rows: `await this.rowRepository.createMany(rowData);` -- returns `Promise<void>`, chunking handled internally by repository
8. Return result: `return { batchId: batch.id, rowCount: parseResult.rows.length };`

**Method: `private getStrategy(mode: BatchMode): ExcelParsingStrategy`**

Simple if/else for 2 strategies (research confirmed map overhead not justified for MVP with only 2 strategies):
```typescript
if (mode === BatchMode.ListMode) {
  return this.listModeStrategy;
}

if (mode === BatchMode.ProfileMode) {
  return this.profileModeStrategy;
}

throw new Error(`Unknown batch mode: ${String(mode)}`);
```

Note: The phase goal says "without any if/else parsing logic in the service itself". The getStrategy() method is NOT parsing logic -- it is strategy SELECTION logic (choosing which strategy to delegate to). The prohibition is against the service containing if/else for HOW to parse (e.g., `if listMode then XLSX.read()...`). Strategy selection via getStrategy() is the standard Strategy Pattern dispatch.

**Method: `private buildColumnMetadata(typeMap: Record<string, CellType>): ColumnMetadata[]`**

Converts ParseResult.typeMap to ColumnMetadata array:
```typescript
return Object.entries(typeMap).map(([key, inferredType], index) => ({
  originalHeader: key,
  normalizedKey: key,
  inferredType,
  position: index,
}));
```

`CellType` enum values are strings (`'string'`, `'number'`, etc.) which are assignable to `ColumnMetadata.inferredType: string`. The `key` serves as both `originalHeader` and `normalizedKey` for MVP (ListMode: column letters, ProfileMode: cell addresses).

**Imports (use exact paths):**
```typescript
import { Inject, Injectable } from '@nestjs/common';

import { BatchMode, ColumnMetadata } from '../../core/entities/batch.entity';
import { RowStatus } from '../../core/entities/row.entity';
import type { CreateRowData } from '../../core/entities/row.entity';
import { BatchRepository } from '../../core/repositories/batch.repository';
import { RowRepository } from '../../core/repositories/row.repository';
import { LIST_MODE_STRATEGY, PROFILE_MODE_STRATEGY } from './excel.constants';
import type { ExcelParsingStrategy, ExcelFileInput } from './strategies/excel-parsing.strategy';
import type { CellType } from './types';
```

Note: Use `import type` for interfaces/types that are only used as type annotations (ExcelParsingStrategy, ExcelFileInput, CellType, CreateRowData). Use value imports for classes, enums, and Symbols that are referenced at runtime.

**What to avoid:**
- Do NOT import from `xlsx` -- service has zero parsing logic
- Do NOT import from `infrastructure/database/` -- use abstract repositories from Core
- Do NOT add `@Transactional()` decorator -- transaction boundary is Phase 5 use case
- Do NOT add try/catch for database errors -- let errors bubble up to use case layer
- Do NOT add a Map for strategy selection -- if/else is cleaner for exactly 2 strategies
- Do NOT create a barrel re-export (index.ts) in the excel directory -- Phase 4 IngestionModule handles registration
  </action>
  <verify>
1. `cd /Users/luanmartins/source/projects/populatte/apps/api && npx tsc --noEmit` compiles without errors
2. File exists: `ls apps/api/src/infrastructure/excel/ingestion.service.ts`
3. No xlsx import: `grep -c "from 'xlsx'" apps/api/src/infrastructure/excel/ingestion.service.ts` returns 0
4. No @Transactional: `grep -c "@Transactional" apps/api/src/infrastructure/excel/ingestion.service.ts` returns 0
5. Uses abstract repos: `grep "BatchRepository\|RowRepository" apps/api/src/infrastructure/excel/ingestion.service.ts` shows imports from `../../core/repositories/`
6. Strategy injection: `grep "LIST_MODE_STRATEGY\|PROFILE_MODE_STRATEGY" apps/api/src/infrastructure/excel/ingestion.service.ts` confirms both tokens
7. Exports IngestInput and IngestResult: `grep "export interface Ingest" apps/api/src/infrastructure/excel/ingestion.service.ts` shows both
  </verify>
  <done>
IngestionService exists with: (1) getStrategy() selects correct strategy based on BatchMode without parsing logic, (2) ingest() orchestrates validate -> parse -> create batch -> persist rows, (3) buildColumnMetadata() converts typeMap to ColumnMetadata[], (4) IngestInput and IngestResult interfaces exported, (5) no xlsx imports, no @Transactional, no concrete repository imports. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/api && npx tsc --noEmit` -- strict TypeScript compilation passes
2. `ingestion.service.ts` exports IngestionService class, IngestInput interface, IngestResult interface
3. IngestionService injects LIST_MODE_STRATEGY and PROFILE_MODE_STRATEGY via Symbol tokens
4. IngestionService injects BatchRepository and RowRepository from Core layer (abstract classes)
5. getStrategy() returns correct strategy for ListMode and ProfileMode, throws for unknown modes
6. ingest() calls strategy.validateFileCount() before parsing
7. ingest() calls strategy.parse() to get ParseResult (no direct xlsx usage)
8. ingest() creates batch via batchRepository.create() with correct CreateBatchData fields
9. ingest() maps ParsedRow[] to CreateRowData[] with RowStatus.Valid default
10. ingest() persists rows via rowRepository.createMany()
11. ingest() returns { batchId, rowCount }
12. No @Transactional decorator on any method
13. No import from 'xlsx'
14. No import from infrastructure/database/ (only core/repositories/)
</verification>

<success_criteria>
- IngestionService selects correct strategy via getStrategy() based on BatchMode
- ingest() orchestrates: strategy selection -> file validation -> parsing -> batch creation -> row persistence -> return result
- No parsing logic in service (no xlsx import)
- No transaction management (no @Transactional)
- Abstract repository injection from Core layer
- TypeScript strict compilation passes
- IngestInput and IngestResult interfaces exported for use by Phase 5 CreateBatchUseCase
</success_criteria>

<output>
After completion, create `.planning/phases/03-ingestion-service/03-01-SUMMARY.md`
</output>
