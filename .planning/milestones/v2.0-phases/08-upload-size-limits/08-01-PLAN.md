---
phase: 08-upload-size-limits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/infrastructure/config/upload.config.ts
  - apps/api/src/infrastructure/config/env.validation.ts
  - apps/api/src/infrastructure/config/index.ts
  - apps/api/src/infrastructure/upload/filters/multer-exception.filter.ts
  - apps/api/src/infrastructure/upload/middleware/content-length.middleware.ts
  - apps/api/src/presentation/controllers/batch.controller.ts
  - apps/api/src/infrastructure/batch/batch.module.ts
  - apps/api/src/app.module.ts
  - apps/api/src/main.ts
autonomous: true

must_haves:
  truths:
    - "Uploading a file larger than 5MB to POST /projects/:projectId/batches returns HTTP 413 with descriptive error"
    - "Uploading more than 50 files to POST /projects/:projectId/batches returns HTTP 413 with descriptive error"
    - "Sending a request with Content-Length exceeding the computed threshold is rejected early with HTTP 413 before Multer buffering"
    - "Requests without Content-Length header pass through to Multer for standard limit enforcement"
    - "Limits are configurable via UPLOAD_MAX_FILE_SIZE and UPLOAD_MAX_FILE_COUNT environment variables"
    - "Upload limit violations are logged with userId, reason, and request path"
  artifacts:
    - path: "apps/api/src/infrastructure/config/upload.config.ts"
      provides: "registerAs('upload') config namespace with maxFileSize and maxFileCount"
      contains: "registerAs"
    - path: "apps/api/src/infrastructure/upload/filters/multer-exception.filter.ts"
      provides: "Global exception filter catching MulterError and returning 413"
      contains: "MulterExceptionFilter"
    - path: "apps/api/src/infrastructure/upload/middleware/content-length.middleware.ts"
      provides: "Route-scoped middleware for early Content-Length rejection"
      contains: "ContentLengthMiddleware"
  key_links:
    - from: "apps/api/src/main.ts"
      to: "MulterExceptionFilter"
      via: "app.useGlobalFilters()"
      pattern: "useGlobalFilters.*MulterExceptionFilter"
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "upload config"
      via: "FilesInterceptor limits object with env-driven values"
      pattern: "limits.*fileSize"
    - from: "apps/api/src/infrastructure/batch/batch.module.ts"
      to: "ContentLengthMiddleware"
      via: "NestModule.configure() with MiddlewareConsumer"
      pattern: "configure.*ContentLengthMiddleware"
---

<objective>
Configure Multer upload limits (5MB per file, 50 files per request) via environment variables, create a global MulterExceptionFilter that returns HTTP 413 with detailed error info, and implement route-scoped Content-Length middleware for early rejection of oversized requests.

Purpose: Prevent memory exhaustion and abuse by enforcing upload limits at the interceptor level, rejecting oversized uploads before any Excel parsing occurs (Pitfall 4 mitigation). Content-Length middleware provides an optimization to reject obviously oversized requests before Multer starts buffering (Pitfall 15 mitigation).

Output: Upload config, MulterExceptionFilter (global), ContentLengthMiddleware (route-scoped), updated FilesInterceptor with limits, environment variable support.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-upload-size-limits/08-CONTEXT.md
@.planning/phases/08-upload-size-limits/08-RESEARCH.md
@.planning/phases/07-batch-endpoint/07-01-SUMMARY.md

# Key source files to reference
@apps/api/src/infrastructure/config/clerk.config.ts      -- registerAs pattern to follow
@apps/api/src/infrastructure/config/env.validation.ts     -- Joi schema to extend
@apps/api/src/infrastructure/config/index.ts              -- barrel to update
@apps/api/src/presentation/controllers/batch.controller.ts -- FilesInterceptor to update
@apps/api/src/infrastructure/batch/batch.module.ts        -- add NestModule + middleware
@apps/api/src/app.module.ts                               -- add uploadConfig to ConfigModule.load
@apps/api/src/main.ts                                     -- register global filter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upload config, Multer limits, and MulterExceptionFilter</name>
  <files>
    apps/api/src/infrastructure/config/upload.config.ts
    apps/api/src/infrastructure/config/env.validation.ts
    apps/api/src/infrastructure/config/index.ts
    apps/api/src/infrastructure/upload/filters/multer-exception.filter.ts
    apps/api/src/presentation/controllers/batch.controller.ts
    apps/api/src/app.module.ts
    apps/api/src/main.ts
  </files>
  <action>
    **1. Create upload config** (`apps/api/src/infrastructure/config/upload.config.ts`):
    - Follow the `clerk.config.ts` pattern exactly (registerAs + typed export)
    - `registerAs('upload', () => ({ ... }))`
    - `maxFileSize`: `parseInt(process.env['UPLOAD_MAX_FILE_SIZE'] ?? '5242880', 10)` with comment `// 5MB default`
    - `maxFileCount`: `parseInt(process.env['UPLOAD_MAX_FILE_COUNT'] ?? '50', 10)`
    - Export `UploadConfig` type alias: `export type UploadConfig = ReturnType<typeof uploadConfig>;`

    **2. Update env validation** (`apps/api/src/infrastructure/config/env.validation.ts`):
    - Add after existing fields:
      ```
      UPLOAD_MAX_FILE_SIZE: Joi.number().default(5 * 1024 * 1024).description('Maximum file size in bytes'),
      UPLOAD_MAX_FILE_COUNT: Joi.number().default(50).description('Maximum number of files per request'),
      ```

    **3. Update config barrel** (`apps/api/src/infrastructure/config/index.ts`):
    - Add `export * from './upload.config';`

    **4. Register upload config in AppModule** (`apps/api/src/app.module.ts`):
    - Import `uploadConfig` from `./infrastructure/config`
    - Add `uploadConfig` to `ConfigModule.forRoot({ load: [clerkConfig, databaseConfig, uploadConfig] })`

    **5. Create MulterExceptionFilter** (`apps/api/src/infrastructure/upload/filters/multer-exception.filter.ts`):
    - Create directory structure: `infrastructure/upload/filters/`
    - Use `@Catch()` decorator -- import `MulterError` from `multer` (use `import { MulterError } from 'multer';`)
    - Inject `Logger` with `private readonly logger = new Logger(MulterExceptionFilter.name);`
    - In `catch()` method:
      - Extract `request` from `ArgumentsHost` via `host.switchToHttp().getRequest()`
      - Extract user from `request` (cast as needed: `(request as Record<string, unknown>)['user']`) for logging
      - Map error codes to messages:
        - `LIMIT_FILE_SIZE` -> `'File size exceeds the maximum allowed size'`
        - `LIMIT_FILE_COUNT` -> `'Too many files uploaded'`
        - All other codes -> `'File upload limit exceeded'`
      - Determine HTTP status: `LIMIT_FILE_SIZE` and `LIMIT_FILE_COUNT` -> 413; `LIMIT_UNEXPECTED_FILE` -> 400; others -> 413
      - Log at `warn` level: include `exception.code`, `exception.field`, user ID (if available), `request.path`
      - Return JSON response matching existing API format:
        ```json
        {
          "statusCode": 413,
          "message": "<mapped message>",
          "error": "Payload Too Large",
          "details": { "code": "<exception.code>", "field": "<exception.field>" }
        }
        ```
    - Do NOT use `import * as multer from 'multer'` (avoid namespace import); use `import { MulterError } from 'multer'` directly

    **6. Register filter globally in main.ts** (`apps/api/src/main.ts`):
    - Import `MulterExceptionFilter` from `./infrastructure/upload/filters/multer-exception.filter`
    - Add `app.useGlobalFilters(new MulterExceptionFilter());` BEFORE `app.listen()`

    **7. Update FilesInterceptor with limits** (`apps/api/src/presentation/controllers/batch.controller.ts`):
    - Change `FilesInterceptor('documents', 20)` to `FilesInterceptor('documents', 50, { limits: { fileSize: 5 * 1024 * 1024, files: 50 } })`
    - Note: Hardcoded limits in the decorator as FilesInterceptor options are static (not injectable). The environment-driven config is used by Content-Length middleware and for documentation. Multer limits in the interceptor serve as the definitive enforcement layer.
    - **Important:** The `maxCount` parameter (2nd arg) and `limits.files` must both be 50 to match (Pitfall 1 from Research).

    **Commit:** `feat(08-01): add upload config, MulterExceptionFilter, and Multer limits`
  </action>
  <verify>
    - `cd apps/api && npx tsc --noEmit` passes with no errors
    - `cd apps/api && npx eslint src/ --ext .ts` passes with no errors
    - Verify `upload.config.ts` exports `uploadConfig` and `UploadConfig`
    - Verify `env.validation.ts` includes both `UPLOAD_MAX_FILE_SIZE` and `UPLOAD_MAX_FILE_COUNT`
    - Verify `main.ts` registers `MulterExceptionFilter` via `useGlobalFilters`
    - Verify `batch.controller.ts` has `FilesInterceptor('documents', 50, { limits: { fileSize: 5 * 1024 * 1024, files: 50 } })`
  </verify>
  <done>
    - Upload config registered with registerAs('upload') and loaded in AppModule
    - Env validation schema accepts UPLOAD_MAX_FILE_SIZE and UPLOAD_MAX_FILE_COUNT with sensible defaults
    - MulterExceptionFilter catches MulterError, returns 413 with detailed error body, logs with userId
    - Filter registered globally in main.ts bootstrap
    - FilesInterceptor enforces 5MB/file and 50 files/request via limits object
    - TypeScript compilation and ESLint pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Content-Length middleware and BatchModule wiring</name>
  <files>
    apps/api/src/infrastructure/upload/middleware/content-length.middleware.ts
    apps/api/src/infrastructure/batch/batch.module.ts
  </files>
  <action>
    **1. Create ContentLengthMiddleware** (`apps/api/src/infrastructure/upload/middleware/content-length.middleware.ts`):
    - Create directory: `infrastructure/upload/middleware/`
    - Implement `NestMiddleware` interface with `use(req, res, next)` method
    - Inject `ConfigService` via constructor
    - In `use()`:
      - Read `content-length` header from request: `const contentLength = req.headers['content-length'];`
      - If no Content-Length header, call `next()` immediately (pass through to Multer per CONTEXT.md)
      - Read config values: `this.configService.get<number>('upload.maxFileSize', 5242880)` and `this.configService.get<number>('upload.maxFileCount', 50)`
      - Calculate threshold: `(maxFileSize * maxFileCount) + (1024 * 100)` (100KB overhead for multipart boundaries/metadata)
      - Parse content-length: `parseInt(contentLength, 10)`
      - If parsed value > threshold:
        - Log at `warn` level with `Logger`: include content-length value, threshold, request path
        - Return `res.status(HttpStatus.PAYLOAD_TOO_LARGE).json({ statusCode: HttpStatus.PAYLOAD_TOO_LARGE, message: 'Request payload too large', error: 'Payload Too Large' })`
      - Otherwise, call `next()`
    - Use `private readonly logger = new Logger(ContentLengthMiddleware.name);`
    - Import types from express: `Request`, `Response`, `NextFunction`
    - Import `Injectable`, `NestMiddleware`, `Logger`, `HttpStatus` from `@nestjs/common`
    - Import `ConfigService` from `@nestjs/config`

    **2. Update BatchModule to apply middleware** (`apps/api/src/infrastructure/batch/batch.module.ts`):
    - Make `BatchModule` implement `NestModule` interface
    - Add `configure(consumer: MiddlewareConsumer)` method
    - Apply `ContentLengthMiddleware` to batch upload route:
      ```typescript
      consumer
        .apply(ContentLengthMiddleware)
        .forRoutes({ path: 'projects/:projectId/batches', method: RequestMethod.POST });
      ```
    - Import `NestModule`, `MiddlewareConsumer`, `RequestMethod` from `@nestjs/common`
    - Import `ContentLengthMiddleware` from `../upload/middleware/content-length.middleware`

    **Commit:** `feat(08-01): add Content-Length middleware for early upload rejection`
  </action>
  <verify>
    - `cd apps/api && npx tsc --noEmit` passes with no errors
    - `cd apps/api && npx eslint src/ --ext .ts` passes with no errors
    - Verify `content-length.middleware.ts` injects ConfigService and reads upload config
    - Verify `batch.module.ts` implements NestModule and configures middleware for POST route
  </verify>
  <done>
    - ContentLengthMiddleware checks Content-Length header against computed threshold
    - Requests without Content-Length pass through to Multer
    - Oversized requests rejected early with 413 before Multer buffering begins
    - Middleware scoped to POST /projects/:projectId/batches only
    - Rejection logged at warn level with request details
    - BatchModule wires middleware via configure()
    - TypeScript compilation and ESLint pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript compilation:** `cd apps/api && npx tsc --noEmit` -- zero errors
2. **ESLint:** `cd apps/api && npx eslint src/ --ext .ts` -- zero errors
3. **Config loaded:** AppModule loads uploadConfig alongside clerkConfig and databaseConfig
4. **Global filter registered:** main.ts calls `app.useGlobalFilters(new MulterExceptionFilter())`
5. **Multer limits set:** FilesInterceptor uses `limits: { fileSize: 5 * 1024 * 1024, files: 50 }`
6. **Middleware wired:** BatchModule.configure() applies ContentLengthMiddleware to POST batch route
7. **Environment variables:** Joi schema validates UPLOAD_MAX_FILE_SIZE and UPLOAD_MAX_FILE_COUNT with defaults
</verification>

<success_criteria>
Multer enforces max 5MB per file and max 50 files per request at the interceptor level. Oversized files are rejected with a clear HTTP 413 error (with code, field, and message details) before any parsing occurs. Content-Length middleware provides early rejection for obviously oversized requests. All limits are configurable via environment variables. Rejection events are logged with userId context.
</success_criteria>

<output>
After completion, create `.planning/phases/08-upload-size-limits/08-01-SUMMARY.md`
</output>
