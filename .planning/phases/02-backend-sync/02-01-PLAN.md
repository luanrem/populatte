---
phase: 02-backend-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/infrastructure/auth/clerk.service.ts
  - apps/api/src/core/use-cases/user/sync-user.use-case.ts
  - apps/api/src/infrastructure/health/sync-failure.indicator.ts
  - apps/api/src/infrastructure/health/health.controller.ts
  - apps/api/src/infrastructure/health/health.module.ts
  - apps/api/src/app.module.ts
  - apps/api/package.json
autonomous: true

must_haves:
  truths:
    - "ClerkService.verifySessionToken() returns email, firstName, lastName, imageUrl from JWT payload"
    - "SyncUserUseCase.execute() calls userRepository.upsert() instead of find+update/create"
    - "GET /health returns health check status with sync failure rate"
    - "SyncFailureIndicator tracks sync attempts and failures with 5% threshold"
  artifacts:
    - path: "apps/api/src/infrastructure/auth/clerk.service.ts"
      provides: "Full JWT claim extraction"
      contains: "email.*firstName.*lastName.*imageUrl"
    - path: "apps/api/src/core/use-cases/user/sync-user.use-case.ts"
      provides: "Atomic user sync via upsert"
      contains: "this.userRepository.upsert"
    - path: "apps/api/src/infrastructure/health/sync-failure.indicator.ts"
      provides: "Sync failure rate tracking"
      contains: "recordSyncAttempt"
    - path: "apps/api/src/infrastructure/health/health.controller.ts"
      provides: "Health check endpoint"
      contains: "@HealthCheck"
    - path: "apps/api/src/infrastructure/health/health.module.ts"
      provides: "Health module wiring"
      exports: ["SyncFailureIndicator"]
  key_links:
    - from: "apps/api/src/infrastructure/health/health.module.ts"
      to: "apps/api/src/app.module.ts"
      via: "Module import"
      pattern: "HealthModule"
    - from: "apps/api/src/infrastructure/health/health.controller.ts"
      to: "apps/api/src/infrastructure/health/sync-failure.indicator.ts"
      via: "DI constructor injection"
      pattern: "SyncFailureIndicator"
---

<objective>
Build the foundation services for Phase 2 guard-based sync: extend ClerkService to extract all JWT claims, fix SyncUserUseCase to use the upsert method, and create the health monitoring infrastructure.

Purpose: These three independent components must exist before the guard can be enhanced (Plan 02-02). ClerkService provides JWT claim data, SyncUserUseCase is corrected per Phase 1 verifier blocker, and HealthModule provides sync failure tracking.

Output: Extended ClerkService with full claim extraction, fixed SyncUserUseCase using upsert, and working health endpoint with sync failure indicator.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-prerequisites/01-01-SUMMARY.md
@apps/api/src/infrastructure/auth/clerk.service.ts
@apps/api/src/core/use-cases/user/sync-user.use-case.ts
@apps/api/src/core/entities/user.entity.ts
@apps/api/src/core/repositories/user.repository.ts
@apps/api/src/app.module.ts
@apps/api/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ClerkService to extract full JWT claims</name>
  <files>apps/api/src/infrastructure/auth/clerk.service.ts</files>
  <action>
Modify `ClerkService.verifySessionToken()` to extract custom claims from the verified JWT payload.

Current state: The method verifies the token but only returns `{ sub: result.sub }`, discarding all custom claims configured in the Clerk JWT template (email, firstName, lastName, imageUrl).

Changes needed:

1. Add a `Logger` instance to `ClerkService` for warning on token verification failures (use `new Logger(ClerkService.name)` from `@nestjs/common`).

2. Update the `ClerkTokenPayload` interface -- the `email` field should be `string` (not `string | undefined`) since it is a required claim. Keep `firstName`, `lastName`, `imageUrl` as optional (`string | undefined`).

3. In the `verifySessionToken()` method, after `verifyToken()` succeeds, extract the custom claims from the result object. Clerk adds custom JWT template claims directly to the token payload root level. Cast appropriately:
   ```typescript
   return {
     sub: result.sub,
     email: result.email as string,
     firstName: result.firstName as string | undefined,
     lastName: result.lastName as string | undefined,
     imageUrl: result.imageUrl as string | undefined,
   };
   ```

4. Update the `catch` block to use the logger: `this.logger.warn('Token verification failed', error)` instead of silently returning null. Still return `null` after logging.

Do NOT change the `getWebhookSigningSecret()` method. Do NOT add or remove any imports beyond `Logger`. Preserve the existing constructor injection pattern.
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit --project apps/api/tsconfig.json` -- TypeScript compilation should pass with no errors.

Verify the ClerkTokenPayload interface has `email: string` (not optional) and the other three fields as `string | undefined`.
  </verify>
  <done>
ClerkService.verifySessionToken() returns ClerkTokenPayload with sub, email (required), firstName, lastName, imageUrl (optional). Logger warns on verification failures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix SyncUserUseCase to use upsert and create health module</name>
  <files>
apps/api/src/core/use-cases/user/sync-user.use-case.ts
apps/api/src/infrastructure/health/sync-failure.indicator.ts
apps/api/src/infrastructure/health/health.controller.ts
apps/api/src/infrastructure/health/health.module.ts
apps/api/src/app.module.ts
apps/api/package.json
  </files>
  <action>
This task has two parts: fix the SyncUserUseCase blocker and create the health monitoring module.

**Part A: Fix SyncUserUseCase**

The Phase 1 verifier found that SyncUserUseCase still uses find+update/create instead of the upsert() method added in Phase 1. Simplify the execute() method:

1. Remove the `findByClerkId` call, the `if (existingUser)` branch, and the separate `create` path.
2. Replace with a single call to `this.userRepository.upsert(input)` which handles both create and update atomically.
3. Remove the `CreateUserData` and `UpdateUserData` imports (no longer needed). Add `UpsertUserData` import.
4. Keep the `SyncUserInput` interface unchanged -- it aligns with `UpsertUserData`.
5. The method becomes approximately:
   ```typescript
   public async execute(input: SyncUserInput): Promise<User> {
     return this.userRepository.upsert({
       clerkId: input.clerkId,
       email: input.email,
       firstName: input.firstName ?? null,
       lastName: input.lastName ?? null,
       imageUrl: input.imageUrl ?? null,
     });
   }
   ```

**Part B: Install @nestjs/terminus and create health module**

1. Install `@nestjs/terminus`:
   ```bash
   cd apps/api && pnpm add @nestjs/terminus
   ```

2. Create `apps/api/src/infrastructure/health/sync-failure.indicator.ts`:
   - Injectable class `SyncFailureIndicator`
   - Private fields: `syncFailures = 0`, `syncAttempts = 0`, `failureThreshold = 0.05`
   - Constructor injects `HealthIndicatorService` from `@nestjs/terminus`
   - Public method `recordSyncAttempt(success: boolean): void` -- increments counters, resets (halves both) when syncAttempts reaches 1000
   - Public async method `isHealthy(key: string)` -- uses `this.healthIndicatorService.check(key)` to create indicator, returns `up` or `down` based on failure rate vs threshold. Include syncAttempts, syncFailures, failureRate in the indicator data.
   - When syncAttempts is 0, return `up` with zero values (no data yet = healthy)
   - Use `failureRate.toFixed(3)` for the rate string

3. Create `apps/api/src/infrastructure/health/health.controller.ts`:
   - `@Controller('health')` class `HealthController`
   - Constructor injects `HealthCheckService` from `@nestjs/terminus` and `SyncFailureIndicator`
   - Single `@Get()` method decorated with `@HealthCheck()` that calls `this.health.check([() => this.syncFailure.isHealthy('user-sync')])`
   - This endpoint must NOT require authentication (no `@UseGuards`). It is a public monitoring endpoint.
   - Use explicit `public` access modifier on all methods per NestJS conventions.

4. Create `apps/api/src/infrastructure/health/health.module.ts`:
   - Import `TerminusModule` from `@nestjs/terminus`
   - Declare `HealthController` in controllers
   - Declare `SyncFailureIndicator` in providers
   - Export `SyncFailureIndicator` (so the guard can inject it in Plan 02-02)
   - Mark module as `@Global()` so SyncFailureIndicator is available for injection across modules

5. Update `apps/api/src/app.module.ts`:
   - Add `HealthModule` import (from `./infrastructure/health/health.module`)
   - Add to the `imports` array alongside existing modules
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && pnpm install --filter=api && npx tsc --noEmit --project apps/api/tsconfig.json` -- should compile without errors.

Verify SyncUserUseCase no longer has findByClerkId, update, or create calls -- only upsert.

Verify health module files exist and are properly wired in app.module.ts.
  </verify>
  <done>
SyncUserUseCase.execute() delegates to userRepository.upsert() atomically. Health endpoint at GET /health returns sync failure rate data. SyncFailureIndicator is exported globally for guard injection. @nestjs/terminus installed.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit --project apps/api/tsconfig.json`
2. ClerkService returns full payload with email (required) + firstName, lastName, imageUrl (optional)
3. SyncUserUseCase uses upsert (not find+update/create)
4. Health module files exist at `apps/api/src/infrastructure/health/`
5. HealthModule imported in AppModule
6. @nestjs/terminus in package.json dependencies
</verification>

<success_criteria>
- ClerkService.verifySessionToken() extracts email, firstName, lastName, imageUrl from JWT
- SyncUserUseCase.execute() is a single upsert call (Phase 1 blocker resolved)
- GET /health endpoint exists and returns sync failure metrics
- SyncFailureIndicator is globally available for injection
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-sync/02-01-SUMMARY.md`
</output>
