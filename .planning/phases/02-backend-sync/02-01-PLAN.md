---
phase: 02-backend-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/infrastructure/auth/clerk.service.ts
  - apps/api/src/core/use-cases/user/sync-user.use-case.ts
  - apps/api/src/infrastructure/health/sync-failure.indicator.ts
  - apps/api/src/infrastructure/health/health.controller.ts
  - apps/api/src/infrastructure/health/health.module.ts
  - apps/api/src/app.module.ts
  - apps/api/package.json
autonomous: true

must_haves:
  truths:
    - "Authenticated requests with valid JWT receive user data including email and profile fields (firstName, lastName, imageUrl)"
    - "Health endpoint at GET /health returns JSON with sync failure rate and status indicators"
    - "User sync via webhook upserts atomically without find+update/create branching"
    - "Health endpoint reports sync failure rate below 5% threshold as healthy"
  artifacts:
    - path: "apps/api/src/infrastructure/auth/clerk.service.ts"
      provides: "Full JWT claim extraction"
      contains: "email.*firstName.*lastName.*imageUrl"
    - path: "apps/api/src/core/use-cases/user/sync-user.use-case.ts"
      provides: "Atomic user sync via upsert (webhook flow only)"
      contains: "this.userRepository.upsert"
    - path: "apps/api/src/infrastructure/health/sync-failure.indicator.ts"
      provides: "Sync failure rate tracking"
      contains: "recordSyncAttempt"
    - path: "apps/api/src/infrastructure/health/health.controller.ts"
      provides: "Health check endpoint"
      contains: "@HealthCheck"
    - path: "apps/api/src/infrastructure/health/health.module.ts"
      provides: "Health module wiring"
      exports: ["SyncFailureIndicator"]
  key_links:
    - from: "apps/api/src/infrastructure/health/health.module.ts"
      to: "apps/api/src/app.module.ts"
      via: "Module import"
      pattern: "HealthModule"
    - from: "apps/api/src/infrastructure/health/health.controller.ts"
      to: "apps/api/src/infrastructure/health/sync-failure.indicator.ts"
      via: "DI constructor injection"
      pattern: "SyncFailureIndicator"
---

<objective>
Build the foundation services for Phase 2 guard-based sync: extend ClerkService to extract all JWT claims, fix SyncUserUseCase to use the upsert method (webhook flow only), and create the health monitoring infrastructure.

Purpose: These three independent components must exist before the guard can be enhanced (Plan 02-02). ClerkService provides JWT claim data, SyncUserUseCase is corrected per Phase 1 verifier blocker (used exclusively by webhook handlers), and HealthModule provides sync failure tracking.

Note on SyncUserUseCase scope: This use case serves the **webhook flow only** (Clerk webhook events that notify of user changes). The guard (Plan 02-02) performs its own compare-first sync logic calling `userRepository.upsert()` directly, because the guard needs compare-before-write optimization that differs from the use case's simple upsert.

Output: Extended ClerkService with full claim extraction, fixed SyncUserUseCase using upsert (webhook-scoped), and working health endpoint with sync failure indicator.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-prerequisites/01-01-SUMMARY.md
@apps/api/src/infrastructure/auth/clerk.service.ts
@apps/api/src/core/use-cases/user/sync-user.use-case.ts
@apps/api/src/core/entities/user.entity.ts
@apps/api/src/core/repositories/user.repository.ts
@apps/api/src/app.module.ts
@apps/api/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ClerkService to extract full JWT claims</name>
  <files>apps/api/src/infrastructure/auth/clerk.service.ts</files>
  <action>
Modify `ClerkService.verifySessionToken()` to extract custom claims from the verified JWT payload.

Current state: The method verifies the token but only returns `{ sub: result.sub }`, discarding all custom claims configured in the Clerk JWT template (email, firstName, lastName, imageUrl).

Changes needed:

1. Add a `Logger` instance to `ClerkService` for warning on token verification failures (use `new Logger(ClerkService.name)` from `@nestjs/common`).

2. Update the `ClerkTokenPayload` interface -- the `email` field should be `string` (not `string | undefined`) since it is a required claim. Keep `firstName`, `lastName`, `imageUrl` as optional (`string | undefined`).

3. In the `verifySessionToken()` method, after `verifyToken()` succeeds, extract the custom claims from the result object. Clerk adds custom JWT template claims directly to the token payload root level. Cast appropriately:
   ```typescript
   return {
     sub: result.sub,
     email: result.email as string,
     firstName: result.firstName as string | undefined,
     lastName: result.lastName as string | undefined,
     imageUrl: result.imageUrl as string | undefined,
   };
   ```

4. Update the `catch` block to use the logger: `this.logger.warn('Token verification failed', error)` instead of silently returning null. Still return `null` after logging.

Do NOT change the `getWebhookSigningSecret()` method. Do NOT add or remove any imports beyond `Logger`. Preserve the existing constructor injection pattern.
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit --project apps/api/tsconfig.json` -- TypeScript compilation should pass with no errors.

Verify the ClerkTokenPayload interface has `email: string` (not optional) and the other three fields as `string | undefined`.
  </verify>
  <done>
ClerkService.verifySessionToken() returns ClerkTokenPayload with sub, email (required), firstName, lastName, imageUrl (optional). Logger warns on verification failures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix SyncUserUseCase to use upsert</name>
  <files>apps/api/src/core/use-cases/user/sync-user.use-case.ts</files>
  <action>
The Phase 1 verifier found that SyncUserUseCase still uses find+update/create instead of the upsert() method added in Phase 1. This use case is scoped to the **webhook flow** (Clerk webhook events). The guard (Plan 02-02) handles its own sync with compare-first logic and calls userRepository directly.

Simplify the execute() method:

1. Remove the `findByClerkId` call, the `if (existingUser)` branch, and the separate `create` path.
2. Replace with a single call to `this.userRepository.upsert(input)` which handles both create and update atomically.
3. Remove the `CreateUserData` and `UpdateUserData` imports (no longer needed). Add `UpsertUserData` import.
4. Keep the `SyncUserInput` interface unchanged -- it aligns with `UpsertUserData`.
5. The method becomes approximately:
   ```typescript
   public async execute(input: SyncUserInput): Promise<User> {
     return this.userRepository.upsert({
       clerkId: input.clerkId,
       email: input.email,
       firstName: input.firstName ?? null,
       lastName: input.lastName ?? null,
       imageUrl: input.imageUrl ?? null,
     });
   }
   ```
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit --project apps/api/tsconfig.json` -- should compile without errors.

Verify SyncUserUseCase no longer has findByClerkId, update, or create calls -- only upsert.
  </verify>
  <done>
SyncUserUseCase.execute() delegates to userRepository.upsert() atomically. Phase 1 blocker resolved. Use case remains scoped to webhook flow.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create health monitoring module with sync failure indicator</name>
  <files>
apps/api/src/infrastructure/health/sync-failure.indicator.ts
apps/api/src/infrastructure/health/health.controller.ts
apps/api/src/infrastructure/health/health.module.ts
apps/api/src/app.module.ts
apps/api/package.json
  </files>
  <action>
Install @nestjs/terminus and create the health monitoring infrastructure.

1. Install `@nestjs/terminus`:
   ```bash
   cd apps/api && pnpm add @nestjs/terminus
   ```

2. Create `apps/api/src/infrastructure/health/sync-failure.indicator.ts`:
   - Injectable class `SyncFailureIndicator`
   - Private fields: `syncFailures = 0`, `syncAttempts = 0`, `failureThreshold = 0.05`
   - Constructor injects `HealthIndicatorService` from `@nestjs/terminus`
   - Public method `recordSyncAttempt(success: boolean): void` -- increments counters, resets (halves both) when syncAttempts reaches 1000
   - Public async method `isHealthy(key: string)` -- uses `this.healthIndicatorService.check(key)` to create indicator, returns `up` or `down` based on failure rate vs threshold. Include syncAttempts, syncFailures, failureRate in the indicator data.
   - When syncAttempts is 0, return `up` with zero values (no data yet = healthy)
   - Use `failureRate.toFixed(3)` for the rate string

3. Create `apps/api/src/infrastructure/health/health.controller.ts`:
   - `@Controller('health')` class `HealthController`
   - Constructor injects `HealthCheckService` from `@nestjs/terminus` and `SyncFailureIndicator`
   - Single `@Get()` method decorated with `@HealthCheck()` that calls `this.health.check([() => this.syncFailure.isHealthy('user-sync')])`
   - This endpoint must NOT require authentication (no `@UseGuards`). It is a public monitoring endpoint.
   - Use explicit `public` access modifier on all methods per NestJS conventions.

4. Create `apps/api/src/infrastructure/health/health.module.ts`:
   - Import `TerminusModule` from `@nestjs/terminus`
   - Declare `HealthController` in controllers
   - Declare `SyncFailureIndicator` in providers
   - Export `SyncFailureIndicator` (so the guard can inject it in Plan 02-02)
   - Mark module as `@Global()` so SyncFailureIndicator is available for injection across modules

5. Update `apps/api/src/app.module.ts`:
   - Add `HealthModule` import (from `./infrastructure/health/health.module`)
   - Add to the `imports` array alongside existing modules
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && pnpm install --filter=api && npx tsc --noEmit --project apps/api/tsconfig.json` -- should compile without errors.

Verify health module files exist and are properly wired in app.module.ts.

Run the API server and verify the health endpoint is accessible:
```bash
cd /Users/luanmartins/source/projects/populatte && npx ts-node -e "
const http = require('http');
// Start server briefly to test health endpoint
" 2>/dev/null || true

# Alternative: use NestJS test utilities or simply start the dev server in background,
# curl GET http://localhost:3000/health, and verify the response contains 'user-sync' key
# with status 'up' and sync metrics (syncAttempts, syncFailures, failureRate).
# Example expected response:
# { "status": "ok", "info": { "user-sync": { "status": "up", "syncAttempts": 0, "syncFailures": 0, "failureRate": "0.000" } } }
```

If the full server start is not feasible during verification, at minimum confirm:
1. TypeScript compiles without errors
2. HealthController has @Get() with @HealthCheck() decorator
3. HealthModule is imported in AppModule
4. @nestjs/terminus is in package.json dependencies
  </verify>
  <done>
Health endpoint at GET /health returns sync failure rate data with user-sync indicator. SyncFailureIndicator is exported globally for guard injection. @nestjs/terminus installed and wired.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit --project apps/api/tsconfig.json`
2. ClerkService returns full payload with email (required) + firstName, lastName, imageUrl (optional)
3. SyncUserUseCase uses upsert (not find+update/create) -- scoped to webhook flow
4. Health module files exist at `apps/api/src/infrastructure/health/`
5. HealthModule imported in AppModule
6. @nestjs/terminus in package.json dependencies
7. GET /health returns valid JSON with user-sync status and sync metrics
</verification>

<success_criteria>
- ClerkService.verifySessionToken() extracts email, firstName, lastName, imageUrl from JWT
- SyncUserUseCase.execute() is a single upsert call (Phase 1 blocker resolved, webhook-scoped)
- GET /health endpoint exists and returns sync failure metrics with user-sync indicator
- SyncFailureIndicator is globally available for injection
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-sync/02-01-SUMMARY.md`
</output>
