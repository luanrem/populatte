---
phase: 02-backend-sync
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts
  - apps/api/src/infrastructure/auth/auth.module.ts
  - apps/api/src/presentation/decorators/current-user.decorator.ts
  - apps/api/src/presentation/controllers/user.controller.ts
autonomous: true

must_haves:
  truths:
    - "ClerkAuthGuard creates user in database if not found during request"
    - "ClerkAuthGuard updates user metadata if JWT claims differ from stored profile"
    - "Request object contains full User entity after guard executes"
    - "CurrentUser decorator returns User entity with correct TypeScript types"
    - "Sync failures return 503 with generic message, not 401"
    - "Controllers use @CurrentUser() user: User without manual database lookup"
  artifacts:
    - path: "apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts"
      provides: "Guard with compare-first sync, error handling, health tracking"
      contains: "syncUser.*userRepository.*upsert"
    - path: "apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts"
      provides: "AuthenticatedRequest with User entity type"
      contains: "user: User"
    - path: "apps/api/src/presentation/decorators/current-user.decorator.ts"
      provides: "Decorator returning full User entity"
      contains: "User"
    - path: "apps/api/src/presentation/controllers/user.controller.ts"
      provides: "Simplified controller using User from decorator"
      contains: "@CurrentUser.*user: User"
  key_links:
    - from: "apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts"
      to: "apps/api/src/core/repositories/user.repository.ts"
      via: "DI constructor injection"
      pattern: "private readonly userRepository: UserRepository"
    - from: "apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts"
      to: "apps/api/src/infrastructure/health/sync-failure.indicator.ts"
      via: "DI constructor injection"
      pattern: "private readonly syncFailureIndicator: SyncFailureIndicator"
    - from: "apps/api/src/presentation/decorators/current-user.decorator.ts"
      to: "apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts"
      via: "AuthenticatedRequest type import"
      pattern: "import.*AuthenticatedRequest"
    - from: "apps/api/src/presentation/controllers/user.controller.ts"
      to: "apps/api/src/presentation/decorators/current-user.decorator.ts"
      via: "CurrentUser parameter decorator"
      pattern: "@CurrentUser.*user: User"
---

<objective>
Enhance ClerkAuthGuard with compare-first sync logic, update the AuthenticatedRequest type to use full User entity, simplify the CurrentUser decorator, and update UserController to use the User entity directly.

Purpose: This is the core integration plan. After this plan, every authenticated request will have a full User entity attached, controllers will never manually fetch users, and sync failures will be tracked via the health indicator (from Plan 02-01).

Output: Working guard-based user sync with compare-first optimization, type-safe User entity on request, simplified controller pattern.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-sync/02-01-SUMMARY.md
@apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts
@apps/api/src/infrastructure/auth/clerk.service.ts
@apps/api/src/infrastructure/auth/auth.module.ts
@apps/api/src/core/entities/user.entity.ts
@apps/api/src/core/repositories/user.repository.ts
@apps/api/src/infrastructure/health/sync-failure.indicator.ts
@apps/api/src/presentation/decorators/current-user.decorator.ts
@apps/api/src/presentation/controllers/user.controller.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance ClerkAuthGuard with compare-first sync and error handling</name>
  <files>
apps/api/src/infrastructure/auth/guards/clerk-auth.guard.ts
apps/api/src/infrastructure/auth/auth.module.ts
  </files>
  <action>
Rewrite ClerkAuthGuard to perform request-time user synchronization with compare-first logic, proper error handling, logging, and health tracking.

**Guard changes (`clerk-auth.guard.ts`):**

1. Update imports: Add `ServiceUnavailableException`, `Logger` from `@nestjs/common`. Add `User` from `../../../core/entities/user.entity`. Add `UserRepository` from `../../../core/repositories/user.repository`. Add `SyncFailureIndicator` from `../../health/sync-failure.indicator`. Add `ClerkTokenPayload` from `../clerk.service` (import the interface).

2. Change the `AuthenticatedRequest` interface: Replace `user: { clerkId: string }` with `user: User` (full User entity from core). This is the Phase 2 core type change.

3. Add a Logger instance: `private readonly logger = new Logger(ClerkAuthGuard.name);`

4. Extend constructor to inject three dependencies:
   ```typescript
   public constructor(
     private readonly clerkService: ClerkService,
     private readonly userRepository: UserRepository,
     private readonly syncFailureIndicator: SyncFailureIndicator,
   ) {}
   ```

5. Rewrite `canActivate()`:
   - Extract token (existing logic, keep extractTokenFromHeader unchanged)
   - Verify token with ClerkService (existing logic)
   - Add claim validation: if `!payload.email`, throw `UnauthorizedException('Missing required claim: email')`. This catches misconfigured JWT templates early.
   - Wrap sync in try/catch:
     - On success: call `this.syncFailureIndicator.recordSyncAttempt(true)`, attach full User to `(request as AuthenticatedRequest).user = user`, return true
     - On error: call `this.syncFailureIndicator.recordSyncAttempt(false)`, log with `this.logger.error('User sync failed during authentication', error)`, throw `new ServiceUnavailableException('Authentication service temporarily unavailable')` (generic message, no leaked internals)

6. Add private `syncUser(payload: ClerkTokenPayload): Promise<User>` method:
   - Fetch stored user: `const storedUser = await this.userRepository.findByClerkId(payload.sub);`
   - Determine if sync needed: `const needsSync = !storedUser || this.hasChanges(storedUser, payload);`
   - If needsSync: log the action (`this.logger.log(\`User ${payload.sub} ${storedUser ? 'updated' : 'created'} via request sync\`)`), then call and return `this.userRepository.upsert(...)` with clerkId, email, firstName ?? null, lastName ?? null, imageUrl ?? null
   - If no sync needed: return `storedUser` directly (skips database write)

7. Add private `hasChanges(user: User, payload: ClerkTokenPayload): boolean` method:
   - Compare profile fields only (per CONTEXT.md: email, firstName, lastName, imageUrl). clerkId is lookup key, not compared.
   - Normalize undefined to null for comparison:
     ```typescript
     return (
       user.email !== payload.email ||
       user.firstName !== (payload.firstName ?? null) ||
       user.lastName !== (payload.lastName ?? null) ||
       user.imageUrl !== (payload.imageUrl ?? null)
     );
     ```
   - This prevents false positives when stored value is null and payload omits field (Pitfall 4 from research).

8. Keep `extractTokenFromHeader()` unchanged.

**Auth module changes (`auth.module.ts`):**

No changes needed. The guard is already provided in AuthModule. Since DrizzleModule (which provides UserRepository) and HealthModule (which provides SyncFailureIndicator) are both @Global(), their exports are available for injection into the guard automatically via NestJS DI. The guard's new constructor dependencies will be resolved by the DI container.

IMPORTANT: Do NOT make UserRepository or SyncFailureIndicator explicit providers in AuthModule. They are already globally available.
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit --project apps/api/tsconfig.json` -- should compile without errors.

Verify the guard has: syncUser method, hasChanges method, UserRepository injection, SyncFailureIndicator injection, ServiceUnavailableException for sync errors, Logger for logging.

Verify AuthenticatedRequest.user is of type `User` (not `{ clerkId: string }`).
  </verify>
  <done>
ClerkAuthGuard performs compare-first sync: extracts JWT claims, fetches stored user, compares profile fields, upserts only on mismatch. Sync failures return 503 with generic message. Health indicator tracks success/failure rate. Full User entity attached to request.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CurrentUser decorator and UserController</name>
  <files>
apps/api/src/presentation/decorators/current-user.decorator.ts
apps/api/src/presentation/controllers/user.controller.ts
  </files>
  <action>
Update the CurrentUser decorator type annotation and simplify UserController to use the full User entity from the guard.

**CurrentUser decorator (`current-user.decorator.ts`):**

1. Add explicit return type annotation `User` to the decorator factory function:
   ```typescript
   import { createParamDecorator, ExecutionContext } from '@nestjs/common';

   import { User } from '../../core/entities/user.entity';
   import { AuthenticatedRequest } from '../../infrastructure/auth/guards/clerk-auth.guard';

   export const CurrentUser = createParamDecorator(
     (data: unknown, ctx: ExecutionContext): User => {
       const request = ctx.switchToHttp().getRequest<AuthenticatedRequest>();
       return request.user;
     },
   );
   ```

2. The decorator now returns `User` instead of the implicit `{ clerkId: string }`. Since the guard (Task 1) now attaches a full `User` to `request.user`, this decorator provides type-safe access to the complete entity.

3. No overloads, no field extraction -- simple whole-user return per CONTEXT.md (Claude's discretion: simplicity wins).

**UserController (`user.controller.ts`):**

1. Simplify the `getMe()` method. The guard now handles user sync and attaches the full User entity. The controller no longer needs to manually fetch the user from the repository.

2. Remove the `UserRepository` constructor injection -- no longer needed in this controller.

3. Remove the `CurrentUserPayload` interface -- no longer needed.

4. Remove the `NotFoundException` import -- no longer needed.

5. The simplified controller:
   ```typescript
   import { Controller, Get, UseGuards } from '@nestjs/common';

   import { User } from '../../core/entities/user.entity';
   import { ClerkAuthGuard } from '../../infrastructure/auth/guards/clerk-auth.guard';
   import { CurrentUser } from '../decorators/current-user.decorator';

   @Controller('users')
   @UseGuards(ClerkAuthGuard)
   export class UserController {
     @Get('me')
     public getMe(@CurrentUser() user: User): User {
       return user;
     }
   }
   ```

6. Note the method is no longer async (no database call needed). The return type is `User` directly (not `Promise<User>`).

IMPORTANT: The controller must still have `@UseGuards(ClerkAuthGuard)` -- the guard does the work, the controller just returns the result. This is the Phase 2 pattern: guard syncs, controller consumes.
  </action>
  <verify>
Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit --project apps/api/tsconfig.json` -- should compile without errors.

Run `cd /Users/luanmartins/source/projects/populatte && npm run lint --filter=api 2>&1 | head -30` -- lint should pass (or show only pre-existing warnings).

Verify UserController no longer imports UserRepository or NotFoundException.
Verify UserController.getMe() is synchronous and returns User directly.
Verify CurrentUser decorator has explicit `: User` return type.
  </verify>
  <done>
CurrentUser decorator returns full User entity with correct TypeScript types. UserController.getMe() returns User directly without database lookup. Controller is simplified: no repository injection, no NotFoundException, no async. Phase 2 pattern established: guard syncs, controller consumes.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit --project apps/api/tsconfig.json`
2. ESLint passes: `npm run lint --filter=api`
3. AuthenticatedRequest.user is type `User` (not `{ clerkId: string }`)
4. ClerkAuthGuard.canActivate() calls syncUser() which uses compare-first logic
5. ClerkAuthGuard throws ServiceUnavailableException (503) on sync failure, not UnauthorizedException (401)
6. CurrentUser decorator returns `User` entity
7. UserController.getMe() has no database call -- returns User from decorator
8. SyncFailureIndicator.recordSyncAttempt() called on both success and failure paths
</verification>

<success_criteria>
- ClerkAuthGuard creates user in database if not found during request (AUTH-01)
- ClerkAuthGuard updates user metadata if changed since last sync (AUTH-01)
- Request object contains full User entity, not just clerkId (AUTH-02)
- CurrentUser decorator returns User entity with correct TypeScript types (AUTH-05)
- Sync failures return 503 with generic message (no leaked internals)
- UserController.getMe() returns User without manual database lookup
- TypeScript compiles and lint passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-sync/02-02-SUMMARY.md`
</output>
