---
phase: 02-transaction-excel-parsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/package.json
  - apps/api/pnpm-lock.yaml
  - apps/api/src/infrastructure/transaction/transaction.module.ts
  - apps/api/src/infrastructure/excel/types/parsed-row.ts
  - apps/api/src/infrastructure/excel/types/cell-type-map.ts
  - apps/api/src/infrastructure/excel/types/index.ts
  - apps/api/src/infrastructure/excel/helpers/cell-access.helper.ts
  - apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts
  - apps/api/src/infrastructure/excel/excel.constants.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "@nestjs-cls/transactional is installed and ClsModule.forRoot is configured with the Drizzle adapter in TransactionModule"
    - "SheetJS 0.20.3 is installed from CDN (not npm registry) and pnpm install succeeds"
    - "ParsedRow interface defines rowIndex, sheetName, sourceFileName, and data fields"
    - "CellTypeMap type alias exists for Record<string, CellType>"
    - "CellAccessHelper provides type-safe cell value extraction compatible with noUncheckedIndexedAccess"
    - "ExcelParsingStrategy interface defines parse() and validateFileCount() contracts"
  artifacts:
    - path: "apps/api/src/infrastructure/transaction/transaction.module.ts"
      provides: "CLS + @Transactional() infrastructure with Drizzle adapter"
      contains: "ClsPluginTransactional"
    - path: "apps/api/src/infrastructure/excel/types/parsed-row.ts"
      provides: "ParsedRow interface consumed by strategies and ingestion service"
      contains: "interface ParsedRow"
    - path: "apps/api/src/infrastructure/excel/types/cell-type-map.ts"
      provides: "CellType enum and CellTypeMap type alias"
      contains: "CellType"
    - path: "apps/api/src/infrastructure/excel/helpers/cell-access.helper.ts"
      provides: "Type-safe SheetJS cell access for strict TypeScript mode"
      contains: "CellAccessHelper"
    - path: "apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts"
      provides: "Strategy interface for Excel parsing"
      contains: "ExcelParsingStrategy"
    - path: "apps/api/src/infrastructure/excel/excel.constants.ts"
      provides: "Symbol-based DI tokens for strategies"
      contains: "LIST_MODE_STRATEGY"
  key_links:
    - from: "apps/api/src/infrastructure/transaction/transaction.module.ts"
      to: "apps/api/src/infrastructure/database/drizzle/drizzle.service.ts"
      via: "DrizzleService injection for Drizzle adapter token"
      pattern: "DrizzleService"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/infrastructure/transaction/transaction.module.ts"
      via: "Module import"
      pattern: "TransactionModule"
---

<objective>
Install @nestjs-cls/transactional with Drizzle adapter and SheetJS 0.20.3 from CDN, then create the shared Excel parsing infrastructure: ParsedRow/CellTypeMap types, CellAccessHelper for strict TypeScript, ExcelParsingStrategy interface, and Symbol-based DI constants.

Purpose: Establishes the two pillars that Phase 2 strategies and Phase 3 use cases depend on -- atomic transaction support and the Excel parsing type system. Without these, strategies cannot be implemented and transactions cannot be decorated.

Output: TransactionModule registered in AppModule, SheetJS available as dependency, all shared Excel types/helpers/interfaces ready for strategy implementations in Plan 02.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-transaction-excel-parsing/02-RESEARCH.md
@.planning/phases/02-transaction-excel-parsing/02-CONTEXT.md
@.planning/phases/01-domain-foundation/01-01-SUMMARY.md
@.planning/phases/01-domain-foundation/01-02-SUMMARY.md
@apps/api/src/infrastructure/database/drizzle/drizzle.service.ts
@apps/api/src/infrastructure/database/drizzle/drizzle.module.ts
@apps/api/src/infrastructure/database/drizzle/drizzle.types.ts
@apps/api/src/app.module.ts
@apps/api/src/core/entities/batch.entity.ts
@apps/api/src/core/entities/row.entity.ts
@apps/api/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create TransactionModule</name>
  <files>
    apps/api/package.json
    apps/api/src/infrastructure/transaction/transaction.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**Step 1: Install packages.** From `apps/api/`, run:
```bash
pnpm add nestjs-cls @nestjs-cls/transactional @nestjs-cls/transactional-adapter-drizzle-orm
pnpm add https://cdn.sheetjs.com/xlsx-0.20.3/xlsx-0.20.3.tgz
```

**Step 2: Verify lockfile.** Run `pnpm install --frozen-lockfile` to confirm the lockfile is consistent. If it fails, run `pnpm install` again and commit the updated lockfile. This validates Pitfall 2 (pnpm lockfile stability with CDN packages).

**Step 3: Create `apps/api/src/infrastructure/transaction/transaction.module.ts`.**

This module configures CLS-based transaction infrastructure with the Drizzle adapter:

```typescript
import { Module } from '@nestjs/common';
import { ClsModule } from 'nestjs-cls';
import { ClsPluginTransactional } from '@nestjs-cls/transactional';
import { TransactionalAdapterDrizzleOrm } from '@nestjs-cls/transactional-adapter-drizzle-orm';
import { DrizzleService } from '../database/drizzle/drizzle.service';
```

Key configuration details:
- `ClsModule.forRoot({ global: true, middleware: { mount: true } })` -- makes CLS context available in all modules
- The `ClsPluginTransactional` plugin needs the Drizzle instance. Since the existing codebase uses `DrizzleService` (class-based provider, NOT a Symbol token), you must use `DrizzleService` as the `drizzleInstanceToken` and configure the adapter to extract the client from it.

**CRITICAL -- Drizzle token resolution:** The existing `DrizzleService` is registered as a class provider (not a Symbol). The adapter needs access to the raw Drizzle client. There are two approaches:

**Approach A (Preferred):** Use a factory provider to register the raw client under a Symbol token alongside the existing DrizzleService:
- Create a `DRIZZLE_CLIENT` constant (Symbol) in `transaction.module.ts` or a constants file
- In TransactionModule, import DrizzleModule and add a factory provider: `{ provide: DRIZZLE_CLIENT, useFactory: (drizzle: DrizzleService) => drizzle.getClient(), inject: [DrizzleService] }`
- Set `drizzleInstanceToken: DRIZZLE_CLIENT` in the adapter

**Approach B (Simpler alternative):** If the adapter supports class-based tokens, try using `DrizzleService` directly as the token and configure `connectionToken` properly. Read the adapter source or test empirically.

Go with whichever approach compiles and the adapter accepts. The goal is: `@Transactional()` decorator on a use case method must be able to start a database transaction.

**Step 4: Register TransactionModule in AppModule.** Add `TransactionModule` to the `imports` array in `apps/api/src/app.module.ts`. It should be imported AFTER `DrizzleModule` since it depends on DrizzleService being available.

**What to avoid:**
- Do NOT use `ClsModule.forRoot()` inside DrizzleModule -- keep transaction concerns separate in their own module
- Do NOT modify DrizzleService or DrizzleModule -- the existing provider pattern must remain intact
- Do NOT use string tokens for the Drizzle instance -- use Symbol or the class reference to prevent silent resolution failures (Pitfall 8 from research)
  </action>
  <verify>
1. `cd apps/api && pnpm install --frozen-lockfile` succeeds
2. `cd apps/api && npx tsc --noEmit` compiles without errors
3. `package.json` contains `nestjs-cls`, `@nestjs-cls/transactional`, `@nestjs-cls/transactional-adapter-drizzle-orm`, and `xlsx` (from CDN URL)
4. `grep -r "ClsPluginTransactional" apps/api/src/` returns the transaction module file
5. `grep -r "TransactionModule" apps/api/src/app.module.ts` confirms module registration
  </verify>
  <done>
TransactionModule exists with ClsModule.forRoot + ClsPluginTransactional + Drizzle adapter configured. SheetJS 0.20.3 installed from CDN. AppModule imports TransactionModule. TypeScript compiles cleanly. pnpm --frozen-lockfile succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared Excel parsing types, helpers, strategy interface, and DI constants</name>
  <files>
    apps/api/src/infrastructure/excel/types/parsed-row.ts
    apps/api/src/infrastructure/excel/types/cell-type-map.ts
    apps/api/src/infrastructure/excel/types/index.ts
    apps/api/src/infrastructure/excel/helpers/cell-access.helper.ts
    apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts
    apps/api/src/infrastructure/excel/excel.constants.ts
  </files>
  <action>
**Create the shared Excel parsing type system used by both strategies (Plan 02).**

**File 1: `types/parsed-row.ts`** -- The ParsedRow interface. This is what strategies return:
```typescript
export interface ParsedRow {
  rowIndex: number;           // Original spreadsheet row number (1-indexed)
  sheetName: string;          // Which sheet this row came from
  sourceFileName: string;     // Original file name for traceability
  data: Record<string, unknown>;  // JSONB payload -- header keys (ListMode) or cell-address keys (ProfileMode)
}
```
Also export `ParseResult` interface that strategies return:
```typescript
export interface ParseResult {
  rows: ParsedRow[];
  typeMap: Record<string, CellType>;  // Column/cell type map stored on batch entity
}
```

**File 2: `types/cell-type-map.ts`** -- CellType enum and CellTypeMap type:
- `CellType` enum with 6 values: `String = 'string'`, `Number = 'number'`, `Boolean = 'boolean'`, `Date = 'date'`, `Error = 'error'`, `Empty = 'empty'`
- `CellTypeMap` type alias: `Record<string, CellType>`
- These align with the 6 SheetJS cell types documented in CONTEXT.md

**File 3: `types/index.ts`** -- Barrel export for all types.

**File 4: `helpers/cell-access.helper.ts`** -- Type-safe SheetJS cell access helper. This is critical for TypeScript strict mode (Pitfall 13 from research):
- Import `* as XLSX from 'xlsx'`
- Static method `getCellValue(sheet: XLSX.WorkSheet, address: string)`: Returns `unknown` (can be string, number, boolean, Date, or null). Access sheet cells using `(sheet as Record<string, XLSX.CellObject | undefined>)[address]` to satisfy `noUncheckedIndexedAccess`. Return `cell.v ?? null` for data cells. Return `null` for undefined/empty cells (type 'z').
- Static method `getCellType(sheet: XLSX.WorkSheet, address: string)`: Returns `CellType`. Maps SheetJS cell.t values: 's' -> String, 'n' -> Number (or Date if `cell.z` indicates date format using `XLSX.SSF` if available), 'b' -> Boolean, 'd' -> Date, 'e' -> Error, 'z'/undefined -> Empty.
- Static method `buildTypeMap(sheet: XLSX.WorkSheet, mode: 'column' | 'cell')`: Returns `CellTypeMap`. Iterates all cells using `XLSX.utils.decode_range(sheet['!ref'] || 'A1')`. In 'column' mode, uses first non-empty cell to determine column type (key = column letter). In 'cell' mode, maps every cell address.
- All methods must handle undefined cells gracefully (strict mode).

**File 5: `strategies/excel-parsing.strategy.ts`** -- The strategy interface:
```typescript
export interface ExcelParsingStrategy {
  parse(files: Array<{ buffer: Buffer; originalName: string }>): ParseResult;
  validateFileCount(count: number): void;
}
```
Note: Files are passed as objects with `buffer` and `originalName` (not just Buffer) because strategies need the source file name for each ParsedRow. This matches the Multer file shape and avoids losing filename traceability.

**File 6: `excel.constants.ts`** -- Symbol-based DI tokens (Pitfall 12):
```typescript
export const LIST_MODE_STRATEGY = Symbol('LIST_MODE_STRATEGY');
export const PROFILE_MODE_STRATEGY = Symbol('PROFILE_MODE_STRATEGY');
```
Two distinct Symbol tokens prevent DI from silently overwriting one strategy with the other.

**What to avoid:**
- Do NOT use string tokens like `'ExcelParsingStrategy'` -- Symbol tokens prevent naming collisions (Pitfall 12)
- Do NOT make CellAccessHelper depend on any NestJS module -- it's a pure utility class
- Do NOT use `import xlsx from 'xlsx'` -- use `import * as XLSX from 'xlsx'` (Pitfall 18: ESM/CJS compatibility)
- Do NOT reference `XLSX.readFile()` anywhere -- only `XLSX.read(buffer)` for server buffers (Pitfall 18)
  </action>
  <verify>
1. `cd apps/api && npx tsc --noEmit` compiles without errors
2. All 6 files exist in the expected paths
3. `grep -r "import \* as XLSX" apps/api/src/infrastructure/excel/` confirms correct SheetJS import pattern
4. `grep -r "noUncheckedIndexedAccess" apps/api/tsconfig.json` confirms strict mode is active (our helper must work under it)
  </verify>
  <done>
ParsedRow/ParseResult interfaces exist with rowIndex, sheetName, sourceFileName, data fields. CellType enum has all 6 SheetJS types. CellAccessHelper provides getCellValue, getCellType, buildTypeMap with strict TypeScript safety. ExcelParsingStrategy interface defines parse() and validateFileCount() contracts. LIST_MODE_STRATEGY and PROFILE_MODE_STRATEGY Symbol tokens exist. All files compile under strict mode.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/api && pnpm install --frozen-lockfile` -- lockfile is consistent with CDN SheetJS
2. `cd apps/api && npx tsc --noEmit` -- all new files compile under strict TypeScript
3. `cd apps/api && pnpm run build` -- NestJS build succeeds with TransactionModule registered
4. Verify `xlsx` in package.json references CDN URL (not npm registry): `grep "cdn.sheetjs.com" apps/api/package.json`
5. Verify TransactionModule is imported in AppModule: `grep "TransactionModule" apps/api/src/app.module.ts`
</verification>

<success_criteria>
- TransactionModule configured with CLS + Drizzle adapter, imported in AppModule
- SheetJS 0.20.3 installed from CDN, pnpm --frozen-lockfile passes
- ParsedRow, ParseResult, CellType, CellTypeMap types exported
- CellAccessHelper works under noUncheckedIndexedAccess
- ExcelParsingStrategy interface ready for ListMode/ProfileMode implementations
- Symbol-based DI tokens for both strategies
- Full TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-transaction-excel-parsing/02-01-SUMMARY.md`
</output>
