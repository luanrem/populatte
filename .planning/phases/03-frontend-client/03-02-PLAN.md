---
phase: 03-frontend-client
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/web/lib/api/schemas/user.schema.ts
  - apps/web/lib/api/schemas/index.ts
  - apps/web/lib/api/endpoints/users.ts
  - apps/web/lib/api/endpoints/index.ts
  - apps/web/lib/query/client.ts
  - apps/web/lib/query/provider.tsx
  - apps/web/lib/query/hooks/use-me.ts
  - apps/web/lib/query/hooks/index.ts
  - apps/web/components/error/error-toast.tsx
  - apps/web/components/error/global-loading.tsx
  - apps/web/app/layout.tsx
  - apps/web/app/error.tsx
  - apps/web/app/not-found.tsx
  - apps/web/app/unauthorized/page.tsx
autonomous: true

must_haves:
  truths:
    - "getMe() endpoint function validates API response with Zod schema and throws on mismatch"
    - "useMe() hook returns typed user data via TanStack Query with proper queryKey"
    - "TanStack Query provider wraps the app with correct defaults (no 4xx retry, exponential backoff for 5xx)"
    - "Toast notifications appear for global errors (network, auth, sync failures)"
    - "Custom 404 page shows navigation back to dashboard"
    - "Custom 403/unauthorized page shows navigation back to dashboard"
    - "Global loading indicator shows during active TanStack Query fetches"
  artifacts:
    - path: "apps/web/lib/api/schemas/user.schema.ts"
      provides: "Zod schema for User API response validation"
      contains: "userResponseSchema"
    - path: "apps/web/lib/api/endpoints/users.ts"
      provides: "getMe() function with Zod-validated response"
      exports: ["getMe"]
    - path: "apps/web/lib/query/provider.tsx"
      provides: "QueryProvider component with stable QueryClient"
      exports: ["QueryProvider"]
    - path: "apps/web/lib/query/hooks/use-me.ts"
      provides: "useMe() hook wrapping getMe() with TanStack Query"
      exports: ["useMe"]
    - path: "apps/web/app/error.tsx"
      provides: "Global error boundary with reset functionality"
    - path: "apps/web/app/not-found.tsx"
      provides: "Custom 404 page with link to dashboard"
    - path: "apps/web/app/unauthorized/page.tsx"
      provides: "Custom 403 page with link to dashboard"
  key_links:
    - from: "apps/web/lib/api/endpoints/users.ts"
      to: "apps/web/lib/api/schemas/user.schema.ts"
      via: "Zod parse for response validation"
      pattern: "userResponseSchema\\.safeParse"
    - from: "apps/web/lib/query/hooks/use-me.ts"
      to: "apps/web/lib/api/endpoints/users.ts"
      via: "queryFn calling getMe()"
      pattern: "getMe"
    - from: "apps/web/app/layout.tsx"
      to: "apps/web/lib/query/provider.tsx"
      via: "QueryProvider wrapping children"
      pattern: "QueryProvider"
    - from: "apps/web/app/layout.tsx"
      to: "apps/web/components/ui/sonner.tsx"
      via: "Toaster component rendered in layout"
      pattern: "Toaster"
---

<objective>
Add Zod response validation, TanStack Query data layer, error UX (toasts, error pages, loading indicator), and wire everything into the app layout.

Purpose: Completes the type-safe API client by adding runtime response validation, React data hooks, and user-facing error handling. After this plan, the frontend has a production-ready data fetching layer.
Output: Zod-validated endpoint functions, TanStack Query hooks, error boundaries, toast notifications, loading indicators, and updated root layout.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-client/03-CONTEXT.md
@.planning/phases/03-frontend-client/03-RESEARCH.md
@.planning/phases/03-frontend-client/03-01-SUMMARY.md
@apps/web/lib/api/types.ts
@apps/web/lib/api/client.ts
@apps/web/lib/api/client.server.ts
@apps/web/lib/api/error-handler.ts
@apps/web/app/layout.tsx
@apps/web/components/ui/sonner.tsx
@apps/api/src/core/entities/user.entity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas, endpoint functions, and TanStack Query hooks</name>
  <files>
    apps/web/lib/api/schemas/user.schema.ts
    apps/web/lib/api/schemas/index.ts
    apps/web/lib/api/endpoints/users.ts
    apps/web/lib/api/endpoints/index.ts
    apps/web/lib/query/client.ts
    apps/web/lib/query/provider.tsx
    apps/web/lib/query/hooks/use-me.ts
    apps/web/lib/query/hooks/index.ts
  </files>
  <action>
    **Step 1 - Create Zod schema for User response** at `apps/web/lib/api/schemas/user.schema.ts`:

    Reference the User entity from `apps/api/src/core/entities/user.entity.ts` for field names. The schema validates JSON responses (dates come as strings over HTTP).

    ```typescript
    import { z } from 'zod'

    export const userResponseSchema = z.object({
      id: z.string(),
      clerkId: z.string(),
      email: z.string().email(),
      firstName: z.string().nullable(),
      lastName: z.string().nullable(),
      imageUrl: z.string().nullable(),
      lastSyncedAt: z.string().nullable(),  // ISO string or null
      deletedAt: z.string().nullable(),
      source: z.string(),
      createdAt: z.string(),  // ISO string
      updatedAt: z.string(),  // ISO string
    })

    export type UserResponse = z.infer<typeof userResponseSchema>
    ```

    Create barrel file at `apps/web/lib/api/schemas/index.ts` re-exporting everything.

    **Step 2 - Create endpoint function** at `apps/web/lib/api/endpoints/users.ts`:

    ```
    'use client'
    ```

    This file exports `getMe` as a function that takes a `fetchFn` parameter (the client's fetch method). This makes it usable with both `useApiClient()` hook and `createApiClient()` factory.

    ```typescript
    export function createUserEndpoints(fetchFn: (endpoint: string, options?: RequestInit) => Promise<Response>) {
      return {
        async getMe(): Promise<UserResponse> {
          const response = await fetchFn('/users/me')
          const data: unknown = await response.json()

          const result = userResponseSchema.safeParse(data)

          if (!result.success) {
            console.error('[API] User response validation failed:', result.error.issues)
            throw new Error('Invalid user data received from server')
          }

          return result.data
        }
      }
    }
    ```

    Also export a standalone `getMe` that uses the hook-based client for convenience:

    This is tricky because `getMe` needs to be a plain async function for use as TanStack Query's `queryFn`, but the client comes from a hook. Solution: The hook `useMe()` will construct the fetch function internally and pass it. Export the `createUserEndpoints` factory and let hooks compose it.

    Create barrel file at `apps/web/lib/api/endpoints/index.ts` re-exporting.

    **Step 3 - Create QueryClient factory** at `apps/web/lib/query/client.ts`:

    Create `createQueryClient()` function returning a new `QueryClient` with defaults:
    - `queries.staleTime`: 60 * 1000 (1 minute)
    - `queries.retry`: Custom function that:
      - Returns false for 4xx errors (check error.message for "HTTP 4" or check `error instanceof ApiError && error.status >= 400 && error.status < 500`)
      - Returns `failureCount < 3` for everything else (5xx, network errors)
    - `queries.retryDelay`: `(attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 8000)` (exponential backoff: 1s, 2s, 4s)

    Import `ApiError` from the types file to check error instance.

    **Step 4 - Create QueryProvider** at `apps/web/lib/query/provider.tsx`:

    ```
    'use client'
    ```

    Use `useState` to create stable QueryClient instance (prevents re-creation on re-render):
    ```typescript
    const [queryClient] = useState(() => createQueryClient())
    ```

    Wrap children with `QueryClientProvider` and include `ReactQueryDevtools` (initialIsOpen: false).

    Accept `{ children: React.ReactNode }` props.

    **Step 5 - Create useMe hook** at `apps/web/lib/query/hooks/use-me.ts`:

    ```
    'use client'
    ```

    Import `useQuery` from `@tanstack/react-query`.
    Import `useApiClient` from the client module.
    Import `createUserEndpoints` from endpoints.
    Import `UserResponse` type from schemas.

    ```typescript
    export function useMe() {
      const client = useApiClient()
      const endpoints = createUserEndpoints(client.fetch)

      return useQuery<UserResponse>({
        queryKey: ['me'],
        queryFn: () => endpoints.getMe(),
        staleTime: 5 * 60 * 1000, // 5 minutes - user data changes rarely
      })
    }
    ```

    Create barrel file at `apps/web/lib/query/hooks/index.ts`.
  </action>
  <verify>
    - File exists: `apps/web/lib/api/schemas/user.schema.ts` with `userResponseSchema` export
    - File exists: `apps/web/lib/api/endpoints/users.ts` with `createUserEndpoints` export
    - File exists: `apps/web/lib/query/client.ts` with `createQueryClient` export
    - File exists: `apps/web/lib/query/provider.tsx` with `QueryProvider` export
    - File exists: `apps/web/lib/query/hooks/use-me.ts` with `useMe` export
    - All barrel files exist (schemas/index.ts, endpoints/index.ts, hooks/index.ts)
    - `cd apps/web && npx tsc --noEmit` passes
  </verify>
  <done>
    Zod schema validates User API responses at runtime. Endpoint function uses safeParse and throws on mismatch. TanStack Query provider wraps app with smart retry defaults (no 4xx retry, exponential backoff for 5xx). useMe() hook provides typed user data with 5-minute stale time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error UX components, error pages, and wire into layout</name>
  <files>
    apps/web/components/error/error-toast.tsx
    apps/web/components/error/global-loading.tsx
    apps/web/app/error.tsx
    apps/web/app/not-found.tsx
    apps/web/app/unauthorized/page.tsx
    apps/web/app/layout.tsx
  </files>
  <action>
    **Step 1 - Create error toast hook** at `apps/web/components/error/error-toast.tsx`:

    ```
    'use client'
    ```

    Create `useApiErrorToast(error: Error | null, message: string)` hook:
    - Uses `useEffect` to watch `error`
    - When error is truthy, calls `toast.error(message, { description: getErrorMessage(error) })`
    - Import `toast` from `sonner`
    - Import `getErrorMessage` from `@/lib/api/error-handler`

    This hook is meant to be used in components alongside TanStack Query:
    ```typescript
    const { data, error } = useMe()
    useApiErrorToast(error, 'Could not load your profile')
    ```

    **Step 2 - Create global loading indicator** at `apps/web/components/error/global-loading.tsx`:

    ```
    'use client'
    ```

    Create `GlobalLoadingIndicator` component:
    - Uses `useIsFetching()` from `@tanstack/react-query`
    - When `isFetching > 0`, renders a thin progress bar at top of viewport:
      ```html
      <div className="fixed top-0 left-0 right-0 h-0.5 z-50 bg-primary/20">
        <div className="h-full bg-primary animate-pulse w-full" />
      </div>
      ```
    - When `isFetching === 0`, renders `null`

    **Step 3 - Create global error boundary** at `apps/web/app/error.tsx`:

    ```
    'use client'
    ```

    Default export component receiving `{ error, reset }` props (Next.js error boundary convention):
    - Display a centered error message: "Something went wrong"
    - Show the error.message in muted text (for development visibility)
    - Include a "Try again" button (shadcn `Button`) that calls `reset()`
    - Include a "Go to Dashboard" link (Next.js `Link` to `/dashboard`)
    - Use shadcn `Button` component for both actions
    - Style: flex column, centered, min-h-screen

    **Step 4 - Create custom 404 page** at `apps/web/app/not-found.tsx`:

    Default export component:
    - Display: "404 - Page Not Found"
    - Subtitle: "The page you're looking for doesn't exist."
    - shadcn `Button` as link to `/dashboard`: "Go to Dashboard"
    - Style: flex column, centered, min-h-screen

    **Step 5 - Create unauthorized page** at `apps/web/app/unauthorized/page.tsx`:

    Default export component:
    - Display: "403 - Access Denied"
    - Subtitle: "You don't have permission to access this page."
    - shadcn `Button` as link to `/dashboard`: "Go to Dashboard"
    - Style: flex column, centered, min-h-screen
    - This is a regular page (not an error boundary) since 403 is a navigation result, not a render error

    **Step 6 - Update root layout** at `apps/web/app/layout.tsx`:

    Add the following to the existing layout (preserve ALL existing code - ClerkProvider, ThemeProvider, SidebarProvider, fonts, metadata):

    1. Import `QueryProvider` from `@/lib/query/provider`
    2. Import `Toaster` from `@/components/ui/sonner`
    3. Import `GlobalLoadingIndicator` from `@/components/error/global-loading`

    4. Wrap the ThemeProvider's children with `<QueryProvider>`:
       - QueryProvider goes INSIDE ThemeProvider (needs theme context) but OUTSIDE SignedIn/SignedOut
       - This ensures TanStack Query is available everywhere, even on sign-in pages

    5. Add `<Toaster />` component as a sibling to QueryProvider's children (inside body, after the main content)
       - Position: use Sonner's default (bottom-right)
       - The `richColors` prop should be set to `true` for better error/success styling

    6. Add `<GlobalLoadingIndicator />` inside QueryProvider, before other children

    The resulting layout structure should be:
    ```
    ClerkProvider
      html
        body
          ThemeProvider
            QueryProvider
              GlobalLoadingIndicator
              SignedIn > SidebarProvider > AppSidebar + children
              SignedOut > children
              Toaster (richColors)
            /QueryProvider
          /ThemeProvider
        /body
      /html
    /ClerkProvider
    ```
  </action>
  <verify>
    - File exists: `apps/web/components/error/error-toast.tsx` with `useApiErrorToast` export
    - File exists: `apps/web/components/error/global-loading.tsx` with `GlobalLoadingIndicator` export
    - File exists: `apps/web/app/error.tsx` with `'use client'` directive
    - File exists: `apps/web/app/not-found.tsx` with link to `/dashboard`
    - File exists: `apps/web/app/unauthorized/page.tsx` with link to `/dashboard`
    - `apps/web/app/layout.tsx` imports QueryProvider, Toaster, and GlobalLoadingIndicator
    - `apps/web/app/layout.tsx` has QueryProvider wrapping content
    - `apps/web/app/layout.tsx` has Toaster component
    - `cd apps/web && npx tsc --noEmit` passes
    - Grep confirms no `any` types in any new files
  </verify>
  <done>
    Error toast hook available for component-level error display. Global loading indicator shows during active fetches. Error boundary catches render errors with retry. Custom 404 and 403 pages provide navigation back to dashboard. Root layout wires QueryProvider, Toaster, and GlobalLoadingIndicator into the component tree.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes with zero errors
2. All Zod schemas exist and export typed inference: `UserResponse`
3. `getMe()` endpoint uses `safeParse` and throws on schema mismatch
4. `useMe()` hook returns `UseQueryResult<UserResponse>`
5. QueryProvider uses `useState` for stable QueryClient (no re-creation)
6. Layout includes: QueryProvider, Toaster (richColors), GlobalLoadingIndicator
7. Error pages exist: error.tsx, not-found.tsx, unauthorized/page.tsx
8. No `any` types used in any new files
9. All `'use client'` directives present where React hooks are used
</verification>

<success_criteria>
- API responses validated with Zod schemas at runtime (throw on mismatch)
- TanStack Query provides typed data hooks with smart retry (no 4xx retry, backoff for 5xx)
- Toast notifications available for error display via `useApiErrorToast` hook
- Error boundaries catch render errors with reset capability
- 404 and 403 pages provide clear navigation back to dashboard
- Global loading indicator visible during active network requests
- Root layout properly wires all providers and global components
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-client/03-02-SUMMARY.md`
</output>
