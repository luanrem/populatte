---
phase: 05-createbatch-use-case
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/repositories/project.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts
  - apps/api/src/core/entities/batch.entity.ts
  - apps/api/src/infrastructure/database/drizzle/schema/ingestion-batches.schema.ts
  - apps/api/src/infrastructure/database/drizzle/mappers/batch.mapper.ts
  - apps/api/src/core/use-cases/batch/create-batch.use-case.ts
  - apps/api/src/core/use-cases/batch/index.ts
  - apps/api/src/core/use-cases/index.ts
  - apps/api/src/infrastructure/excel/ingestion.module.ts
autonomous: true

must_haves:
  truths:
    - "CreateBatchUseCase validates project exists, is not soft-deleted, and belongs to requesting user before starting ingestion"
    - "Separate error responses: 404 for missing project, 404 with 'archived' message for soft-deleted project, 403 for ownership mismatch"
    - "Unauthorized access attempts are logged at WARN level with userId and projectId"
    - "@Transactional() wraps the full execute() method so batch insert + all row inserts share the same transaction and roll back together on any error"
    - "Use case delegates to IngestionService for parsing and persistence, containing no parsing or persistence logic itself"
  artifacts:
    - path: "apps/api/src/core/repositories/project.repository.ts"
      provides: "findByIdOnly(id: string) abstract method for ownership validation"
      contains: "findByIdOnly"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts"
      provides: "findByIdOnly implementation querying by id only (no userId filter, no soft-delete filter)"
      contains: "findByIdOnly"
    - path: "apps/api/src/core/entities/batch.entity.ts"
      provides: "BatchStatus enum aligned to PROCESSING/COMPLETED/FAILED"
      contains: "Processing"
    - path: "apps/api/src/infrastructure/database/drizzle/schema/ingestion-batches.schema.ts"
      provides: "batchStatusEnum aligned to PROCESSING/COMPLETED/FAILED"
      contains: "PROCESSING"
    - path: "apps/api/src/core/use-cases/batch/create-batch.use-case.ts"
      provides: "CreateBatchUseCase with @Transactional, ownership validation, IngestionService delegation"
      exports: ["CreateBatchUseCase", "CreateBatchInput", "CreateBatchResult"]
    - path: "apps/api/src/infrastructure/excel/ingestion.module.ts"
      provides: "CreateBatchUseCase registered as provider and exported"
      contains: "CreateBatchUseCase"
  key_links:
    - from: "apps/api/src/core/use-cases/batch/create-batch.use-case.ts"
      to: "apps/api/src/core/repositories/project.repository.ts"
      via: "findByIdOnly for ownership validation"
      pattern: "projectRepository\\.findByIdOnly"
    - from: "apps/api/src/core/use-cases/batch/create-batch.use-case.ts"
      to: "apps/api/src/infrastructure/excel/ingestion.service.ts"
      via: "IngestionService.ingest() call inside @Transactional boundary"
      pattern: "ingestionService\\.ingest"
    - from: "apps/api/src/core/use-cases/batch/create-batch.use-case.ts"
      to: "@nestjs-cls/transactional"
      via: "@Transactional() decorator on execute() method"
      pattern: "@Transactional\\(\\)"
    - from: "apps/api/src/infrastructure/excel/ingestion.module.ts"
      to: "apps/api/src/core/use-cases/batch/create-batch.use-case.ts"
      via: "NestJS provider registration and export"
      pattern: "CreateBatchUseCase"
---

<objective>
Create the CreateBatchUseCase that validates project ownership with separate 404/403 errors, orchestrates ingestion via IngestionService within a @Transactional() boundary, and guarantees atomic commit/rollback of batch + rows.

Purpose: This use case is the bridge between the HTTP layer (Phase 7) and the ingestion engine (Phases 3-4). It enforces business rules (ownership, soft-delete detection) and transaction atomicity that the service layer intentionally does not handle.

Output: Working CreateBatchUseCase with ownership validation, transactional orchestration, security audit logging, and NestJS module wiring.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-createbatch-use-case/05-CONTEXT.md
@.planning/phases/05-createbatch-use-case/05-RESEARCH.md

Key source files to reference:
@apps/api/src/core/use-cases/project/create-project.use-case.ts (use case pattern)
@apps/api/src/core/use-cases/project/get-project.use-case.ts (NotFoundException pattern)
@apps/api/src/core/repositories/project.repository.ts (abstract class to extend)
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts (implementation to extend)
@apps/api/src/core/entities/batch.entity.ts (BatchStatus enum to align, CreateBatchData interface)
@apps/api/src/infrastructure/database/drizzle/schema/ingestion-batches.schema.ts (batchStatusEnum to align)
@apps/api/src/infrastructure/database/drizzle/mappers/batch.mapper.ts (BatchMapper to update)
@apps/api/src/infrastructure/excel/ingestion.service.ts (IngestionService to call)
@apps/api/src/infrastructure/excel/ingestion.module.ts (module to register use case in)
@apps/api/src/core/use-cases/index.ts (barrel export to extend)
@apps/api/src/core/entities/project.entity.ts (Project entity with deletedAt field)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Repository findByIdOnly method and BatchStatus enum alignment</name>
  <files>
    apps/api/src/core/repositories/project.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts
    apps/api/src/core/entities/batch.entity.ts
    apps/api/src/infrastructure/database/drizzle/schema/ingestion-batches.schema.ts
    apps/api/src/infrastructure/database/drizzle/mappers/batch.mapper.ts
  </files>
  <action>
    **Part A: Add findByIdOnly to ProjectRepository**

    1. In `apps/api/src/core/repositories/project.repository.ts`, add a new abstract method:
       ```typescript
       public abstract findByIdOnly(id: string): Promise<Project | null>;
       ```
       This method queries by `id` only -- no `userId` filter and no `isNull(deletedAt)` filter. This is needed so the use case can distinguish between "project not found" (404), "project is archived/soft-deleted" (404 with specific message), and "user doesn't own project" (403).

    2. In `apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts`, implement `findByIdOnly`:
       ```typescript
       public async findByIdOnly(id: string): Promise<Project | null> {
         const result = await this.drizzle
           .getClient()
           .select()
           .from(projects)
           .where(eq(projects.id, id))
           .limit(1);

         const row = result[0];
         return row ? ProjectMapper.toDomain(row) : null;
       }
       ```
       Note: Do NOT add `isNull(projects.deletedAt)` -- the use case needs to see the `deletedAt` field to give a specific error message for archived projects. Import `eq` from `drizzle-orm` (already imported in the file).

    **Part B: Align BatchStatus enum to PROCESSING/COMPLETED/FAILED**

    The CONTEXT.md decision specifies three batch lifecycle states: PROCESSING, COMPLETED, FAILED. Currently:
    - Entity enum: `PendingReview = 'PENDING_REVIEW'` / `Completed = 'COMPLETED'` / `Failed = 'FAILED'`
    - Schema pgEnum: `['PENDING_REVIEW', 'COMPLETED', 'FAILED']`
    - Default: `'PENDING_REVIEW'`

    Update to match context decision:

    3. In `apps/api/src/core/entities/batch.entity.ts`, change `BatchStatus` enum:
       ```typescript
       export enum BatchStatus {
         Processing = 'PROCESSING',
         Completed = 'COMPLETED',
         Failed = 'FAILED',
       }
       ```
       Change ONLY the `PendingReview` member to `Processing` with value `'PROCESSING'`. Keep `Completed` and `Failed` unchanged.

    4. In `apps/api/src/infrastructure/database/drizzle/schema/ingestion-batches.schema.ts`, update `batchStatusEnum`:
       ```typescript
       export const batchStatusEnum = pgEnum('batch_status', [
         'PROCESSING',
         'COMPLETED',
         'FAILED',
       ]);
       ```
       Also update the default on the `status` column from `'PENDING_REVIEW'` to `'PROCESSING'`:
       ```typescript
       status: batchStatusEnum('status').notNull().default('PROCESSING'),
       ```

    5. In `apps/api/src/infrastructure/database/drizzle/mappers/batch.mapper.ts`, no changes needed -- the `as BatchStatus` cast will continue to work since the string values are aligned.

    6. Generate a new Drizzle migration for the enum change:
       ```bash
       cd apps/api && npx drizzle-kit generate
       ```
       This will produce a migration file that alters the `batch_status` enum (renames `PENDING_REVIEW` to `PROCESSING`). Verify the generated SQL looks correct. Do NOT run `drizzle-kit push` or `drizzle-kit migrate` -- just generate.

    **Important:** The migration SQL for renaming a PostgreSQL enum value should use:
    ```sql
    ALTER TYPE "batch_status" RENAME VALUE 'PENDING_REVIEW' TO 'PROCESSING';
    ```
    If Drizzle generates DROP/CREATE instead, that's also acceptable since there's no production data yet.
  </action>
  <verify>
    Run `cd /Users/luanmartins/source/projects/populatte/apps/api && npx tsc --noEmit` to verify TypeScript compilation passes with the new abstract method and enum changes.
    Verify the migration file was generated in `apps/api/drizzle/`.
  </verify>
  <done>
    - `ProjectRepository` has `findByIdOnly(id: string)` abstract method
    - `DrizzleProjectRepository` implements `findByIdOnly` querying by id only (no userId, no deletedAt filter)
    - `BatchStatus` enum in entity uses `Processing = 'PROCESSING'` (not `PendingReview`)
    - Schema `batchStatusEnum` uses `['PROCESSING', 'COMPLETED', 'FAILED']` with default `'PROCESSING'`
    - Drizzle migration generated for the enum change
    - TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: CreateBatchUseCase with transactional orchestration and module wiring</name>
  <files>
    apps/api/src/core/use-cases/batch/create-batch.use-case.ts
    apps/api/src/core/use-cases/batch/index.ts
    apps/api/src/core/use-cases/index.ts
    apps/api/src/infrastructure/excel/ingestion.module.ts
  </files>
  <action>
    **Part A: Create CreateBatchUseCase**

    1. Create directory `apps/api/src/core/use-cases/batch/`.

    2. Create `apps/api/src/core/use-cases/batch/create-batch.use-case.ts`:

       Define `CreateBatchInput` interface:
       ```typescript
       export interface CreateBatchInput {
         projectId: string;
         userId: string;
         mode: BatchMode;
         files: ExcelFileInput[];
       }
       ```
       Import `BatchMode` from `../../entities/batch.entity` and `ExcelFileInput` from `../../../infrastructure/excel/strategies/excel-parsing.strategy`.

       Define `CreateBatchResult` interface:
       ```typescript
       export interface CreateBatchResult {
         batchId: string;
         rowCount: number;
         mode: BatchMode;
         fileCount: number;
       }
       ```

       Create the use case class following established patterns (Injectable, constructor injection, execute method):

       ```typescript
       @Injectable()
       export class CreateBatchUseCase {
         private readonly logger = new Logger(CreateBatchUseCase.name);

         public constructor(
           private readonly projectRepository: ProjectRepository,
           private readonly ingestionService: IngestionService,
         ) {}

         @Transactional()
         public async execute(input: CreateBatchInput): Promise<CreateBatchResult> {
           // Step 1: Find project WITHOUT userId filter (enables separate 404/403)
           const project = await this.projectRepository.findByIdOnly(input.projectId);

           if (!project) {
             throw new NotFoundException('Project not found');
           }

           // Step 2: Check if soft-deleted (specific error message per CONTEXT.md)
           if (project.deletedAt) {
             throw new NotFoundException('Project is archived');
           }

           // Step 3: Validate ownership (403 with security audit log)
           if (project.userId !== input.userId) {
             this.logger.warn(
               `Unauthorized batch creation attempt - userId: ${input.userId}, projectId: ${input.projectId}`,
             );
             throw new ForbiddenException('Access denied');
           }

           // Step 4: Delegate to IngestionService (all DB operations participate in THIS transaction)
           const result = await this.ingestionService.ingest({
             projectId: input.projectId,
             userId: input.userId,
             mode: input.mode,
             files: input.files,
           });

           // Step 5: Return summary
           return {
             batchId: result.batchId,
             rowCount: result.rowCount,
             mode: input.mode,
             fileCount: input.files.length,
           };
         }
       }
       ```

       Imports needed:
       - `Injectable`, `Logger`, `NotFoundException`, `ForbiddenException` from `@nestjs/common`
       - `Transactional` from `@nestjs-cls/transactional`
       - `BatchMode` from `../../entities/batch.entity`
       - `ProjectRepository` from `../../repositories/project.repository`
       - `IngestionService` from `../../../infrastructure/excel/ingestion.service`
       - `ExcelFileInput` from `../../../infrastructure/excel/strategies/excel-parsing.strategy` (use `import type`)

       **Important design notes:**
       - The `@Transactional()` decorator goes on the `execute()` method, NOT the class. This ensures ALL operations inside (batch create + row creates via IngestionService) share the same CLS-scoped transaction.
       - Do NOT add try/catch around `ingestionService.ingest()`. Any exception thrown will automatically trigger transaction rollback via `@Transactional()`. Adding try/catch would require explicit rethrow and risks swallowing errors.
       - Use NestJS built-in exceptions (NotFoundException, ForbiddenException) -- these integrate with the HTTP exception filter automatically.
       - The use case does NOT validate `mode` (valid enum values). That's the controller/DTO layer's job (Phase 10).

    3. Create `apps/api/src/core/use-cases/batch/index.ts` barrel export:
       ```typescript
       export * from './create-batch.use-case';
       ```

    4. Update `apps/api/src/core/use-cases/index.ts` to add batch barrel:
       ```typescript
       export * from './user';
       export * from './project';
       export * from './batch';
       ```

    **Part B: Register CreateBatchUseCase in IngestionModule**

    5. Update `apps/api/src/infrastructure/excel/ingestion.module.ts`:
       - Import `CreateBatchUseCase` from `../../core/use-cases/batch`
       - Add `CreateBatchUseCase` to the `providers` array
       - Add `CreateBatchUseCase` to the `exports` array (so the future batch controller module can inject it)

       The updated module should look like:
       ```typescript
       @Module({
         imports: [ExcelModule],
         providers: [IngestionService, CreateBatchUseCase],
         exports: [IngestionService, CreateBatchUseCase],
       })
       export class IngestionModule {}
       ```

       Why IngestionModule and not a new BatchModule? The use case depends on IngestionService which is only available within IngestionModule. ProjectRepository comes from global DrizzleModule. Keeping the use case here avoids circular imports and keeps batch ingestion concerns together.

       Update the JSDoc comment to reflect that CreateBatchUseCase is now provided and exported.
  </action>
  <verify>
    Run `cd /Users/luanmartins/source/projects/populatte/apps/api && npx tsc --noEmit` to verify TypeScript compilation passes.
    Run `cd /Users/luanmartins/source/projects/populatte && npm run lint --filter=@populatte/api` to verify ESLint passes.
  </verify>
  <done>
    - `CreateBatchUseCase` exists at `apps/api/src/core/use-cases/batch/create-batch.use-case.ts`
    - Use case has `@Transactional()` on `execute()` method
    - Two-step ownership validation: findByIdOnly -> check deletedAt -> check userId
    - NotFoundException for missing project (404), NotFoundException with "archived" for soft-deleted (404), ForbiddenException for ownership mismatch (403)
    - Logger.warn on unauthorized access attempts with userId and projectId
    - IngestionService.ingest() called within transactional boundary
    - Returns CreateBatchResult with batchId, rowCount, mode, fileCount
    - Barrel exports updated (batch/index.ts, use-cases/index.ts)
    - CreateBatchUseCase registered as provider and export in IngestionModule
    - TypeScript and ESLint pass cleanly
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/luanmartins/source/projects/populatte/apps/api && npx tsc --noEmit` -- TypeScript compiles with no errors
2. `cd /Users/luanmartins/source/projects/populatte && npm run lint --filter=@populatte/api` -- ESLint passes
3. Verify `ProjectRepository.findByIdOnly` exists and DrizzleProjectRepository implements it (grep for `findByIdOnly`)
4. Verify `@Transactional()` decorator is on `CreateBatchUseCase.execute()` (grep for `@Transactional`)
5. Verify ownership validation produces 404/403 separately (grep for `NotFoundException` and `ForbiddenException` in create-batch.use-case.ts)
6. Verify Logger.warn is called on unauthorized access (grep for `logger.warn` in create-batch.use-case.ts)
7. Verify IngestionModule provides and exports CreateBatchUseCase (grep for `CreateBatchUseCase` in ingestion.module.ts)
8. Verify BatchStatus enum aligned to PROCESSING (grep for `Processing.*PROCESSING` in batch.entity.ts)
9. Verify migration file generated in `apps/api/drizzle/`
</verification>

<success_criteria>
- CreateBatchUseCase validates project ownership with separate 404 (not found), 404 (archived), and 403 (not owned) errors
- @Transactional() wraps the full execute() method for atomic batch + row operations
- Security audit logging at WARN level for unauthorized access attempts
- IngestionService.ingest() called within transactional boundary for delegation
- BatchStatus enum aligned to PROCESSING/COMPLETED/FAILED across entity, schema, and mapper
- ProjectRepository.findByIdOnly enables two-step ownership validation
- Drizzle migration generated for enum change
- Use case registered in IngestionModule and exported for future controller injection
- TypeScript and ESLint pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-createbatch-use-case/05-01-SUMMARY.md`
</output>
