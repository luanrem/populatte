---
phase: 07-batch-endpoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/presentation/dto/batch.dto.ts
  - apps/api/src/presentation/controllers/batch.controller.ts
  - apps/api/src/presentation/controllers/index.ts
  - apps/api/src/infrastructure/batch/batch.module.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "POST /projects/:projectId/batches accepts multipart/form-data with mode field and documents file array"
    - "Endpoint is protected by ClerkAuthGuard (401 for missing/invalid auth)"
    - "Controller delegates entirely to CreateBatchUseCase with no business logic"
    - "Response includes batchId, rowCount, mode, fileCount on 201 Created"
  artifacts:
    - path: "apps/api/src/presentation/dto/batch.dto.ts"
      provides: "Zod schema for mode field validation and CreateBatchDto type"
      contains: "createBatchSchema"
    - path: "apps/api/src/presentation/controllers/batch.controller.ts"
      provides: "HTTP handler with Multer interceptor, ClerkAuthGuard, file transformation"
      exports: ["BatchController"]
    - path: "apps/api/src/infrastructure/batch/batch.module.ts"
      provides: "NestJS module importing IngestionModule and registering BatchController"
      exports: ["BatchModule"]
  key_links:
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "CreateBatchUseCase"
      via: "constructor injection from IngestionModule"
      pattern: "CreateBatchUseCase"
    - from: "apps/api/src/infrastructure/batch/batch.module.ts"
      to: "IngestionModule"
      via: "imports array"
      pattern: "imports.*IngestionModule"
    - from: "apps/api/src/app.module.ts"
      to: "BatchModule"
      via: "imports array"
      pattern: "imports.*BatchModule"
---

<objective>
Create the HTTP endpoint for batch creation that accepts multipart file uploads with Clerk authentication and delegates to CreateBatchUseCase.

Purpose: Expose the ingestion pipeline through a REST endpoint so the web dashboard can upload Excel files for processing.
Output: BatchController with Multer interceptor, Zod DTO, BatchModule, and AppModule wiring.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@apps/api/src/presentation/controllers/project.controller.ts
@apps/api/src/presentation/dto/project.dto.ts
@apps/api/src/presentation/pipes/zod-validation.pipe.ts
@apps/api/src/presentation/decorators/current-user.decorator.ts
@apps/api/src/infrastructure/project/project.module.ts
@apps/api/src/infrastructure/excel/ingestion.module.ts
@apps/api/src/app.module.ts

# Domain types
@apps/api/src/core/entities/batch.entity.ts
@apps/api/src/core/use-cases/batch/create-batch.use-case.ts
@apps/api/src/infrastructure/excel/strategies/excel-parsing.strategy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create batch DTO and BatchController</name>
  <files>
    apps/api/src/presentation/dto/batch.dto.ts
    apps/api/src/presentation/controllers/batch.controller.ts
  </files>
  <action>
**1. Create `apps/api/src/presentation/dto/batch.dto.ts`:**

Define a Zod schema for the `mode` form field:

```typescript
import { z } from 'zod';
import { BatchMode } from '../../core/entities/batch.entity';

export const createBatchSchema = z.object({
  mode: z.nativeEnum(BatchMode),
});

export type CreateBatchDto = z.infer<typeof createBatchSchema>;
```

**2. Create `apps/api/src/presentation/controllers/batch.controller.ts`:**

Follow the exact patterns from `ProjectController`:
- `@Controller('projects/:projectId/batches')` for nested resource routing
- `@UseGuards(ClerkAuthGuard)` at class level
- `@CurrentUser()` decorator for user extraction
- Inject `CreateBatchUseCase` via constructor

Controller structure:

```typescript
import {
  Controller,
  Post,
  Param,
  Body,
  UseGuards,
  UseInterceptors,
  UploadedFiles,
  BadRequestException,
} from '@nestjs/common';
import { FilesInterceptor } from '@nestjs/platform-express';

import type { User } from '../../core/entities/user.entity';
import { CreateBatchUseCase } from '../../core/use-cases/batch';
import { ClerkAuthGuard } from '../../infrastructure/auth/guards/clerk-auth.guard';
import { CurrentUser } from '../decorators/current-user.decorator';
import { createBatchSchema } from '../dto/batch.dto';
```

Route: `@Post()` (class-level controller path handles `/projects/:projectId/batches`)

Method signature:
```typescript
@Post()
@UseInterceptors(FilesInterceptor('documents', 20))
public async create(
  @Param('projectId') projectId: string,
  @Body('mode') mode: string,
  @UploadedFiles() uploadedFiles: Express.Multer.File[],
  @CurrentUser() user: User,
)
```

Method body:
1. Validate `mode` with Zod: `const validated = createBatchSchema.parse({ mode })` -- wrap in try/catch and throw `BadRequestException` with Zod error messages on failure (match ZodValidationPipe error format: `{ message: 'Validation failed', errors: [...] }`)
2. Validate files are present: if `!uploadedFiles || uploadedFiles.length === 0`, throw `BadRequestException('At least one file is required')`
3. Transform `Express.Multer.File[]` to `ExcelFileInput[]`: map each file to `{ buffer: file.buffer, originalName: file.originalname }`
4. Delegate to use case: `return this.createBatch.execute({ projectId, userId: user.id, mode: validated.mode, files })`
5. Return use case result directly (NestJS auto-sends 201 for POST)

Import `ExcelFileInput` type from `../../infrastructure/excel/strategies/excel-parsing.strategy` (type-only import).

Use `public` access modifier on methods (matches existing controller pattern).
  </action>
  <verify>
Run `npx tsc --noEmit` from `apps/api` to verify TypeScript compilation. Both new files must compile without errors.
  </verify>
  <done>
batch.dto.ts exports `createBatchSchema` and `CreateBatchDto` type. BatchController has a single POST method that validates mode with Zod, validates file presence, transforms Multer files to ExcelFileInput[], and delegates to CreateBatchUseCase. No business logic in controller.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BatchModule and wire into AppModule</name>
  <files>
    apps/api/src/infrastructure/batch/batch.module.ts
    apps/api/src/app.module.ts
    apps/api/src/presentation/controllers/index.ts
  </files>
  <action>
**1. Create `apps/api/src/infrastructure/batch/batch.module.ts`:**

Follow the `ProjectModule` pattern. Key difference: BatchModule does NOT register use cases as providers because `CreateBatchUseCase` is already provided and exported by `IngestionModule`. Instead, BatchModule imports `IngestionModule` to access the use case.

```typescript
import { Module } from '@nestjs/common';

import { IngestionModule } from '../excel/ingestion.module';
import { BatchController } from '../../presentation/controllers/batch.controller';

@Module({
  imports: [IngestionModule],
  controllers: [BatchController],
})
export class BatchModule {}
```

**2. Update `apps/api/src/app.module.ts`:**

Add `BatchModule` to the imports array, positioned after `ProjectModule` (presentation-layer modules grouped together):

- Add import: `import { BatchModule } from './infrastructure/batch/batch.module';`
- Add `BatchModule` to the `imports` array after `ProjectModule`

Do NOT add `BatchController` to AppModule's controllers array -- it is registered in `BatchModule`.

**3. Update `apps/api/src/presentation/controllers/index.ts`:**

Add barrel export for BatchController:

```typescript
export * from './batch.controller';
```

Add this line after the existing exports.
  </action>
  <verify>
Run `npx tsc --noEmit` from `apps/api` to verify full compilation. Then run `npm run lint --filter=@populatte/api` to verify no linting errors.
  </verify>
  <done>
BatchModule imports IngestionModule and registers BatchController. AppModule imports BatchModule. Controllers barrel export includes BatchController. Full TypeScript compilation and linting pass.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from `apps/api` with zero errors
2. `npm run lint --filter=@populatte/api` passes with zero errors
3. All five files exist at their expected paths
4. `BatchController` is registered in `BatchModule`, not directly in `AppModule`
5. `BatchModule` imports `IngestionModule` (not individual use cases as providers)
6. Controller method has `@UseInterceptors(FilesInterceptor('documents', 20))`
7. Controller method has `@UseGuards(ClerkAuthGuard)` at class level
8. Controller delegates to `CreateBatchUseCase.execute()` with correct input shape
9. No business logic in controller (no parsing, no ownership checks, no DB calls)
</verification>

<success_criteria>
- POST /projects/:projectId/batches route exists with Multer file interceptor
- ClerkAuthGuard protects all batch routes
- Mode field validated with Zod schema
- Express.Multer.File[] transformed to ExcelFileInput[] before delegation
- CreateBatchUseCase receives { projectId, userId, mode, files } and its result is returned as 201
- Full TypeScript compilation and linting pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-batch-endpoint/07-01-SUMMARY.md`
</output>
