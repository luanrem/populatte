---
phase: 09-file-content-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/presentation/pipes/file-content-validation.pipe.ts
  - apps/api/src/presentation/controllers/batch.controller.ts
autonomous: true

must_haves:
  truths:
    - "Uploading a renamed .xlsx file (e.g. a PDF renamed to .xlsx) returns HTTP 422 with error code INVALID_FILE_TYPE"
    - "Uploading a valid .xlsx file passes validation and reaches the use case"
    - "Uploading a valid .xls file passes validation and reaches the use case"
    - "Uploading a valid .csv file passes validation and reaches the use case"
    - "Uploading a file with valid ZIP bytes but wrong extension (e.g. data.pdf) returns HTTP 422"
    - "If any file in a multi-file upload is invalid, the entire batch is rejected (fail-fast)"
    - "Validation failures are logged server-side with filenames and detected bytes"
  artifacts:
    - path: "apps/api/src/presentation/pipes/file-content-validation.pipe.ts"
      provides: "FileContentValidationPipe with magic-byte inspection for XLSX/XLS/CSV"
      contains: "0x50, 0x4B, 0x03, 0x04"
    - path: "apps/api/src/presentation/controllers/batch.controller.ts"
      provides: "Controller wired with FileContentValidationPipe on @UploadedFiles"
      contains: "FileContentValidationPipe"
  key_links:
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "apps/api/src/presentation/pipes/file-content-validation.pipe.ts"
      via: "@UploadedFiles() decorator pipe parameter"
      pattern: "FileContentValidationPipe"
---

<objective>
Create a file content validation pipe that inspects magic bytes of uploaded files to verify they are genuine Excel (.xlsx, .xls) or CSV files before SheetJS processes them. Wire the pipe into the batch controller.

Purpose: Prevents MIME-type spoofing attacks where attackers rename malicious files with Excel extensions. This is a security gate that runs after Multer buffers files but before the use case layer processes them.

Output: A `FileContentValidationPipe` that validates both file extension AND buffer content match, integrated into `BatchController`.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-file-content-validation/09-CONTEXT.md
@.planning/phases/09-file-content-validation/09-RESEARCH.md

@apps/api/src/presentation/controllers/batch.controller.ts
@apps/api/src/presentation/pipes/zod-validation.pipe.ts
@apps/api/src/infrastructure/upload/filters/multer-exception.filter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileContentValidationPipe with magic-byte inspection</name>
  <files>apps/api/src/presentation/pipes/file-content-validation.pipe.ts</files>
  <action>
Create a NestJS pipe implementing `PipeTransform` that validates uploaded files via magic-byte inspection. The pipe receives `Express.Multer.File[]` and returns the array if valid, or throws `UnprocessableEntityException` (422) on first invalid file.

Implementation details:

1. Define magic-byte constants inline at the top of the file:
   - ZIP: `[0x50, 0x4B, 0x03, 0x04]` (4 bytes) -- used for .xlsx validation
   - OLE2: `[0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]` (8 bytes) -- used for .xls validation

2. Create a helper function `matchesMagicBytes(buffer: Buffer, signature: readonly number[]): boolean` that checks if buffer starts with the given byte sequence.

3. Create `FileContentValidationPipe` class with `@Injectable()` decorator:
   - Add `private readonly logger = new Logger(FileContentValidationPipe.name)`
   - Implement `transform(files: Express.Multer.File[]): Express.Multer.File[]` method
   - Iterate files with fail-fast: on first invalid file, log and throw
   - For each file, extract extension from `file.originalname` via `split('.').pop()?.toLowerCase()`
   - Validation logic per extension:
     - `.xlsx`: buffer must match ZIP magic bytes
     - `.xls`: buffer must match OLE2 magic bytes
     - `.csv`: buffer must pass UTF-8 text heuristic (no null bytes, >95% printable ASCII characters in first 512 bytes)
     - Any other extension: reject immediately (unsupported file type)
   - Handle empty/missing buffer: `if (!file.buffer || file.buffer.length === 0)` -> reject

4. CSV text validation helper method `isValidCsvContent(buffer: Buffer): boolean`:
   - Read first `Math.min(512, buffer.length)` bytes
   - Convert to UTF-8 string
   - Reject if contains null character (`\0`)
   - Count printable characters matching `[\x20-\x7E\r\n\t]`
   - Return `true` if ratio > 0.95

5. On validation failure:
   - Log with `this.logger.warn(...)` including: message, filename (`file.originalname`), mimetype, size, first 8 bytes as hex (`file.buffer.subarray(0, 8).toString('hex')`)
   - Throw `UnprocessableEntityException` with body:
     ```
     {
       statusCode: 422,
       message: 'One or more files are not valid Excel files',
       error: 'Unprocessable Entity',
       details: { code: 'INVALID_FILE_TYPE' }
     }
     ```
   - Do NOT list individual filenames in the error response (security)

6. Follow existing pipe patterns in the codebase (see `zod-validation.pipe.ts` for style reference). Use `public` access modifier on `transform` method per ESLint rules.

Do NOT use the `file-type` npm package (ESM-only, causes NestJS issues). Use manual buffer inspection only.
  </action>
  <verify>
Run `npx tsc --noEmit --project apps/api/tsconfig.json` to verify TypeScript compilation. Run `npm run lint --filter=@populatte/api` to verify linting passes.
  </verify>
  <done>
FileContentValidationPipe exists at `apps/api/src/presentation/pipes/file-content-validation.pipe.ts`, validates .xlsx (ZIP magic bytes), .xls (OLE2 magic bytes), and .csv (UTF-8 text heuristic), rejects unsupported extensions, fails fast on first invalid file, throws 422 with INVALID_FILE_TYPE error code, and logs failures server-side.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire FileContentValidationPipe into BatchController</name>
  <files>apps/api/src/presentation/controllers/batch.controller.ts</files>
  <action>
Modify `BatchController` to apply `FileContentValidationPipe` to the `@UploadedFiles()` decorator so validation runs after Multer buffers files but before the controller method body executes.

1. Import `FileContentValidationPipe` from `../pipes/file-content-validation.pipe`

2. Change the `@UploadedFiles()` decorator to include the pipe:
   ```
   @UploadedFiles(new FileContentValidationPipe())
   ```

3. The existing "file presence" check (`if (!uploadedFiles || uploadedFiles.length === 0)`) can remain as a safety net, but the pipe handles the primary validation. The pipe does NOT check for empty arrays (that's a different concern -- no files uploaded vs invalid files), so keep the existing check.

4. No other changes to the controller. The pipe runs transparently in the NestJS pipeline -- if validation passes, the controller receives the files as before; if validation fails, 422 is thrown before the method body executes.

5. Ensure all imports are organized per ESLint rules (external packages first, then internal).
  </action>
  <verify>
Run `npx tsc --noEmit --project apps/api/tsconfig.json` to verify TypeScript compilation. Run `npm run lint --filter=@populatte/api` to verify linting passes. Start the dev server with `npm run dev --filter=@populatte/api` and verify it starts without errors (Ctrl+C after startup).
  </verify>
  <done>
BatchController's `@UploadedFiles()` decorator uses `FileContentValidationPipe`. TypeScript compiles, ESLint passes, dev server starts. Files pass through the validation pipe before reaching the controller method body.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project apps/api/tsconfig.json` passes (no type errors)
2. `npm run lint --filter=@populatte/api` passes (no linting violations)
3. `FileContentValidationPipe` exists and exports correctly
4. `BatchController` imports and uses `FileContentValidationPipe` in `@UploadedFiles()` decorator
5. The pipe validates extension + content together (dual validation)
6. Fail-fast behavior: loop breaks on first invalid file
7. Error response uses HTTP 422 with `INVALID_FILE_TYPE` code
8. Server-side logging includes filename, mimetype, size, and detected bytes
</verification>

<success_criteria>
- Files with .xlsx extension and valid ZIP magic bytes (0x504B0304) pass validation
- Files with .xls extension and valid OLE2 magic bytes (0xD0CF11E0A1B11AE1) pass validation
- Files with .csv extension and valid UTF-8 text content pass validation
- Files with mismatched extension/content are rejected with HTTP 422
- Files with unsupported extensions are rejected with HTTP 422
- Entire batch is rejected on first invalid file (fail-fast)
- Error response includes `{ details: { code: 'INVALID_FILE_TYPE' } }`
- No individual filenames exposed in error response
- Validation failures logged server-side with file details
- TypeScript compilation and ESLint pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-file-content-validation/09-01-SUMMARY.md`
</output>
