---
phase: 11-repository-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/entities/pagination.types.ts
  - apps/api/src/core/entities/index.ts
  - apps/api/src/core/repositories/batch.repository.ts
  - apps/api/src/core/repositories/row.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts
autonomous: true

must_haves:
  truths:
    - "RowRepository.findByBatchIdPaginated() returns paginated rows with total count"
    - "BatchRepository.findByProjectIdPaginated() returns paginated batches with total count"
    - "All read queries across batch, row, and project repositories filter out soft-deleted records"
    - "Rows are sorted by sourceRowIndex ASC with id ASC tiebreaker"
    - "Batches are sorted by createdAt DESC (newest first)"
    - "ProjectRepository.findByIdOnly() filters soft-deleted records"
  artifacts:
    - path: "apps/api/src/core/entities/pagination.types.ts"
      provides: "PaginatedResult<T> generic type"
      contains: "PaginatedResult"
    - path: "apps/api/src/core/repositories/row.repository.ts"
      provides: "Abstract findByBatchIdPaginated method"
      contains: "findByBatchIdPaginated"
    - path: "apps/api/src/core/repositories/batch.repository.ts"
      provides: "Abstract findByProjectIdPaginated method"
      contains: "findByProjectIdPaginated"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts"
      provides: "Drizzle implementation of paginated row query"
      contains: "Promise.all"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts"
      provides: "Drizzle implementation of paginated batch query"
      contains: "Promise.all"
  key_links:
    - from: "apps/api/src/core/repositories/row.repository.ts"
      to: "apps/api/src/core/entities/pagination.types.ts"
      via: "import PaginatedResult"
      pattern: "import.*PaginatedResult"
    - from: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts"
      to: "apps/api/src/core/repositories/row.repository.ts"
      via: "extends RowRepository"
      pattern: "extends RowRepository"
    - from: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts"
      to: "apps/api/src/core/repositories/batch.repository.ts"
      via: "extends BatchRepository"
      pattern: "extends BatchRepository"
---

<objective>
Add paginated read methods to batch and row repositories, create the PaginatedResult<T> generic type, fix soft-delete filtering gaps, and correct sort ordering across all repository read methods.

Purpose: Phase 12 (Read Endpoints) depends on these repository methods to expose paginated batch/row data via REST. This plan provides the data access layer for the entire read cycle.

Output:
- `PaginatedResult<T>` type in core entities
- `findByBatchIdPaginated()` on RowRepository (abstract + Drizzle implementation)
- `findByProjectIdPaginated()` on BatchRepository (abstract + Drizzle implementation)
- Soft-delete filtering on `ProjectRepository.findByIdOnly()`
- Correct sort ordering on `BatchRepository.findByProjectId()` (DESC, not ASC)
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-repository-layer/11-CONTEXT.md
@.planning/phases/11-repository-layer/11-RESEARCH.md

Key existing files:
@apps/api/src/core/entities/batch.entity.ts
@apps/api/src/core/entities/row.entity.ts
@apps/api/src/core/entities/index.ts
@apps/api/src/core/repositories/batch.repository.ts
@apps/api/src/core/repositories/row.repository.ts
@apps/api/src/core/repositories/index.ts
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts
@apps/api/src/infrastructure/database/drizzle/mappers/batch.mapper.ts
@apps/api/src/infrastructure/database/drizzle/mappers/row.mapper.ts
@apps/api/src/infrastructure/database/drizzle/schema/ingestion-batches.schema.ts
@apps/api/src/infrastructure/database/drizzle/schema/ingestion-rows.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PaginatedResult type and extend abstract repositories</name>
  <files>
    apps/api/src/core/entities/pagination.types.ts
    apps/api/src/core/entities/index.ts
    apps/api/src/core/repositories/batch.repository.ts
    apps/api/src/core/repositories/row.repository.ts
  </files>
  <action>
    1. Create `apps/api/src/core/entities/pagination.types.ts` with:
       ```typescript
       export interface PaginatedResult<T> {
         items: T[];
         total: number;
       }
       ```
       This is a generic type returning items + total. The use case/controller layer will add `limit` and `offset` to compose the full response shape.

    2. Export from barrel: Add `export * from './pagination.types';` to `apps/api/src/core/entities/index.ts`.

    3. Add paginated method to `BatchRepository` abstract class (`apps/api/src/core/repositories/batch.repository.ts`):
       ```typescript
       import { PaginatedResult } from '../entities/pagination.types';
       ```
       Add method signature:
       ```typescript
       public abstract findByProjectIdPaginated(
         projectId: string,
         limit: number,
         offset: number,
       ): Promise<PaginatedResult<Batch>>;
       ```
       Add JSDoc comment on this method: `/** Caller MUST verify the project exists and is not soft-deleted before calling. */`

    4. Add paginated method to `RowRepository` abstract class (`apps/api/src/core/repositories/row.repository.ts`):
       ```typescript
       import { PaginatedResult } from '../entities/pagination.types';
       ```
       Add method signature:
       ```typescript
       public abstract findByBatchIdPaginated(
         batchId: string,
         limit: number,
         offset: number,
       ): Promise<PaginatedResult<Row>>;
       ```
       Add JSDoc comment on this method: `/** Caller MUST verify the parent batch exists and is not soft-deleted before calling. */`
  </action>
  <verify>
    Run `npx tsc --noEmit --project apps/api/tsconfig.json 2>&1 | head -30` to verify type definitions compile (expect errors from unimplemented abstract methods in Drizzle repositories — that's correct and expected, will be fixed in Task 2).
  </verify>
  <done>
    PaginatedResult<T> type exists and is exported. Both abstract repositories declare paginated methods. TypeScript compilation shows only "not implemented" errors for the new abstract methods in Drizzle implementations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Drizzle paginated methods, fix soft-delete and ordering</name>
  <files>
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts
  </files>
  <action>
    1. **DrizzleBatchRepository** (`drizzle-batch.repository.ts`):

       a. Add imports: `count`, `desc`, `asc` from `drizzle-orm`. Add import for `PaginatedResult` from core entities.

       b. Add `findByProjectIdPaginated()` implementation using the two-query pattern:
          ```typescript
          public async findByProjectIdPaginated(
            projectId: string,
            limit: number,
            offset: number,
          ): Promise<PaginatedResult<Batch>> {
            const conditions = and(
              eq(ingestionBatches.projectId, projectId),
              isNull(ingestionBatches.deletedAt),
            );

            const [data, countResult] = await Promise.all([
              this.drizzle
                .getClient()
                .select()
                .from(ingestionBatches)
                .where(conditions)
                .orderBy(desc(ingestionBatches.createdAt))
                .limit(limit)
                .offset(offset),
              this.drizzle
                .getClient()
                .select({ count: count() })
                .from(ingestionBatches)
                .where(conditions),
            ]);

            const total = countResult[0]?.count ?? 0;
            return {
              items: data.map((row) => BatchMapper.toDomain(row)),
              total,
            };
          }
          ```

       c. Fix `findByProjectId()` ordering: Change `.orderBy(ingestionBatches.createdAt)` to `.orderBy(desc(ingestionBatches.createdAt))` — batches must be sorted newest first per context decision.

    2. **DrizzleRowRepository** (`drizzle-row.repository.ts`):

       a. Add imports: `count`, `asc` from `drizzle-orm`. Add import for `PaginatedResult` from core entities.

       b. Add `findByBatchIdPaginated()` implementation using the two-query pattern:
          ```typescript
          public async findByBatchIdPaginated(
            batchId: string,
            limit: number,
            offset: number,
          ): Promise<PaginatedResult<Row>> {
            const conditions = and(
              eq(ingestionRows.batchId, batchId),
              isNull(ingestionRows.deletedAt),
            );

            const [data, countResult] = await Promise.all([
              this.drizzle
                .getClient()
                .select()
                .from(ingestionRows)
                .where(conditions)
                .orderBy(asc(ingestionRows.sourceRowIndex), asc(ingestionRows.id))
                .limit(limit)
                .offset(offset),
              this.drizzle
                .getClient()
                .select({ count: count() })
                .from(ingestionRows)
                .where(conditions),
            ]);

            const total = countResult[0]?.count ?? 0;
            return {
              items: data.map((row) => RowMapper.toDomain(row)),
              total,
            };
          }
          ```

    3. **DrizzleProjectRepository** (`drizzle-project.repository.ts`):

       a. Fix `findByIdOnly()` to add soft-delete filter. Current code:
          ```typescript
          .where(eq(projects.id, id))
          ```
          Change to:
          ```typescript
          .where(and(eq(projects.id, id), isNull(projects.deletedAt)))
          ```
          The `and` and `isNull` imports already exist in this file.

    **Important patterns to follow:**
    - Extract `conditions` variable shared between data query and count query (prevents Pitfall 5 from RESEARCH.md)
    - Always use `count()` helper from drizzle-orm (not raw SQL template)
    - Always include tiebreaker `asc(id)` for row ordering (prevents Pitfall 1)
    - Batch ordering uses `desc(createdAt)` only (createdAt is unique enough via defaultNow + uuid id)
  </action>
  <verify>
    Run `npx tsc --noEmit --project apps/api/tsconfig.json 2>&1 | head -50` — expect clean compilation (0 errors, excluding pre-existing known issues).

    Run `npm run lint --filter=@populatte/api 2>&1 | tail -20` — verify no new lint errors.

    Verify soft-delete filtering completeness by searching: `grep -n "\.select()" apps/api/src/infrastructure/database/drizzle/repositories/*.ts` — every select() query in a read method should have `isNull(*.deletedAt)` in its where clause.
  </verify>
  <done>
    - `findByProjectIdPaginated()` returns `PaginatedResult<Batch>` with batches sorted by `createdAt DESC`
    - `findByBatchIdPaginated()` returns `PaginatedResult<Row>` with rows sorted by `sourceRowIndex ASC, id ASC`
    - `findByIdOnly()` on project repository filters soft-deleted records
    - `findByProjectId()` on batch repository sorts `createdAt DESC` (not ASC)
    - TypeScript compiles cleanly and lint passes
    - All `.select()` read queries have `isNull(deletedAt)` filtering
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --project apps/api/tsconfig.json` compiles without new errors
2. `npm run lint --filter=@populatte/api` passes without new errors
3. `grep -n "isNull" apps/api/src/infrastructure/database/drizzle/repositories/*.ts` shows soft-delete filtering on every read query
4. `grep -n "findByProjectIdPaginated\|findByBatchIdPaginated" apps/api/src/core/repositories/*.ts` confirms abstract methods exist
5. `grep -n "Promise.all" apps/api/src/infrastructure/database/drizzle/repositories/*.ts` confirms parallel query pattern in both paginated implementations
6. `grep -n "PaginatedResult" apps/api/src/core/entities/pagination.types.ts` confirms type exists
</verification>

<success_criteria>
- PaginatedResult<T> type defined in core entities and exported via barrel
- RowRepository abstract class declares findByBatchIdPaginated(batchId, limit, offset)
- BatchRepository abstract class declares findByProjectIdPaginated(projectId, limit, offset)
- DrizzleRowRepository implements findByBatchIdPaginated with Promise.all two-query pattern
- DrizzleBatchRepository implements findByProjectIdPaginated with Promise.all two-query pattern
- All read queries across batch, row, and project repositories filter isNull(deletedAt)
- Rows ordered by sourceRowIndex ASC, id ASC
- Batches ordered by createdAt DESC
- TypeScript compiles and lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-repository-layer/11-01-SUMMARY.md`
</output>
