---
phase: 12-read-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/repositories/row.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
  - apps/api/src/core/use-cases/batch/get-batch.use-case.ts
  - apps/api/src/core/use-cases/batch/list-batches.use-case.ts
  - apps/api/src/core/use-cases/batch/list-rows.use-case.ts
  - apps/api/src/core/use-cases/batch/index.ts
  - apps/api/src/presentation/dto/batch.dto.ts
  - apps/api/src/presentation/controllers/batch.controller.ts
  - apps/api/src/infrastructure/batch/batch.module.ts
autonomous: true

must_haves:
  truths:
    - "GET /projects/:projectId/batches returns paginated batch list with totalRows per batch"
    - "GET /projects/:projectId/batches/:batchId returns single batch with totalRows"
    - "GET /projects/:projectId/batches/:batchId/rows returns paginated rows ordered by sourceRowIndex"
    - "All three endpoints return 404 if project not found, 403 if user is not owner"
    - "Pagination uses limit range 1-100 (default 50), offset >= 0 (default 0)"
    - "Invalid pagination params return 400 Bad Request, not silent fallback"
  artifacts:
    - path: "apps/api/src/core/use-cases/batch/get-batch.use-case.ts"
      provides: "Single batch detail with totalRows"
      exports: ["GetBatchUseCase"]
    - path: "apps/api/src/core/use-cases/batch/list-batches.use-case.ts"
      provides: "Paginated batch list with totalRows per batch"
      exports: ["ListBatchesUseCase"]
    - path: "apps/api/src/core/use-cases/batch/list-rows.use-case.ts"
      provides: "Paginated row list for a batch"
      exports: ["ListRowsUseCase"]
    - path: "apps/api/src/presentation/dto/batch.dto.ts"
      provides: "Pagination query Zod schema"
      contains: "paginationQuerySchema"
    - path: "apps/api/src/presentation/controllers/batch.controller.ts"
      provides: "GET endpoints for batches and rows"
      min_lines: 50
  key_links:
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "apps/api/src/core/use-cases/batch/get-batch.use-case.ts"
      via: "constructor injection"
      pattern: "GetBatchUseCase"
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "apps/api/src/core/use-cases/batch/list-batches.use-case.ts"
      via: "constructor injection"
      pattern: "ListBatchesUseCase"
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "apps/api/src/core/use-cases/batch/list-rows.use-case.ts"
      via: "constructor injection"
      pattern: "ListRowsUseCase"
    - from: "apps/api/src/core/use-cases/batch/get-batch.use-case.ts"
      to: "apps/api/src/core/repositories/row.repository.ts"
      via: "countByBatchId call"
      pattern: "countByBatchId"
    - from: "apps/api/src/infrastructure/batch/batch.module.ts"
      to: "apps/api/src/core/use-cases/batch/index.ts"
      via: "providers array"
      pattern: "GetBatchUseCase.*ListBatchesUseCase.*ListRowsUseCase"
---

<objective>
Create three GET endpoints for reading batch metadata and paginated row data with ownership validation.

Purpose: Close the read cycle for ingested data so the dashboard can display batch metadata and paginated rows for user validation before automation.

Output: Three working GET routes on BatchController — single batch detail, batch list, and paginated rows — all enforcing project ownership with 404/403 distinction.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-read-endpoints/12-CONTEXT.md
@.planning/phases/12-read-endpoints/12-RESEARCH.md
@.planning/phases/11-repository-layer/11-01-SUMMARY.md

Key existing files:
@apps/api/src/core/use-cases/batch/create-batch.use-case.ts (ownership validation pattern to follow)
@apps/api/src/core/repositories/batch.repository.ts (findByProjectIdPaginated exists)
@apps/api/src/core/repositories/row.repository.ts (findByBatchIdPaginated exists, countByBatchId does NOT exist yet — Task 1 creates it)
@apps/api/src/core/entities/batch.entity.ts (Batch interface)
@apps/api/src/core/entities/row.entity.ts (Row interface)
@apps/api/src/core/entities/pagination.types.ts (PaginatedResult<T>)
@apps/api/src/presentation/controllers/batch.controller.ts (add GET routes here)
@apps/api/src/presentation/dto/batch.dto.ts (add pagination schema here)
@apps/api/src/presentation/pipes/zod-validation.pipe.ts (reuse for query validation)
@apps/api/src/presentation/decorators/current-user.decorator.ts (CurrentUser decorator)
@apps/api/src/infrastructure/batch/batch.module.ts (register new use cases)
@apps/api/src/infrastructure/excel/ingestion.module.ts (CreateBatchUseCase lives here)
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts (add countByBatchId impl)
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts (reference for pattern)
@apps/api/src/core/use-cases/batch/index.ts (barrel export)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core layer — create countByBatchId method from scratch and three use cases</name>
  <files>
    apps/api/src/core/repositories/row.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
    apps/api/src/core/use-cases/batch/get-batch.use-case.ts
    apps/api/src/core/use-cases/batch/list-batches.use-case.ts
    apps/api/src/core/use-cases/batch/list-rows.use-case.ts
    apps/api/src/core/use-cases/batch/index.ts
  </files>
  <action>
    **1. Create countByBatchId — a brand new method (does not exist yet)**

    This method does NOT exist anywhere in the codebase. You are creating it from scratch on both the abstract class and the Drizzle implementation.

    In `apps/api/src/core/repositories/row.repository.ts`, add a new abstract method:
    ```typescript
    public abstract countByBatchId(batchId: string): Promise<number>;
    ```

    In `apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts`, create the implementation:
    - Use `count()` from drizzle-orm with `and(eq(ingestionRows.batchId, batchId), isNull(ingestionRows.deletedAt))`
    - Return `result[0]?.count ?? 0`
    - Follow same import/pattern as existing `findByBatchIdPaginated`

    **2. Create GetBatchUseCase** (`apps/api/src/core/use-cases/batch/get-batch.use-case.ts`)

    Follow the exact ownership validation pattern from `create-batch.use-case.ts`:
    - @Injectable() class with Logger
    - Constructor injects ProjectRepository, BatchRepository, RowRepository
    - `execute(projectId: string, batchId: string, userId: string): Promise<GetBatchResult>`
    - Step 1: `findByIdOnly(projectId)` — if null, throw `NotFoundException('Project not found')`
    - Step 2: if `project.deletedAt`, throw `NotFoundException('Project is archived')`
    - Step 3: if `project.userId !== userId`, log warn and throw `ForbiddenException('Access denied')`
    - Step 4: `findById(batchId)` — if null, throw `NotFoundException('Batch not found')`
    - Step 5: Defense-in-depth: if `batch.projectId !== projectId`, throw `NotFoundException('Batch not found')`
    - Step 6: `countByBatchId(batchId)` to get totalRows
    - Step 7: Return `{ ...batch, totalRows }` (spread batch fields + computed totalRows)

    Export `GetBatchResult` interface extending Batch with `totalRows: number`.

    **3. Create ListBatchesUseCase** (`apps/api/src/core/use-cases/batch/list-batches.use-case.ts`)

    Same ownership validation pattern (Steps 1-3), then:
    - Step 4: `findByProjectIdPaginated(projectId, limit, offset)` to get paginated batches
    - Step 5: For each batch in items, call `countByBatchId(batch.id)` to add totalRows (use `Promise.all` for parallel count queries)
    - Step 6: Return `{ items: batchesWithTotalRows, total: result.total, limit, offset }`

    **N+1 query note:** This creates N+1 queries (1 list + N count queries). This is an intentional MVP trade-off — the context decision explicitly requires "each batch in the list includes totalRows count", and Promise.all parallelizes the count queries. With max limit=100, this means at most 101 parallel queries, acceptable for MVP. Optimization (e.g., SQL subquery or JOIN) is deferred to a future performance phase.

    Export `ListBatchesResult` interface with `items`, `total`, `limit`, `offset`. Each item in items should have all Batch fields plus `totalRows: number`.

    **4. Create ListRowsUseCase** (`apps/api/src/core/use-cases/batch/list-rows.use-case.ts`)

    Ownership validation (Steps 1-3 for project), then:
    - Step 4: `findById(batchId)` — if null, throw `NotFoundException('Batch not found')`
    - Step 5: Defense-in-depth: if `batch.projectId !== projectId`, throw `NotFoundException('Batch not found')`
    - Step 6: `findByBatchIdPaginated(batchId, limit, offset)` (already sorted by sourceRowIndex ASC)
    - Step 7: Return `{ items: result.items, total: result.total, limit, offset }`

    Export `ListRowsResult` interface with `items`, `total`, `limit`, `offset`.

    **5. Update barrel export** (`apps/api/src/core/use-cases/batch/index.ts`)

    Add exports for all three new use cases alongside existing CreateBatchUseCase export.

    **Parameter ordering convention (follow existing codebase pattern):**
    All use cases follow `(resourceIds..., userId, queryParams...)`:
    - `GetBatchUseCase.execute(projectId, batchId, userId)` — resource IDs first, then userId
    - `ListBatchesUseCase.execute(projectId, userId, limit, offset)` — resource ID, userId, then query params
    - `ListRowsUseCase.execute(projectId, batchId, userId, limit, offset)` — resource IDs, userId, then query params

    This matches existing patterns: `get-project.use-case(id, userId)`, `delete-project.use-case(id, userId)`, `update-project.use-case(id, userId, data)`.

    **Important patterns to follow:**
    - All use cases are `@Injectable()` with `private readonly logger = new Logger(ClassName.name)`
    - Ownership validation uses exact same 3-step pattern as CreateBatchUseCase
    - Security audit logs use `this.logger.warn()` with userId and resource ID
    - NestJS exception classes: NotFoundException, ForbiddenException (imported from @nestjs/common)
    - Entity-aware messages: "Project not found", "Batch not found" (names entity, not ID)
  </action>
  <verify>
    Run `npm run lint --filter=@populatte/api` and `npm run type-check --filter=@populatte/api` — both must pass with zero errors.
  </verify>
  <done>
    Three use case files exist with ownership validation, countByBatchId is created from scratch in both abstract and Drizzle repositories, barrel export updated. Parameter ordering follows (resourceIds..., userId, queryParams...) convention. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Presentation layer — pagination DTO, controller routes, module wiring</name>
  <files>
    apps/api/src/presentation/dto/batch.dto.ts
    apps/api/src/presentation/controllers/batch.controller.ts
    apps/api/src/infrastructure/batch/batch.module.ts
  </files>
  <action>
    **1. Add pagination Zod schema to batch.dto.ts**

    In `apps/api/src/presentation/dto/batch.dto.ts`, add alongside existing `createBatchSchema`:
    ```typescript
    export const paginationQuerySchema = z.object({
      limit: z.coerce.number().int().min(1).max(100).default(50),
      offset: z.coerce.number().int().min(0).default(0),
    });

    export type PaginationQueryDto = z.infer<typeof paginationQuerySchema>;
    ```

    Keep existing `createBatchSchema` and `CreateBatchDto` unchanged.

    **2. Add GET routes to BatchController**

    In `apps/api/src/presentation/controllers/batch.controller.ts`:
    - Add `Get` and `Query` to imports from `@nestjs/common`
    - Import `GetBatchUseCase`, `ListBatchesUseCase`, `ListRowsUseCase` from `../../core/use-cases/batch`
    - Import `ZodValidationPipe` from `../pipes/zod-validation.pipe`
    - Import `paginationQuerySchema` and `PaginationQueryDto` from `../dto/batch.dto`
    - Update constructor to inject all four use cases (existing createBatch + three new ones)

    Add three GET methods:

    ```typescript
    @Get()
    public async list(
      @Param('projectId') projectId: string,
      @Query(new ZodValidationPipe(paginationQuerySchema)) query: PaginationQueryDto,
      @CurrentUser() user: User,
    ) {
      return this.listBatches.execute(projectId, user.id, query.limit, query.offset);
    }

    @Get(':batchId')
    public async getById(
      @Param('projectId') projectId: string,
      @Param('batchId') batchId: string,
      @CurrentUser() user: User,
    ) {
      return this.getBatch.execute(projectId, batchId, user.id);
    }

    @Get(':batchId/rows')
    public async listRows(
      @Param('projectId') projectId: string,
      @Param('batchId') batchId: string,
      @Query(new ZodValidationPipe(paginationQuerySchema)) query: PaginationQueryDto,
      @CurrentUser() user: User,
    ) {
      return this.listRowsUseCase.execute(projectId, batchId, user.id, query.limit, query.offset);
    }
    ```

    **Route ordering matters:** NestJS matches routes top-to-bottom. Place `@Get()` (list) before `@Get(':batchId')` (detail) before `@Get(':batchId/rows')` (nested). This prevents `:batchId` from matching "rows" as a batchId.

    **3. Wire use cases in BatchModule**

    In `apps/api/src/infrastructure/batch/batch.module.ts`:
    - Import `GetBatchUseCase`, `ListBatchesUseCase`, `ListRowsUseCase` from `../../core/use-cases/batch`
    - Add all three to the `providers` array
    - Keep existing IngestionModule import (provides CreateBatchUseCase)
    - Keep existing middleware configuration for POST route unchanged

    **Important:**
    - Do NOT remove any existing imports, the FilesInterceptor, the Multer file handling, or the POST route
    - Existing `createBatch` constructor param name stays as-is
    - Use `private readonly` for all injected use cases in controller constructor
    - `@UseGuards(ClerkAuthGuard)` already applies to all routes at class level — no changes needed
  </action>
  <verify>
    Run `npm run lint --filter=@populatte/api` and `npm run type-check --filter=@populatte/api` — both must pass.
    Then run `npm run build --filter=@populatte/api` — must compile successfully.
  </verify>
  <done>
    BatchController has 4 routes (1 POST + 3 GET). Pagination schema validates limit 1-100 with default 50, offset >= 0 with default 0. All three GET use cases are wired in BatchModule. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint --filter=@populatte/api` passes with zero errors
2. `npm run type-check --filter=@populatte/api` passes with zero errors
3. `npm run build --filter=@populatte/api` compiles successfully
4. All three use case files exist and export their classes
5. BatchController has @Get(), @Get(':batchId'), @Get(':batchId/rows') routes
6. paginationQuerySchema validates: limit min=1 max=100 default=50, offset min=0 default=0
7. countByBatchId exists on both abstract RowRepository and DrizzleRowRepository (created from scratch, not pre-existing)
8. All use cases use the 3-step ownership pattern: findByIdOnly -> deletedAt check -> userId match
9. GetBatch and ListRows verify batch.projectId === projectId (defense-in-depth)
10. ListBatches computes totalRows per batch via countByBatchId with Promise.all parallelization
11. All use case execute() methods follow (resourceIds..., userId, queryParams...) parameter convention
</verification>

<success_criteria>
- Three GET endpoints compile and are registered on BatchController
- Ownership validation follows established pattern (404 project, 403 ownership)
- Pagination uses Zod coercion with defaults (50/0) and limits (min=1, max=100)
- Defense-in-depth validation checks batch belongs to project
- totalRows computed via dedicated countByBatchId (not pagination hack)
- All use case parameter signatures follow (resourceIds..., userId, queryParams...) convention
- All lint, type-check, and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-read-endpoints/12-01-SUMMARY.md`
</output>
