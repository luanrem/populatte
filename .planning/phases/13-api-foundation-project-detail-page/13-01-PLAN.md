---
phase: 13-api-foundation-project-detail-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/api/client.ts
  - apps/web/lib/api/schemas/batch.schema.ts
  - apps/web/lib/api/schemas/index.ts
  - apps/web/lib/api/endpoints/batches.ts
  - apps/web/lib/api/endpoints/index.ts
  - apps/web/lib/query/hooks/use-batches.ts
  - apps/web/lib/query/hooks/index.ts
  - apps/web/app/(platform)/projects/[id]/page.tsx
  - apps/web/components/projects/batch-empty-state.tsx
autonomous: true

must_haves:
  truths:
    - "User navigates to /projects/[id] and sees the project name in the page header"
    - "Project detail page renders a 'Nova Importacao' button (non-functional until Phase 14)"
    - "Batch API client supports FormData uploads without hardcoded Content-Type breaking multipart"
    - "Zod schemas validate batch list, batch detail, and paginated row responses at runtime"
    - "React Query hooks (useBatches, useBatch, useBatchRows, useUploadBatch) are available and wired"
  artifacts:
    - path: "apps/web/lib/api/schemas/batch.schema.ts"
      provides: "Zod schemas for batch list, batch detail, paginated rows"
      exports: ["batchResponseSchema", "batchListResponseSchema", "rowResponseSchema", "paginatedRowsResponseSchema", "BatchResponse", "RowResponse", "PaginatedRowsResponse"]
    - path: "apps/web/lib/api/endpoints/batches.ts"
      provides: "Batch endpoint factory with list, getById, listRows, upload"
      exports: ["createBatchEndpoints"]
    - path: "apps/web/lib/query/hooks/use-batches.ts"
      provides: "React Query hooks for batch operations"
      exports: ["useBatches", "useBatch", "useBatchRows", "useUploadBatch"]
    - path: "apps/web/app/(platform)/projects/[id]/page.tsx"
      provides: "Project detail page shell"
      min_lines: 40
    - path: "apps/web/components/projects/batch-empty-state.tsx"
      provides: "Empty state for batch grid section"
      exports: ["BatchEmptyState"]
  key_links:
    - from: "apps/web/lib/api/endpoints/batches.ts"
      to: "apps/web/lib/api/schemas/batch.schema.ts"
      via: "Zod safeParse validation on every API response"
      pattern: "safeParse"
    - from: "apps/web/lib/query/hooks/use-batches.ts"
      to: "apps/web/lib/api/endpoints/batches.ts"
      via: "createBatchEndpoints(client.fetch) in each hook"
      pattern: "createBatchEndpoints"
    - from: "apps/web/app/(platform)/projects/[id]/page.tsx"
      to: "apps/web/lib/query/hooks/use-batches.ts"
      via: "useBatches hook for batch list data"
      pattern: "useBatches"
    - from: "apps/web/lib/api/client.ts"
      to: "FormData detection"
      via: "Skip Content-Type for FormData bodies"
      pattern: "FormData"
---

<objective>
Create the full frontend API plumbing for batch operations (Zod schemas, endpoint factory, React Query hooks) with a FormData upload fix, and build the project detail page shell at /projects/[id].

Purpose: This plan wires the Next.js dashboard to the batch API endpoints built in v2.0/v2.1, and gives users a project detail page where batch operations will live. Without this foundation, no upload modal, batch grid, or data table can be built.

Output:
- Fixed API client that supports FormData uploads (no hardcoded Content-Type for multipart)
- Zod schemas for batch list, batch detail, and paginated row responses
- Batch endpoint factory following existing createProjectEndpoints pattern
- React Query hooks: useBatches, useBatch, useBatchRows, useUploadBatch
- Project detail page at /projects/[id] with header, breadcrumb, "Nova Importacao" button, and empty state
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-api-foundation-project-detail-page/13-CONTEXT.md
@.planning/phases/13-api-foundation-project-detail-page/13-RESEARCH.md

# Existing patterns to follow exactly:
@apps/web/lib/api/client.ts
@apps/web/lib/api/types.ts
@apps/web/lib/api/schemas/project.schema.ts
@apps/web/lib/api/endpoints/projects.ts
@apps/web/lib/query/hooks/use-projects.ts
@apps/web/lib/query/hooks/use-me.ts
@apps/web/app/(platform)/projects/page.tsx
@apps/web/components/layout/app-header.tsx

# API response shapes (source of truth for Zod schemas):
@apps/api/src/core/entities/batch.entity.ts
@apps/api/src/core/entities/row.entity.ts
@apps/api/src/core/use-cases/batch/list-batches.use-case.ts
@apps/api/src/core/use-cases/batch/get-batch.use-case.ts
@apps/api/src/core/use-cases/batch/list-rows.use-case.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix FormData support in API client and create batch Zod schemas + endpoint factory</name>
  <files>
    apps/web/lib/api/client.ts
    apps/web/lib/api/schemas/batch.schema.ts
    apps/web/lib/api/schemas/index.ts
    apps/web/lib/api/endpoints/batches.ts
    apps/web/lib/api/endpoints/index.ts
  </files>
  <action>
**1) Fix FormData Content-Type in `apps/web/lib/api/client.ts` (line 83):**

Replace the unconditional `headers.set('Content-Type', 'application/json')` with conditional logic that skips Content-Type when the body is FormData. The browser MUST auto-generate the multipart boundary for FormData uploads.

Change line 83 from:
```typescript
headers.set('Content-Type', 'application/json');
```
To:
```typescript
if (!(requestOptions.body instanceof FormData)) {
  headers.set('Content-Type', 'application/json');
}
```

This must be the ONLY change to client.ts. Do not modify the retry logic or any other behavior.

**2) Create `apps/web/lib/api/schemas/batch.schema.ts`:**

Define Zod schemas matching the API response shapes from the backend entities and use cases. The schemas must use `z.infer` for type exports.

Schemas needed:

- `columnMetadataSchema` - object with: originalHeader (string), normalizedKey (string), inferredType (string), position (number)
- `batchResponseSchema` - object with: id (string), projectId (string), userId (string), mode (enum: 'LIST_MODE' | 'PROFILE_MODE'), status (enum: 'PROCESSING' | 'COMPLETED' | 'FAILED'), fileCount (number), rowCount (number), columnMetadata (array of columnMetadataSchema), totalRows (number), createdAt (string — JSON serialized dates arrive as ISO strings), updatedAt (string), deletedAt (string nullable), deletedBy (string nullable)
- `batchListResponseSchema` - object with: items (array of batchResponseSchema), total (number), limit (number), offset (number)
- `validationMessageSchema` - object with: field (string), type (string), message (string)
- `rowResponseSchema` - object with: id (string), batchId (string), data (z.record(z.string(), z.unknown())), status (enum: 'DRAFT' | 'VALID' | 'WARNING' | 'ERROR'), validationMessages (array of validationMessageSchema), sourceFileName (string), sourceSheetName (string), sourceRowIndex (number), createdAt (string), updatedAt (string), deletedAt (string nullable)
- `paginatedRowsResponseSchema` - object with: items (array of rowResponseSchema), total (number), limit (number), offset (number)

Export inferred types: `BatchResponse`, `BatchListResponse`, `RowResponse`, `PaginatedRowsResponse`, `ColumnMetadata`.

**3) Update `apps/web/lib/api/schemas/index.ts`:**

Add barrel export: `export * from './batch.schema';`

**4) Create `apps/web/lib/api/endpoints/batches.ts`:**

Follow the exact same factory pattern as `createProjectEndpoints` in `projects.ts`. Add `'use client'` directive at top.

```typescript
export function createBatchEndpoints(
  fetchFn: (endpoint: string, options?: RequestInit) => Promise<Response>,
)
```

Methods:
- `list(projectId: string, limit?: number, offset?: number)` — GET `/projects/${projectId}/batches?limit=${limit}&offset=${offset}`. Default limit=50, offset=0. Validate response with `batchListResponseSchema.safeParse()`. On validation failure, log error with `console.error('[API] Batch list response validation failed:', result.error.issues)` and throw `new Error('Invalid batch list data received from server')`. Return `BatchListResponse`.
- `getById(projectId: string, batchId: string)` — GET `/projects/${projectId}/batches/${batchId}`. Validate with `batchResponseSchema.safeParse()`. Return `BatchResponse`.
- `listRows(projectId: string, batchId: string, limit?: number, offset?: number)` — GET `/projects/${projectId}/batches/${batchId}/rows?limit=${limit}&offset=${offset}`. Default limit=50, offset=0. Validate with `paginatedRowsResponseSchema.safeParse()`. Return `PaginatedRowsResponse`.
- `upload(projectId: string, formData: FormData)` — POST `/projects/${projectId}/batches` with body: formData (NOT JSON.stringify). Do NOT set Content-Type — the FormData fix in client.ts handles this. Validate response with `batchResponseSchema.safeParse()`. Return `BatchResponse`.

For query string construction: only append limit/offset params if they differ from defaults (or always append them — either is fine, but be consistent).

**5) Update `apps/web/lib/api/endpoints/index.ts`:**

Add barrel export: `export * from './batches';` (keep existing exports).
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/web/tsconfig.json` — no type errors in the new files.
    Visually inspect that `client.ts` has the FormData check and `batch.schema.ts` has all 6 schemas with type exports.
  </verify>
  <done>
    - API client conditionally sets Content-Type only for non-FormData bodies
    - batch.schema.ts exports 6 Zod schemas and 5 inferred TypeScript types
    - batches.ts exports createBatchEndpoints with list, getById, listRows, upload methods
    - Barrel exports updated in schemas/index.ts and endpoints/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React Query hooks for batch operations</name>
  <files>
    apps/web/lib/query/hooks/use-batches.ts
    apps/web/lib/query/hooks/index.ts
  </files>
  <action>
**1) Create `apps/web/lib/query/hooks/use-batches.ts`:**

Follow the exact patterns established in `use-projects.ts` and `use-me.ts`. Add `'use client'` directive at top.

Import `useQuery`, `useMutation`, `useQueryClient` from `@tanstack/react-query`. Import `useApiClient` from the client module. Import `createBatchEndpoints` from the endpoints module. Import types `BatchListResponse`, `BatchResponse`, `PaginatedRowsResponse` from the schemas.

Hooks to create:

- `useBatches(projectId: string)` — useQuery with:
  - queryKey: `['projects', projectId, 'batches']`
  - queryFn: calls `endpoints.list(projectId)`
  - enabled: `!!projectId`
  - Return type: `BatchListResponse`

- `useBatch(projectId: string, batchId: string)` — useQuery with:
  - queryKey: `['projects', projectId, 'batches', batchId]`
  - queryFn: calls `endpoints.getById(projectId, batchId)`
  - enabled: `!!projectId && !!batchId`
  - Return type: `BatchResponse`

- `useBatchRows(projectId: string, batchId: string, limit?: number, offset?: number)` — useQuery with:
  - queryKey: `['projects', projectId, 'batches', batchId, 'rows', { limit, offset }]`
  - queryFn: calls `endpoints.listRows(projectId, batchId, limit, offset)`
  - enabled: `!!projectId && !!batchId`
  - Return type: `PaginatedRowsResponse`

- `useUploadBatch(projectId: string)` — useMutation with:
  - mutationFn: receives `FormData`, calls `endpoints.upload(projectId, formData)`
  - onSuccess: invalidates `['projects', projectId, 'batches']` query key (APIF-05 requirement: upload invalidates batch list cache)
  - Generic types: `<BatchResponse, Error, FormData>`

Each hook must: create client with `useApiClient()`, create endpoints with `createBatchEndpoints(client.fetch)`, then return the query/mutation result.

**2) Update `apps/web/lib/query/hooks/index.ts`:**

Add barrel export: `export * from './use-batches';` (keep existing `export * from './use-me';`).
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/web/tsconfig.json` — no type errors.
    Confirm all 4 hooks are exported by checking the index.ts barrel.
  </verify>
  <done>
    - useBatches, useBatch, useBatchRows, useUploadBatch hooks created with correct query keys
    - useUploadBatch invalidates batch list cache on success (APIF-05)
    - All hooks use enabled flag for conditional queries
    - Barrel export updated in hooks/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Create project detail page with header, breadcrumb, action button, and empty state</name>
  <files>
    apps/web/app/(platform)/projects/[id]/page.tsx
    apps/web/components/projects/batch-empty-state.tsx
  </files>
  <action>
**1) Install shadcn/ui Breadcrumb component:**

Run from `apps/web` directory:
```bash
cd apps/web && pnpm dlx shadcn@latest add breadcrumb
```

This adds `apps/web/components/ui/breadcrumb.tsx` with the Breadcrumb, BreadcrumbList, BreadcrumbItem, BreadcrumbLink, BreadcrumbSeparator, BreadcrumbPage components.

**2) Create `apps/web/components/projects/batch-empty-state.tsx`:**

A presentational component showing an illustrative empty state for when a project has no batches.

Structure:
- `"use client"` directive
- Container div centered with `flex flex-col items-center justify-center py-16 px-4`
- A decorative circle (dashed border, soft muted background): `div` with `rounded-full border-2 border-dashed border-muted-foreground/25 bg-muted/50 p-6 mb-6`
- Inside the circle: Lucide `FileSpreadsheet` icon, size 48, color `text-muted-foreground/50`
- Heading: `<h3>` with text "Nenhuma importacao ainda" styled `text-lg font-semibold text-foreground mt-2`
- Subtitle: `<p>` with text "Clique em \"Nova Importacao\" acima para enviar sua primeira planilha." styled `text-sm text-muted-foreground mt-1 text-center max-w-sm`
- NO button/CTA in the empty state (context decision: no duplicate triggers — directs user to the existing "Nova Importacao" button)

Export: `export function BatchEmptyState()`

Props: none (pure presentational).

**3) Create `apps/web/app/(platform)/projects/[id]/page.tsx`:**

This is a Next.js 15+ dynamic route page. CRITICAL: In Next.js 15+, `params` is a Promise and MUST be awaited.

Structure:

```typescript
"use client";

import { use } from "react";
```

Use `use()` from React to unwrap the params Promise in a client component. This avoids async component issues with client components.

```typescript
export default function ProjectDetailPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = use(params);
  // ... rest of component
}
```

Component behavior:

a) **Data fetching:**
   - Call `useProject(id)` to get project data (already exists in use-projects.ts)
   - Call `useBatches(id)` to get batch list for the project

b) **Loading state (skeleton):**
   When `project isLoading` is true, render skeleton placeholders:
   - Skeleton for breadcrumb area: a `Skeleton` with `h-4 w-48`
   - Skeleton for page title: a `Skeleton` with `h-8 w-64`
   - Skeleton for action button: a `Skeleton` with `h-9 w-40`
   - Use the Skeleton component from `@/components/ui/skeleton`

c) **Error state (project not found / generic API error):**
   When project query `isError` is true:
   - If the error is an `ApiError` with status 404: Show in-page "Projeto nao encontrado" with a link back to `/projects`. Use a centered layout with text + link.
   - For other errors: show toast notification with `toast.error("Erro ao carregar o projeto")`. Use `useEffect` to trigger the toast once when error is detected. Still render an in-page fallback ("Algo deu errado. Tente novamente.").

d) **Loaded state (main content):**

Layout structure (within `<main className="w-full">`):

1. **Breadcrumb navigation** — above the header:
   ```
   <div className="px-8 pt-4">
     <Breadcrumb>
       <BreadcrumbList>
         <BreadcrumbItem>
           <BreadcrumbLink href="/projects">Projetos</BreadcrumbLink>
         </BreadcrumbItem>
         <BreadcrumbSeparator />
         <BreadcrumbItem>
           <BreadcrumbPage>{project.name}</BreadcrumbPage>
         </BreadcrumbItem>
       </BreadcrumbList>
     </Breadcrumb>
   </div>
   ```

2. **AppHeader** — reuse `AppHeader` component with `title={project.name}`:
   - In the children slot (right side), render the "Nova Importacao" button:
     ```tsx
     <Button size="sm" disabled>
       <Upload className="mr-2 h-4 w-4" />
       Nova Importacao
     </Button>
     ```
   - Button is `disabled` because upload modal is Phase 14. The disabled state clearly signals it's not yet functional.
   - Use `Upload` icon from `lucide-react`.

3. **Content area** — below header:
   ```
   <div className="mx-auto max-w-5xl px-8 py-6">
     {/* Batch grid zone — will be populated in Phase 15 */}
     {/* For now, show empty state or loading */}
   </div>
   ```

   Inside content area:
   - If batches `isLoading`: show 6 skeleton cards in a grid (`grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4`). Each skeleton card: `Skeleton` with `h-32 rounded-lg`.
   - If batches loaded and `data.items.length === 0`: render `<BatchEmptyState />`
   - If batches loaded and items exist: render a placeholder `<p>` with text "{items.length} importacoes" (actual batch grid comes in Phase 15).

Import from:
- `@/components/layout/app-header` for AppHeader
- `@/components/ui/skeleton` for Skeleton
- `@/components/ui/button` for Button
- `@/components/ui/breadcrumb` for Breadcrumb components
- `@/components/projects/batch-empty-state` for BatchEmptyState
- `@/lib/query/hooks/use-projects` for useProject
- `@/lib/query/hooks/use-batches` for useBatches
- `@/lib/api/types` for ApiError (for 404 detection)
- `lucide-react` for Upload icon
- `sonner` for toast
- `react` for use, useEffect
  </action>
  <verify>
    Run `npx tsc --noEmit -p apps/web/tsconfig.json` — no type errors.
    Run `npm run dev --filter=@populatte/web` and navigate to `/projects/{any-project-id}` — page renders with breadcrumb, header, and appropriate state (loading/error/empty).
  </verify>
  <done>
    - /projects/[id] page renders project name in header with breadcrumb navigation
    - "Nova Importacao" button visible (disabled) in the header
    - Loading skeleton shown while data fetches
    - 404 error shows "Projeto nao encontrado" in-page
    - Empty state shows BatchEmptyState when no batches exist
    - Batch list placeholder shown when batches exist
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p apps/web/tsconfig.json` passes with zero errors
2. `npm run lint --filter=@populatte/web` passes with no new errors
3. Navigate to /projects — existing project list page still works (no regressions)
4. Navigate to /projects/{valid-id} — project detail page renders with project name, breadcrumb, disabled "Nova Importacao" button, and either skeleton loading, empty state, or batch count
5. Navigate to /projects/nonexistent-id — shows "Projeto nao encontrado" with link back
6. Verify in browser DevTools Network tab: batch list request fires for /projects/:id/batches on page load
7. Check that FormData bodies are NOT sent with Content-Type: application/json header (verify by inspecting createBatchEndpoints.upload in devtools or reading the code)
</verification>

<success_criteria>
- User can navigate to /projects/[id] and see the project name in a header with breadcrumb
- "Nova Importacao" button is visible and disabled in the header
- Batch API client supports FormData uploads (Content-Type not hardcoded for FormData)
- Zod schemas validate all 3 batch response shapes (list, detail, paginated rows) at runtime via safeParse
- All 4 React Query hooks are exported and available: useBatches, useBatch, useBatchRows, useUploadBatch
- useUploadBatch invalidates batch list cache on success
- Loading skeletons display while data loads
- Empty state shows when project has no batches
- 404 error shows in-page "Projeto nao encontrado"
</success_criteria>

<output>
After completion, create `.planning/phases/13-api-foundation-project-detail-page/13-01-SUMMARY.md`
</output>
