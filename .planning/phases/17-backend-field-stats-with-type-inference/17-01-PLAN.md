---
phase: 17-backend-field-stats-with-type-inference
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/entities/field-stats.entity.ts
  - apps/api/src/core/entities/index.ts
  - apps/api/src/core/services/type-inference.service.ts
  - apps/api/src/core/services/type-inference.service.spec.ts
autonomous: true

must_haves:
  truths:
    - "TypeInferenceService detects STRING from text values with 100% confidence"
    - "TypeInferenceService detects NUMBER from numeric values (including Brazilian currency) with >=80% confidence"
    - "TypeInferenceService detects DATE from Brazilian DD/MM/YYYY and ISO formats with >=80% confidence"
    - "TypeInferenceService detects BOOLEAN from strict keywords (true/false/sim/nao/s/n/0/1) with >=80% confidence"
    - "TypeInferenceService returns UNKNOWN with 0 confidence for all-empty samples"
    - "TypeInferenceService falls back to STRING when no type reaches 80% threshold"
    - "Brazilian CPF/CNPJ/CEP are classified as STRING, not NUMBER"
  artifacts:
    - path: "apps/api/src/core/entities/field-stats.entity.ts"
      provides: "InferredType enum (STRING, NUMBER, DATE, BOOLEAN, UNKNOWN), FieldStats interface, GetFieldStatsResult interface"
      exports: ["InferredType", "FieldStats", "GetFieldStatsResult"]
    - path: "apps/api/src/core/services/type-inference.service.ts"
      provides: "TypeInferenceService with inferType() and Brazilian format detection"
      exports: ["TypeInferenceService"]
    - path: "apps/api/src/core/services/type-inference.service.spec.ts"
      provides: "Unit tests for type inference covering all 5 types + edge cases"
  key_links:
    - from: "apps/api/src/core/services/type-inference.service.ts"
      to: "apps/api/src/core/entities/field-stats.entity.ts"
      via: "imports InferredType enum"
      pattern: "import.*InferredType.*field-stats"
---

<objective>
Create the TypeInferenceService with TDD and define the field stats entity types. The service uses a majority-wins heuristic (80% threshold) to detect STRING, NUMBER, DATE, BOOLEAN, or UNKNOWN from sample values. It must handle Brazilian locale formats (CPF, CNPJ, CEP as STRING; DD/MM/YYYY dates as DATE; R$ currency as NUMBER).

Purpose: Type inference is the core business logic for Phase 17. It lives in the use case layer per Clean Architecture and has zero infrastructure dependencies, making it a perfect TDD target.
Output: InferredType enum, FieldStats/GetFieldStatsResult interfaces, fully tested TypeInferenceService.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-backend-field-stats-with-type-inference/17-CONTEXT.md
@.planning/phases/17-backend-field-stats-with-type-inference/17-RESEARCH.md

@apps/api/src/core/entities/batch.entity.ts — ColumnMetadata interface (used in GetFieldStatsResult)
@apps/api/src/core/entities/row.entity.ts — Row entity (data: Record<string, unknown>)
@apps/api/src/core/entities/index.ts — barrel export to update
</context>

<feature>
  <name>TypeInferenceService with Brazilian locale support</name>
  <files>
    apps/api/src/core/entities/field-stats.entity.ts
    apps/api/src/core/entities/index.ts
    apps/api/src/core/services/type-inference.service.ts
    apps/api/src/core/services/type-inference.service.spec.ts
  </files>
  <behavior>
    TypeInferenceService.inferType(samples: unknown[]) returns { type: InferredType; confidence: number }

    ## Type Detection Rules (order matters):

    1. BOOLEAN — strict keyword set (case-insensitive): true, false, yes, no, sim, não, nao, 1, 0, s, n
    2. STRING (Brazilian IDs) — CPF: /^\d{3}\.?\d{3}\.?\d{3}-?\d{2}$/, CNPJ: /^\d{2}\.?\d{3}\.?\d{3}\/?\d{4}-?\d{2}$/, CEP: /^\d{5}-?\d{3}$/
    3. DATE (Brazilian) — DD/MM/YYYY or DD-MM-YYYY: /^\d{2}[/-]\d{2}[/-]\d{4}$/
    4. NUMBER (Brazilian currency) — R$ format: /^R\$\s?\d{1,3}(\.\d{3})*(,\d{2})?$/
    5. NUMBER — pure numeric via !isNaN(Number(str)) && str !== ''
    6. DATE — ISO or common formats via Date.parse (only if result is not NaN)
    7. STRING — default fallback

    ## Majority-Wins Heuristic:
    - Filter null, undefined, empty string from samples
    - If all filtered out: return { type: UNKNOWN, confidence: 0 }
    - Detect type for each non-empty sample
    - Count occurrences of each type
    - Find dominant type (highest count)
    - confidence = dominantCount / nonEmptyCount
    - If dominant type is NOT STRING and confidence < 0.8: return { type: STRING, confidence: 1.0 }
    - Otherwise: return { type: dominantType, confidence }

    ## Test Cases:

    ### STRING detection
    - ["hello", "world", "foo"] → { type: STRING, confidence: 1.0 }
    - ["abc", "def", "", null] → { type: STRING, confidence: 1.0 } (empty/null filtered)

    ### NUMBER detection
    - ["1", "2.5", "3", "-4", "5"] → { type: NUMBER, confidence: 1.0 }
    - ["R$ 1.234,56", "R$ 99,00", "R$ 0,50"] → { type: NUMBER, confidence: 1.0 }

    ### DATE detection
    - ["25/01/2026", "30/12/2025", "01/06/2024"] → { type: DATE, confidence: 1.0 }
    - ["2026-01-25", "2025-12-30"] → { type: DATE, confidence: 1.0 }

    ### BOOLEAN detection
    - ["sim", "nao", "sim", "sim"] → { type: BOOLEAN, confidence: 1.0 }
    - ["true", "false", "true"] → { type: BOOLEAN, confidence: 1.0 }
    - ["S", "N", "S", "N", "S"] → { type: BOOLEAN, confidence: 1.0 }
    - ["1", "0", "1", "0"] → { type: BOOLEAN, confidence: 1.0 }

    ### UNKNOWN detection
    - [] → { type: UNKNOWN, confidence: 0 }
    - [null, "", undefined] → { type: UNKNOWN, confidence: 0 }

    ### Brazilian format classification
    - ["123.456.789-01", "987.654.321-00"] → { type: STRING, confidence: 1.0 } (CPF)
    - ["12.345.678/0001-90", "98.765.432/0001-01"] → { type: STRING, confidence: 1.0 } (CNPJ)
    - ["01234-567", "98765-432"] → { type: STRING, confidence: 1.0 } (CEP)

    ### Mixed type / threshold
    - ["hello", "1", "2", "3", "4"] → 80% NUMBER → { type: NUMBER, confidence: 0.8 }
    - ["hello", "world", "1", "2", "3"] → 60% NUMBER → falls below 80% → { type: STRING, confidence: 1.0 }

    ## Entity Types to Create:

    ```typescript
    // field-stats.entity.ts
    export enum InferredType {
      STRING = 'STRING',
      NUMBER = 'NUMBER',
      DATE = 'DATE',
      BOOLEAN = 'BOOLEAN',
      UNKNOWN = 'UNKNOWN',
    }

    export interface TypeInference {
      type: InferredType;
      confidence: number;
    }

    export interface FieldStats {
      fieldName: string;
      presenceCount: number;
      uniqueCount: number;
      inferredType: InferredType;
      confidence: number;
      sampleValues: unknown[];
    }

    export interface GetFieldStatsResult {
      totalRows: number;
      fields: FieldStats[];
    }
    ```
  </behavior>
  <implementation>
    1. Create `apps/api/src/core/entities/field-stats.entity.ts` with InferredType enum, TypeInference, FieldStats, and GetFieldStatsResult interfaces
    2. Update `apps/api/src/core/entities/index.ts` to export from field-stats.entity
    3. Create `apps/api/src/core/services/` directory (new — does not exist yet)
    4. Create `apps/api/src/core/services/type-inference.service.ts` — NestJS @Injectable() class with:
       - `public inferType(samples: unknown[]): TypeInference` — main method
       - `private detectSingleType(value: unknown): InferredType` — per-value detection
       - Private static regex patterns for Brazilian formats
       - Private static BOOLEAN_VALUES Set
    5. Create `apps/api/src/core/services/type-inference.service.spec.ts` — Jest tests covering all cases above

    Follow TDD: Write test file first (RED), then implement service (GREEN), then refactor if needed.

    IMPORTANT: TypeInferenceService is @Injectable() but has zero constructor dependencies. It lives in core/services (not infrastructure) because it contains pure business logic with no external deps.

    IMPORTANT: Do NOT use `Date.parse` on strings that look like DD/MM/YYYY — detect Brazilian date pattern BEFORE the ISO date check to prevent `Date.parse("01/02/2026")` being interpreted as MM/DD/YYYY (American format). The regex check must come first.
  </implementation>
</feature>

<verification>
```bash
cd apps/api && npm run test -- --testPathPattern="type-inference" --verbose
```
All test cases pass. No lint errors in new files.
```bash
cd apps/api && npx tsc --noEmit
```
TypeScript compilation succeeds with strict mode.
</verification>

<success_criteria>
- TypeInferenceService passes all test cases listed in behavior section
- InferredType enum has exactly 5 values: STRING, NUMBER, DATE, BOOLEAN, UNKNOWN
- FieldStats and GetFieldStatsResult interfaces exported from entities barrel
- Brazilian formats (CPF, CNPJ, CEP) correctly classified as STRING
- Brazilian dates (DD/MM/YYYY) classified as DATE, not misinterpreted as American MM/DD/YYYY
- Empty/null samples return UNKNOWN with 0 confidence
- Mixed types below 80% threshold fall back to STRING with 1.0 confidence
</success_criteria>

<output>
After completion, create `.planning/phases/17-backend-field-stats-with-type-inference/17-01-SUMMARY.md`
</output>
