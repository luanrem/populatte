---
phase: 17-backend-field-stats-with-type-inference
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - apps/api/src/core/repositories/row.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
  - apps/api/src/core/repositories/batch.repository.ts
  - apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts
  - apps/api/src/core/use-cases/batch/index.ts
  - apps/api/src/presentation/controllers/batch.controller.ts
  - apps/api/src/infrastructure/batch/batch.module.ts
autonomous: true

must_haves:
  truths:
    - "GET /projects/:projectId/batches/:batchId/field-stats returns per-field stats with presence count, unique count, inferred type, confidence, and sample values"
    - "Field stats endpoint validates project ownership with 404/403 separation"
    - "Field stats endpoint applies soft-delete filtering and defense-in-depth (batch.projectId === projectId)"
    - "Aggregation uses single CTE query (not N+1 per-field queries)"
    - "Type inference uses first 100 rows, presence/unique counts use ALL rows"
    - "Zero-row batches return fields from columnMetadata with zero stats and UNKNOWN type"
    - "Empty strings are not counted toward presence"
    - "Response includes totalRows at top level"
  artifacts:
    - path: "apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts"
      provides: "GetFieldStatsUseCase orchestrating ownership validation + aggregation + type inference"
      exports: ["GetFieldStatsUseCase"]
    - path: "apps/api/src/core/repositories/batch.repository.ts"
      provides: "getFieldAggregations abstract method"
      contains: "getFieldAggregations"
    - path: "apps/api/src/core/repositories/row.repository.ts"
      provides: "getSampleRows abstract method"
      contains: "getSampleRows"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts"
      provides: "CTE-based JSONB aggregation query implementation"
      contains: "jsonb_object_keys"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts"
      provides: "getSampleRows implementation with limit and deterministic sort"
    - path: "apps/api/src/presentation/controllers/batch.controller.ts"
      provides: "GET :batchId/field-stats endpoint"
      contains: "getFieldStats"
    - path: "apps/api/src/infrastructure/batch/batch.module.ts"
      provides: "GetFieldStatsUseCase and TypeInferenceService registered as providers"
  key_links:
    - from: "apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts"
      to: "apps/api/src/core/services/type-inference.service.ts"
      via: "constructor injection"
      pattern: "TypeInferenceService"
    - from: "apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts"
      to: "apps/api/src/core/repositories/batch.repository.ts"
      via: "getFieldAggregations call"
      pattern: "getFieldAggregations"
    - from: "apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts"
      to: "apps/api/src/core/repositories/row.repository.ts"
      via: "getSampleRows call"
      pattern: "getSampleRows"
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts"
      via: "constructor injection + execute call"
      pattern: "getFieldStatsUseCase\\.execute"
---

<objective>
Wire the field stats endpoint end-to-end: add repository methods for JSONB aggregation and sample rows, create the GetFieldStatsUseCase that orchestrates ownership validation + aggregation + type inference, add the GET endpoint to the controller, and register everything in the NestJS module.

Purpose: This delivers the complete backend API for field-level analytics that the frontend (Phase 19) will consume.
Output: Working GET /projects/:projectId/batches/:batchId/field-stats endpoint returning `{ totalRows, fields: FieldStats[] }`.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-backend-field-stats-with-type-inference/17-CONTEXT.md
@.planning/phases/17-backend-field-stats-with-type-inference/17-RESEARCH.md
@.planning/phases/17-backend-field-stats-with-type-inference/17-01-SUMMARY.md

@apps/api/src/core/use-cases/batch/get-batch.use-case.ts — ownership validation pattern to replicate
@apps/api/src/core/repositories/batch.repository.ts — add getFieldAggregations method
@apps/api/src/core/repositories/row.repository.ts — add getSampleRows method
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts — CTE query implementation
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts — sample rows implementation
@apps/api/src/infrastructure/database/drizzle/schema/ingestion-rows.schema.ts — table name and columns
@apps/api/src/presentation/controllers/batch.controller.ts — add endpoint
@apps/api/src/infrastructure/batch/batch.module.ts — register providers
@apps/api/src/core/entities/batch.entity.ts — ColumnMetadata, Batch interface
@apps/api/src/core/entities/row.entity.ts — Row interface with data field
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add repository abstract methods and Drizzle implementations</name>
  <files>
    apps/api/src/core/repositories/batch.repository.ts
    apps/api/src/core/repositories/row.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
  </files>
  <action>
    **1. Define FieldAggregation interface** in batch.repository.ts (above the class):
    ```typescript
    export interface FieldAggregation {
      fieldName: string;
      presenceCount: number;
      uniqueCount: number;
    }
    ```

    **2. Add abstract method to BatchRepository** in batch.repository.ts:
    ```typescript
    public abstract getFieldAggregations(batchId: string): Promise<FieldAggregation[]>;
    ```

    **3. Add abstract method to RowRepository** in row.repository.ts:
    ```typescript
    public abstract getSampleRows(batchId: string, limit: number): Promise<Row[]>;
    ```

    **4. Implement getFieldAggregations in DrizzleBatchRepository** — Use a single CTE-based query:
    - Import `sql` from `drizzle-orm`
    - Import `FieldAggregation` from core repository
    - The CTE extracts distinct keys from `jsonb_object_keys(data)` across all non-deleted rows for the batch
    - Main query joins field_keys with ingestion_rows to compute:
      - `presence_count`: COUNT of rows where `data->>field IS NOT NULL AND data->>field != ''`
      - `unique_count`: COUNT DISTINCT of `data->>field` FILTER (WHERE not null and not empty)
    - Parse the raw SQL result: field names come as strings, counts come as strings from PostgreSQL — cast to number
    - Return as `FieldAggregation[]`

    SQL template (use Drizzle `sql` tag for parameter safety):
    ```sql
    WITH field_keys AS (
      SELECT DISTINCT jsonb_object_keys(data) AS key
      FROM ingestion_rows
      WHERE batch_id = ${batchId} AND deleted_at IS NULL
    )
    SELECT
      fk.key AS field_name,
      COUNT(CASE WHEN ir.data->>fk.key IS NOT NULL AND ir.data->>fk.key != '' THEN 1 END)::integer AS presence_count,
      COUNT(DISTINCT ir.data->>fk.key) FILTER (WHERE ir.data->>fk.key IS NOT NULL AND ir.data->>fk.key != '')::integer AS unique_count
    FROM field_keys fk
    LEFT JOIN ingestion_rows ir ON ir.batch_id = ${batchId} AND ir.deleted_at IS NULL
    GROUP BY fk.key
    ```

    Map raw result rows to FieldAggregation objects with Number() casts on counts.

    **5. Implement getSampleRows in DrizzleRowRepository**:
    - Query ingestion_rows WHERE batchId matches AND deletedAt IS NULL
    - ORDER BY sourceRowIndex ASC, id ASC (deterministic, matches data table sort)
    - LIMIT by the provided limit parameter
    - Map results through RowMapper.toDomain
    - This is similar to the existing `findByBatchId` but with a LIMIT and explicit ORDER BY

    IMPORTANT: Use `this.drizzle.getClient().execute(sql`...`)` for the CTE query in batch repository. The Drizzle query builder does not support CTEs with `jsonb_object_keys()`. The result rows need to be typed/cast manually.
  </action>
  <verify>
    ```bash
    cd apps/api && npx tsc --noEmit
    ```
    TypeScript compiles without errors. Both abstract methods implemented in Drizzle repositories.
  </verify>
  <done>
    - BatchRepository has `getFieldAggregations(batchId)` returning `FieldAggregation[]`
    - RowRepository has `getSampleRows(batchId, limit)` returning `Row[]`
    - DrizzleBatchRepository implements CTE-based single aggregation query
    - DrizzleRowRepository implements sample rows with deterministic sort + limit
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GetFieldStatsUseCase and wire endpoint</name>
  <files>
    apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts
    apps/api/src/core/use-cases/batch/index.ts
    apps/api/src/presentation/controllers/batch.controller.ts
    apps/api/src/infrastructure/batch/batch.module.ts
  </files>
  <action>
    **1. Create GetFieldStatsUseCase** at `apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts`:

    Follow the EXACT same ownership validation pattern from GetBatchUseCase (steps 1-5):
    - Step 1: `projectRepository.findByIdOnly(projectId)` — 404 if not found
    - Step 2: Check `project.deletedAt` — 404 if archived
    - Step 3: Check `project.userId !== userId` — 403 with security log (`this.logger.warn(...)`)
    - Step 4: `batchRepository.findById(batchId)` — 404 if not found
    - Step 5: Defense-in-depth `batch.projectId !== projectId` — 404

    After validation:
    - Step 6: `rowRepository.countByBatchId(batchId)` for totalRows
    - Step 7: Zero-row edge case: if totalRows === 0, return `{ totalRows: 0, fields: batch.columnMetadata.map(col => ({ fieldName: col.normalizedKey, presenceCount: 0, uniqueCount: 0, inferredType: InferredType.UNKNOWN, confidence: 0, sampleValues: [] })) }`
    - Step 8: `batchRepository.getFieldAggregations(batchId)` for presence/unique counts
    - Step 9: `rowRepository.getSampleRows(batchId, 100)` for type inference samples
    - Step 10: For each aggregation field, extract samples from rows, infer type via `typeInferenceService.inferType(samples)`, extract first 3 distinct non-empty values as sampleValues
    - Return `GetFieldStatsResult` with totalRows and fields array

    Constructor dependencies: ProjectRepository, BatchRepository, RowRepository, TypeInferenceService. All @Injectable().

    **2. Export from barrel** — Add `export * from './get-field-stats.use-case';` to `apps/api/src/core/use-cases/batch/index.ts`

    **3. Add endpoint to BatchController**:
    - Import GetFieldStatsUseCase
    - Add to constructor: `private readonly getFieldStatsUseCase: GetFieldStatsUseCase`
    - Add endpoint AFTER `:batchId/rows` route (route ordering matters):
      ```typescript
      @Get(':batchId/field-stats')
      public async getFieldStats(
        @Param('projectId') projectId: string,
        @Param('batchId') batchId: string,
        @CurrentUser() user: User,
      ) {
        return this.getFieldStatsUseCase.execute(projectId, batchId, user.id);
      }
      ```
    - IMPORTANT: Place `@Get(':batchId/field-stats')` BEFORE `@Get(':batchId')` in the controller to prevent NestJS treating "field-stats" as a batchId parameter. The route ordering should be: `@Get()` → `@Get(':batchId')` → `@Get(':batchId/rows')` → `@Get(':batchId/field-stats')`. Actually, since `field-stats` is a literal segment after `:batchId`, NestJS handles this correctly because it's `/:batchId/field-stats` not `/:batchId`. But to be safe, place the `field-stats` route near the `rows` route (both are sub-routes of `:batchId`).

    **4. Register in BatchModule**:
    - Import GetFieldStatsUseCase from use-cases barrel
    - Import TypeInferenceService from `../../core/services/type-inference.service`
    - Add both to providers array: `[..., GetFieldStatsUseCase, TypeInferenceService]`
  </action>
  <verify>
    ```bash
    cd apps/api && npx tsc --noEmit
    ```
    TypeScript compiles without errors.

    ```bash
    cd apps/api && npm run lint
    ```
    No new lint errors in modified files.

    Start the API and verify the endpoint exists:
    ```bash
    cd apps/api && npm run build
    ```
    Build succeeds, confirming all imports resolve and module wiring is correct.
  </verify>
  <done>
    - GetFieldStatsUseCase exists with full ownership validation (404/403 separation)
    - GetFieldStatsUseCase applies defense-in-depth (batch.projectId === projectId)
    - GetFieldStatsUseCase handles zero-row batch edge case
    - GetFieldStatsUseCase orchestrates aggregation + sampling + type inference
    - GET /projects/:projectId/batches/:batchId/field-stats endpoint registered
    - TypeInferenceService and GetFieldStatsUseCase registered in BatchModule
    - Response shape: { totalRows: number, fields: FieldStats[] }
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `cd apps/api && npx tsc --noEmit`
2. Lint passes: `cd apps/api && npm run lint`
3. Build succeeds: `cd apps/api && npm run build`
4. All existing tests pass: `cd apps/api && npm run test`
5. Type inference tests pass: `cd apps/api && npm run test -- --testPathPattern="type-inference"`
</verification>

<success_criteria>
- GET /projects/:projectId/batches/:batchId/field-stats endpoint exists and compiles
- Ownership validation follows established 404/403 pattern with security logging
- Defense-in-depth: batch.projectId === projectId check present
- Soft-delete filtering applied (deletedAt IS NULL in all queries)
- Single CTE aggregation query (no N+1 per field)
- Type inference uses first 100 rows (deterministic sample)
- Presence/unique counts use ALL rows (exact, not approximate)
- Empty strings not counted toward presence (filtered in SQL)
- Zero-row batches return fields from columnMetadata with zero stats
- Response includes totalRows at top level for frontend percentage calculation
- 3 sample distinct values per field for card preview
</success_criteria>

<output>
After completion, create `.planning/phases/17-backend-field-stats-with-type-inference/17-02-SUMMARY.md`
</output>
