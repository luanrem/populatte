---
phase: 18-backend-field-values-endpoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/entities/field-values.entity.ts
  - apps/api/src/core/entities/index.ts
  - apps/api/src/core/repositories/batch.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
  - apps/api/src/core/use-cases/batch/get-field-values.use-case.ts
  - apps/api/src/core/use-cases/batch/index.ts
  - apps/api/src/presentation/dto/batch.dto.ts
  - apps/api/src/presentation/controllers/batch.controller.ts
  - apps/api/src/infrastructure/batch/batch.module.ts
autonomous: true

must_haves:
  truths:
    - "GET /projects/:projectId/batches/:batchId/fields/:fieldKey/values returns paginated distinct values for a field"
    - "Response includes matching count (filtered by search) AND total distinct count for the field"
    - "Pagination works with limit/offset query params (default 50/0)"
    - "Search query param filters values case-insensitively via ILIKE contains match"
    - "404 returned when fieldKey does not exist in batch columnMetadata"
    - "Ownership validation follows 404/403 separation pattern with defense-in-depth"
    - "Null and empty string values are excluded from results"
    - "Values are sorted alphabetically (A to Z)"
  artifacts:
    - path: "apps/api/src/core/entities/field-values.entity.ts"
      provides: "FieldValuesResult and FieldValuesQuery interfaces"
      contains: "FieldValuesResult"
    - path: "apps/api/src/core/use-cases/batch/get-field-values.use-case.ts"
      provides: "Ownership-validated use case with field key existence check"
      exports: ["GetFieldValuesUseCase"]
    - path: "apps/api/src/core/repositories/batch.repository.ts"
      provides: "Abstract getFieldValues method"
      contains: "getFieldValues"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts"
      provides: "SQL implementation with ILIKE search and pagination"
      contains: "getFieldValues"
    - path: "apps/api/src/presentation/dto/batch.dto.ts"
      provides: "fieldValuesQuerySchema with search/limit/offset validation"
      contains: "fieldValuesQuerySchema"
  key_links:
    - from: "apps/api/src/presentation/controllers/batch.controller.ts"
      to: "apps/api/src/core/use-cases/batch/get-field-values.use-case.ts"
      via: "constructor injection and endpoint delegation"
      pattern: "getFieldValuesUseCase\\.execute"
    - from: "apps/api/src/core/use-cases/batch/get-field-values.use-case.ts"
      to: "apps/api/src/core/repositories/batch.repository.ts"
      via: "abstract repository method call"
      pattern: "batchRepository\\.getFieldValues"
    - from: "apps/api/src/infrastructure/batch/batch.module.ts"
      to: "apps/api/src/core/use-cases/batch/get-field-values.use-case.ts"
      via: "NestJS provider registration"
      pattern: "GetFieldValuesUseCase"
---

<objective>
Paginated distinct values endpoint for a specific field within a batch.

Purpose: Enable on-demand value exploration for individual Excel columns. Phase 20's side sheet UI will consume this endpoint to display all values for a selected field with search and pagination.

Output: Complete vertical slice — entity types, abstract repository method, Drizzle SQL implementation, use case with ownership validation, Zod DTO, controller endpoint, and module wiring.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-backend-field-values-endpoint/18-CONTEXT.md

# Key reference files (follow these patterns exactly)
@apps/api/src/core/use-cases/batch/get-field-stats.use-case.ts — ownership validation pattern (Steps 1-5)
@apps/api/src/core/repositories/batch.repository.ts — abstract repository with FieldAggregation pattern
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts — CTE SQL pattern
@apps/api/src/presentation/controllers/batch.controller.ts — endpoint registration pattern
@apps/api/src/presentation/dto/batch.dto.ts — Zod schema pattern (paginationQuerySchema)
@apps/api/src/infrastructure/batch/batch.module.ts — provider wiring
@apps/api/src/core/entities/field-stats.entity.ts — entity interface pattern
@apps/api/src/core/entities/batch.entity.ts — ColumnMetadata interface (for field key validation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Entity, repository interface, and Drizzle SQL implementation</name>
  <files>
    apps/api/src/core/entities/field-values.entity.ts
    apps/api/src/core/entities/index.ts
    apps/api/src/core/repositories/batch.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts
  </files>
  <action>
    **1. Create field-values entity** (`apps/api/src/core/entities/field-values.entity.ts`):

    Define two interfaces:

    ```typescript
    export interface FieldValuesQuery {
      batchId: string;
      fieldKey: string;
      limit: number;
      offset: number;
      search?: string;
    }

    export interface FieldValuesResult {
      values: string[];
      matchingCount: number;
      totalDistinctCount: number;
    }
    ```

    - `values`: The paginated slice of distinct values for this page
    - `matchingCount`: Total distinct values matching the search filter (for pagination math). When no search, equals totalDistinctCount.
    - `totalDistinctCount`: Total distinct values for this field regardless of search (enables "showing X of Y matches (Z total)" in UI)

    **2. Export from barrel** (`apps/api/src/core/entities/index.ts`):
    Add `export * from './field-values.entity';`

    **3. Add abstract method to BatchRepository** (`apps/api/src/core/repositories/batch.repository.ts`):

    Add import for `FieldValuesQuery` and `FieldValuesResult` from `../entities/field-values.entity`.
    Add abstract method:

    ```typescript
    /**
     * Returns paginated distinct values for a specific field key.
     * Caller MUST verify batch ownership and field key existence before calling.
     */
    public abstract getFieldValues(
      query: FieldValuesQuery,
    ): Promise<FieldValuesResult>;
    ```

    **4. Implement in DrizzleBatchRepository** (`apps/api/src/infrastructure/database/drizzle/repositories/drizzle-batch.repository.ts`):

    Add import for `FieldValuesQuery` and `FieldValuesResult`.

    Implement `getFieldValues` using raw SQL (same pattern as `getFieldAggregations`). The query needs:

    **SQL approach** — Two queries in Promise.all for optimal performance:

    Query 1 (values + matchingCount): Use a CTE to extract distinct non-empty values for the field key, optionally filter by ILIKE search, count total matches, then paginate with LIMIT/OFFSET and ORDER BY value ASC.

    Query 2 (totalDistinctCount): Count all distinct non-empty values for the field key (no search filter).

    When `search` is provided, Query 1 adds `WHERE value ILIKE '%' || search || '%'` (use parameterized `${query.search}` to prevent SQL injection — the `sql` template tag handles escaping).

    When no `search`, skip the ILIKE filter and `matchingCount` equals `totalDistinctCount`.

    **Concrete SQL for Query 1:**
    ```sql
    WITH field_values AS (
      SELECT DISTINCT data->>'{fieldKey}' AS value
      FROM ingestion_rows
      WHERE batch_id = {batchId}
        AND deleted_at IS NULL
        AND data->>'{fieldKey}' IS NOT NULL
        AND data->>'{fieldKey}' != ''
    )
    SELECT value, COUNT(*) OVER() AS matching_count
    FROM field_values
    WHERE value ILIKE '%' || {search} || '%'  -- only if search provided
    ORDER BY value ASC
    LIMIT {limit} OFFSET {offset}
    ```

    **Concrete SQL for Query 2:**
    ```sql
    SELECT COUNT(DISTINCT data->>'{fieldKey}')::integer AS total_count
    FROM ingestion_rows
    WHERE batch_id = {batchId}
      AND deleted_at IS NULL
      AND data->>'{fieldKey}' IS NOT NULL
      AND data->>'{fieldKey}' != ''
    ```

    Use `Promise.all` to run both queries in parallel. Parse results:
    - `values`: Map rows to string array
    - `matchingCount`: From `matching_count` window function in first row (or 0 if no rows)
    - `totalDistinctCount`: From Query 2's `total_count`

    **Important:** Use Drizzle's `sql` tagged template for parameterization (same as `getFieldAggregations`). The field key must be safely interpolated as a string parameter, not concatenated.
  </action>
  <verify>
    Run `npm run type-check --filter=@populatte/api` — no TypeScript errors.
    Verify entity file exports `FieldValuesQuery` and `FieldValuesResult`.
    Verify `BatchRepository` has the new abstract method.
    Verify `DrizzleBatchRepository` compiles with the implementation.
  </verify>
  <done>
    `FieldValuesQuery` and `FieldValuesResult` interfaces defined. `BatchRepository` abstract class has `getFieldValues` method. `DrizzleBatchRepository` implements it with CTE-based SQL, ILIKE search, alphabetical sort, and pagination. Both queries run in parallel via Promise.all.
  </done>
</task>

<task type="auto">
  <name>Task 2: Use case, DTO, controller endpoint, and module wiring</name>
  <files>
    apps/api/src/core/use-cases/batch/get-field-values.use-case.ts
    apps/api/src/core/use-cases/batch/index.ts
    apps/api/src/presentation/dto/batch.dto.ts
    apps/api/src/presentation/controllers/batch.controller.ts
    apps/api/src/infrastructure/batch/batch.module.ts
  </files>
  <action>
    **1. Create GetFieldValuesUseCase** (`apps/api/src/core/use-cases/batch/get-field-values.use-case.ts`):

    Follow `GetFieldStatsUseCase` pattern exactly for ownership validation (Steps 1-5):
    - Inject `ProjectRepository`, `BatchRepository`
    - Step 1: `findByIdOnly(projectId)` — 404 if not found
    - Step 2: Check `project.deletedAt` — 404 if soft-deleted
    - Step 3: Check `project.userId !== userId` — log warn + 403 ForbiddenException
    - Step 4: `findById(batchId)` — 404 if not found
    - Step 5: Defense-in-depth `batch.projectId !== projectId` — 404

    **After ownership validation, add field key existence check:**
    - Step 6: Check if `fieldKey` exists in `batch.columnMetadata` by matching against `normalizedKey`. Use `batch.columnMetadata.some(col => col.normalizedKey === fieldKey)`.
    - If not found: throw `NotFoundException('Field not found in batch')`.

    **Then delegate to repository:**
    - Step 7: Call `this.batchRepository.getFieldValues({ batchId, fieldKey, limit, offset, search })` and return the result.

    Method signature:
    ```typescript
    public async execute(
      projectId: string,
      batchId: string,
      fieldKey: string,
      userId: string,
      limit: number,
      offset: number,
      search?: string,
    ): Promise<FieldValuesResult>
    ```

    **2. Export from barrel** (`apps/api/src/core/use-cases/batch/index.ts`):
    Add `export * from './get-field-values.use-case';`

    **3. Add field values query DTO** (`apps/api/src/presentation/dto/batch.dto.ts`):

    Add a new Zod schema below the existing `paginationQuerySchema`:

    ```typescript
    export const fieldValuesQuerySchema = z.object({
      limit: z.coerce.number().int().min(1).max(100).default(50),
      offset: z.coerce.number().int().min(0).default(0),
      search: z.string().max(200).optional(),
    });

    export type FieldValuesQueryDto = z.infer<typeof fieldValuesQuerySchema>;
    ```

    The `search` field is optional. Max length 200 to prevent abuse. Limit/offset follow same constraints as existing `paginationQuerySchema`.

    **4. Add controller endpoint** (`apps/api/src/presentation/controllers/batch.controller.ts`):

    - Import `GetFieldValuesUseCase` from the batch use cases barrel
    - Import `fieldValuesQuerySchema` and `FieldValuesQueryDto` from batch DTO
    - Add `GetFieldValuesUseCase` to constructor injection
    - Add endpoint:

    ```typescript
    @Get(':batchId/fields/:fieldKey/values')
    public async getFieldValues(
      @Param('projectId') projectId: string,
      @Param('batchId') batchId: string,
      @Param('fieldKey') fieldKey: string,
      @Query(new ZodValidationPipe(fieldValuesQuerySchema))
      query: FieldValuesQueryDto,
      @CurrentUser() user: User,
    ) {
      return this.getFieldValuesUseCase.execute(
        projectId,
        batchId,
        decodeURIComponent(fieldKey),
        user.id,
        query.limit,
        query.offset,
        query.search,
      );
    }
    ```

    **Important:** Apply `decodeURIComponent(fieldKey)` to handle URL-encoded field keys (e.g., `Nome%20Completo` -> `Nome Completo`). NestJS may partially decode, but explicit decode ensures correctness for special characters.

    **5. Wire in BatchModule** (`apps/api/src/infrastructure/batch/batch.module.ts`):
    - Import `GetFieldValuesUseCase` from use cases barrel
    - Add `GetFieldValuesUseCase` to the `providers` array
  </action>
  <verify>
    Run `npm run type-check --filter=@populatte/api` — no TypeScript errors.
    Run `npm run lint --filter=@populatte/api` — no lint errors.
    Run `npm run build --filter=@populatte/api` — build succeeds.
    Verify the controller has the new endpoint registered at `:batchId/fields/:fieldKey/values`.
    Verify `BatchModule` providers include `GetFieldValuesUseCase`.
  </verify>
  <done>
    `GetFieldValuesUseCase` validates ownership (404/403 separation), checks field key existence in columnMetadata (404 if missing), and delegates to repository. Zod schema validates limit/offset/search query params. Controller endpoint accepts URL-encoded field key and passes decoded value to use case. Module wiring connects all providers.
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check --filter=@populatte/api` — no TypeScript errors
2. `npm run lint --filter=@populatte/api` — no lint errors
3. `npm run build --filter=@populatte/api` — build succeeds
4. `npm run test --filter=@populatte/api` — existing tests still pass
5. Start dev server and test with curl:
   - `curl GET /projects/{projectId}/batches/{batchId}/fields/{fieldKey}/values` returns paginated values
   - `curl GET .../values?search=test` returns filtered values
   - `curl GET .../values?limit=10&offset=5` returns correct page
   - Invalid fieldKey returns 404
   - Wrong project ownership returns 403
</verification>

<success_criteria>
- GET endpoint returns distinct field values with pagination
- Search filters values case-insensitively
- Response includes both matchingCount and totalDistinctCount
- 404 for nonexistent field key, project, or batch
- 403 for wrong ownership
- Null/empty values excluded
- Values sorted alphabetically
- Build, lint, and type-check all pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-backend-field-values-endpoint/18-01-SUMMARY.md`
</output>
