---
phase: 20-view-values-side-sheet
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/api/schemas/field-values.schema.ts
  - apps/web/lib/api/endpoints/batches.ts
  - apps/web/lib/query/hooks/use-batches.ts
  - apps/web/hooks/use-debounce.ts

autonomous: true

must_haves:
  truths:
    - "Field values API response is validated at runtime with Zod before reaching components"
    - "useFieldValuesInfinite hook returns paginated data with hasNextPage and fetchNextPage for infinite scroll"
    - "Debounced search value updates only after 300ms of typing inactivity"
  artifacts:
    - path: "apps/web/lib/api/schemas/field-values.schema.ts"
      provides: "Zod schema and TypeScript type for field values API response"
      exports: ["fieldValuesResponseSchema", "FieldValuesResponse"]
    - path: "apps/web/lib/api/endpoints/batches.ts"
      provides: "getFieldValues endpoint method with safeParse validation"
      contains: "getFieldValues"
    - path: "apps/web/lib/query/hooks/use-batches.ts"
      provides: "useFieldValuesInfinite hook with useInfiniteQuery"
      exports: ["useFieldValuesInfinite"]
    - path: "apps/web/hooks/use-debounce.ts"
      provides: "Generic useDebounce hook"
      exports: ["useDebounce"]
  key_links:
    - from: "apps/web/lib/api/endpoints/batches.ts"
      to: "/projects/:projectId/batches/:batchId/fields/:fieldKey/values"
      via: "fetchFn with query params (limit, offset, search)"
      pattern: "fields.*fieldKey.*values"
    - from: "apps/web/lib/query/hooks/use-batches.ts"
      to: "apps/web/lib/api/endpoints/batches.ts"
      via: "useInfiniteQuery calling endpoints.getFieldValues"
      pattern: "useInfiniteQuery"
---

<objective>
Create the data fetching layer for field values: Zod schema, API endpoint method, infinite query hook, and debounce utility.

Purpose: Establish the data pipeline from backend field values endpoint to React components, enabling infinite scroll pagination and debounced search.
Output: Four files — Zod schema, updated batches endpoint, updated hooks file, and new useDebounce hook.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@apps/web/lib/api/schemas/field-stats.schema.ts
@apps/web/lib/api/endpoints/batches.ts
@apps/web/lib/query/hooks/use-batches.ts

# Backend entity this must match
@apps/api/src/core/entities/field-values.entity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create field values Zod schema and API endpoint method</name>
  <files>
    apps/web/lib/api/schemas/field-values.schema.ts
    apps/web/lib/api/endpoints/batches.ts
  </files>
  <action>
    1. Create `apps/web/lib/api/schemas/field-values.schema.ts`:
       - Define `fieldValuesResponseSchema` as z.object matching backend `FieldValuesResult` entity:
         - `values`: z.array(z.string())
         - `matchingCount`: z.number()
         - `totalDistinctCount`: z.number()
       - Export type `FieldValuesResponse` inferred from schema
       - Follow exact pattern from `field-stats.schema.ts`

    2. Add `getFieldValues` method to `createBatchEndpoints` in `apps/web/lib/api/endpoints/batches.ts`:
       - Signature: `async getFieldValues(projectId: string, batchId: string, fieldKey: string, params: { limit: number; offset: number; search?: string }): Promise<FieldValuesResponse>`
       - URL: `/projects/${projectId}/batches/${batchId}/fields/${encodeURIComponent(fieldKey)}/values?limit=${params.limit}&offset=${params.offset}`
       - Append `&search=${encodeURIComponent(params.search)}` only if `params.search` is truthy
       - Use `fieldValuesResponseSchema.safeParse(data)` for runtime validation
       - Log error with `[API] Field values response validation failed:` on parse failure
       - Import `fieldValuesResponseSchema` and `FieldValuesResponse` type from the new schema file
       - Follow exact same pattern as `getFieldStats` method

    Important: `fieldKey` must be URI-encoded with `encodeURIComponent` because field names can contain spaces and special characters from Excel columns.
  </action>
  <verify>
    Run `cd apps/web && npx tsc --noEmit` — no type errors.
    Verify the schema file exports `fieldValuesResponseSchema` and `FieldValuesResponse`.
    Verify `batches.ts` imports and uses the new schema.
  </verify>
  <done>
    `field-values.schema.ts` exists with Zod schema matching backend FieldValuesResult.
    `batches.ts` has `getFieldValues` method with safeParse validation and URI-encoded fieldKey.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useDebounce hook and useFieldValuesInfinite hook</name>
  <files>
    apps/web/hooks/use-debounce.ts
    apps/web/lib/query/hooks/use-batches.ts
  </files>
  <action>
    1. Create `apps/web/hooks/use-debounce.ts`:
       - Generic hook: `export function useDebounce<T>(value: T, delay: number): T`
       - Uses useState to hold debouncedValue, initialized to value
       - Uses useEffect with setTimeout that sets debouncedValue after delay ms
       - Cleanup function clears timeout on re-render
       - Dependencies: [value, delay]
       - No 'use client' directive needed (hooks directory doesn't use it based on existing use-mobile.ts pattern — check first)

    2. Add `useFieldValuesInfinite` to `apps/web/lib/query/hooks/use-batches.ts`:
       - Import `useInfiniteQuery` from '@tanstack/react-query' (add to existing import)
       - Import `FieldValuesResponse` type from field-values schema
       - Signature: `export function useFieldValuesInfinite(projectId: string, batchId: string, fieldKey: string, search?: string)`
       - Uses `useApiClient` and `createBatchEndpoints` (same pattern as other hooks in file)
       - queryKey: `['projects', projectId, 'batches', batchId, 'field-values', fieldKey, { search }]`
       - queryFn receives `{ pageParam }` (default 0), calls `endpoints.getFieldValues(projectId, batchId, fieldKey, { limit: 50, offset: pageParam, search: search || undefined })`
       - `initialPageParam: 0`
       - `getNextPageParam`: calculate total loaded from `allPages.reduce((sum, page) => sum + page.values.length, 0)`. Return loadedCount if loadedCount < lastPage.matchingCount, otherwise return undefined (no more pages)
       - `enabled: !!projectId && !!batchId && !!fieldKey`
       - Return type annotation: use the return type of useInfiniteQuery (let TypeScript infer)

    Important: Pass `search || undefined` (not empty string) to avoid sending `&search=` when search is empty. The backend may behave differently with empty string vs no param.
  </action>
  <verify>
    Run `cd apps/web && npx tsc --noEmit` — no type errors.
    Verify `use-debounce.ts` exports `useDebounce`.
    Verify `use-batches.ts` exports `useFieldValuesInfinite` alongside existing hooks.
  </verify>
  <done>
    `useDebounce` hook exists in `hooks/use-debounce.ts` with generic typing and proper cleanup.
    `useFieldValuesInfinite` hook exists in `use-batches.ts` using `useInfiniteQuery` with correct queryKey including fieldKey and search, initialPageParam=0, and getNextPageParam based on matchingCount.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes with zero errors
2. `field-values.schema.ts` exports match backend entity shape (values: string[], matchingCount: number, totalDistinctCount: number)
3. `getFieldValues` in batches.ts uses encodeURIComponent on fieldKey
4. `useFieldValuesInfinite` queryKey includes fieldKey and search for proper cache isolation
5. `useDebounce` properly cleans up setTimeout on unmount
</verification>

<success_criteria>
- Field values Zod schema validates { values: string[], matchingCount: number, totalDistinctCount: number }
- API endpoint method constructs correct URL with encoded fieldKey and optional search param
- useInfiniteQuery hook provides hasNextPage, fetchNextPage, and isFetchingNextPage for infinite scroll
- useDebounce hook delays value updates by specified milliseconds
- All existing hooks in use-batches.ts remain intact and functional
- TypeScript compilation passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-view-values-side-sheet/20-01-SUMMARY.md`
</output>
