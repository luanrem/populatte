---
phase: 20-view-values-side-sheet
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - apps/web/components/projects/field-values-side-sheet.tsx
  - apps/web/components/projects/field-value-row.tsx
  - apps/web/components/projects/batch-field-inventory.tsx
  - apps/web/components/projects/field-card.tsx

autonomous: true

must_haves:
  truths:
    - "User can click a field card to open a side sheet showing all values for that field"
    - "Side sheet includes debounced search input that filters displayed values via backend"
    - "User can copy individual values to clipboard with inline checkmark feedback"
    - "Side sheet fetches values on demand when opened, not pre-loaded"
    - "Loading skeletons display while values are fetching"
    - "Clicking a different field card swaps sheet content in place without closing"
    - "Infinite scroll loads more values as user scrolls to bottom of sheet"
    - "Empty state shows when field has no values or search has no matches"
  artifacts:
    - path: "apps/web/components/projects/field-values-side-sheet.tsx"
      provides: "Side sheet with header, search, value list, infinite scroll, and empty states"
      exports: ["FieldValuesSideSheet"]
    - path: "apps/web/components/projects/field-value-row.tsx"
      provides: "Individual value row with truncation, tooltip, and copy button"
      exports: ["FieldValueRow"]
    - path: "apps/web/components/projects/batch-field-inventory.tsx"
      provides: "Sheet state management (isSheetOpen, selectedField) and Sheet wrapper"
      contains: "Sheet open={isSheetOpen}"
    - path: "apps/web/components/projects/field-card.tsx"
      provides: "FieldCard with all field stats passed through for sheet header"
      contains: "onClick"
  key_links:
    - from: "apps/web/components/projects/batch-field-inventory.tsx"
      to: "apps/web/components/projects/field-values-side-sheet.tsx"
      via: "Sheet wrapping FieldValuesSideSheet with selectedField state"
      pattern: "FieldValuesSideSheet"
    - from: "apps/web/components/projects/field-values-side-sheet.tsx"
      to: "apps/web/lib/query/hooks/use-batches.ts"
      via: "useFieldValuesInfinite hook for on-demand data fetching"
      pattern: "useFieldValuesInfinite"
    - from: "apps/web/components/projects/field-values-side-sheet.tsx"
      to: "apps/web/hooks/use-debounce.ts"
      via: "useDebounce for search input"
      pattern: "useDebounce"
    - from: "apps/web/components/projects/field-value-row.tsx"
      to: "navigator.clipboard.writeText"
      via: "Copy button with Clipboard API"
      pattern: "navigator\\.clipboard\\.writeText"
---

<objective>
Build the side sheet UI components and integrate them into the field inventory grid, completing the field value exploration flow.

Purpose: Enable users to explore all distinct values of any field by clicking its card, with search filtering, infinite scroll, and clipboard copy.
Output: Two new components (FieldValuesSideSheet, FieldValueRow) and updates to BatchFieldInventory and FieldCard for sheet integration.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-view-values-side-sheet/20-01-SUMMARY.md

# Components to modify
@apps/web/components/projects/batch-field-inventory.tsx
@apps/web/components/projects/field-card.tsx

# UI primitives available
@apps/web/components/ui/sheet.tsx

# Phase context (locked decisions)
@.planning/phases/20-view-values-side-sheet/20-CONTEXT.md
@.planning/phases/20-view-values-side-sheet/20-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FieldValueRow and FieldValuesSideSheet components</name>
  <files>
    apps/web/components/projects/field-value-row.tsx
    apps/web/components/projects/field-values-side-sheet.tsx
  </files>
  <action>
    **Install react-intersection-observer first:**
    ```bash
    cd apps/web && pnpm add react-intersection-observer
    ```

    **1. Create `apps/web/components/projects/field-value-row.tsx`:**

    A single value row with copy button. Must include 'use client' directive.

    Props interface `FieldValueRowProps`:
    - `value: string` — the displayed value text
    - `count: number` — occurrence count (from matchingCount context, displayed as number)

    Component structure:
    - Outer div: `group flex items-center justify-between px-4 py-3 border-b hover:bg-muted/50 transition-colors`
    - Left side (value text): `flex-1 min-w-0 mr-4`
      - `<p>` with `text-sm truncate` and `title={value}` for hover tooltip on long values
      - Display `{value}`
    - Right side: `flex items-center gap-2 shrink-0`
      - Count span: `text-xs text-muted-foreground tabular-nums` displaying `{count}`
      - Copy button: wrap in `<button>` with `aria-label="Copy value"`
        - Click handler: async function that calls `navigator.clipboard.writeText(value)`, sets `copied` state to true, then setTimeout resets to false after 1500ms. Wrap in try/catch, console.error on failure.
        - Styling: On desktop (hover devices), hidden until row hover. On touch, always visible.
          Use Tailwind: `p-1 rounded transition-opacity hover:bg-muted` and add `opacity-0 group-hover:opacity-100` but with `[@media(hover:hover)]:opacity-0 [@media(hover:hover)]:group-hover:opacity-100` pattern. Default opacity-100 for touch.
          Simpler approach: just use `opacity-0 group-hover:opacity-100 sm:opacity-0 sm:group-hover:opacity-100` with a base of `opacity-100` at smallest breakpoint. Actually, the cleanest Tailwind approach: set base as visible, then `@media(hover: hover)` hides it. Since Tailwind doesn't natively support `@media(hover: hover)` as a utility, use: button always visible (no opacity classes), but for desktop add `md:opacity-0 md:group-hover:opacity-100` — on mobile it stays visible. This is a pragmatic approach.
        - Icon: `copied ? <CheckCheck className="h-4 w-4 text-green-600" /> : <Copy className="h-4 w-4 text-muted-foreground" />`
    - Import `useState` from react, `Copy` and `CheckCheck` from lucide-react

    **2. Create `apps/web/components/projects/field-values-side-sheet.tsx`:**

    The main side sheet content component. Must include 'use client' directive.

    Props interface `FieldValuesSideSheetProps`:
    - `projectId: string`
    - `batchId: string`
    - `fieldName: string`
    - `inferredType: string`
    - `presenceCount: number`
    - `uniqueCount: number`

    Imports needed:
    - `useState, useEffect, useRef` from react
    - `{ useInView }` from 'react-intersection-observer'
    - `{ Search, FileQuestion }` from 'lucide-react'
    - `{ SheetHeader, SheetTitle, SheetDescription }` from '@/components/ui/sheet'
    - `{ Badge }` from '@/components/ui/badge'
    - `{ Input }` from '@/components/ui/input'
    - `{ Skeleton }` from '@/components/ui/skeleton'
    - `{ Button }` from '@/components/ui/button'
    - `{ useFieldValuesInfinite }` from '@/lib/query/hooks/use-batches'
    - `{ useDebounce }` from '@/hooks/use-debounce'
    - `{ FieldValueRow }` from './field-value-row'

    Type badge color map — reuse EXACT same `typeColorMap` from field-card.tsx. To avoid duplication, either:
    - Option A: Copy the map (acceptable for 5-line object in two files)
    - Option B: Extract to shared file
    Choose Option A for simplicity (keeps this plan focused).

    Component implementation:
    - State: `searchInput` (string, default ''), scroll container ref
    - `debouncedSearch = useDebounce(searchInput, 300)`
    - Reset searchInput when fieldName changes: `useEffect(() => { setSearchInput('') }, [fieldName])`
    - Reset scroll position when fieldName changes: `useEffect(() => { scrollRef.current?.scrollTo({ top: 0 }) }, [fieldName])`
    - `{ ref: loadMoreRef, inView } = useInView()`
    - Destructure from useFieldValuesInfinite: `data, fetchNextPage, hasNextPage, isFetchingNextPage, isFetching, isLoading`
    - Auto-fetch effect: `useEffect` that calls `fetchNextPage()` when `inView && hasNextPage && !isFetchingNextPage`
    - Extract counts: `matchingCount = data?.pages[0]?.matchingCount ?? 0`, `totalCount = data?.pages[0]?.totalDistinctCount ?? 0`
    - Flatten values for rendering: `allValues = data?.pages.flatMap(page => page.values) ?? []`

    Layout (flex column, full height):
    1. **Header** (non-scrolling):
       - `SheetHeader` with:
         - Row: `SheetTitle` (fieldName) + `Badge` with type color (inferredType)
         - `SheetDescription`: `{presenceCount} registros . {uniqueCount} valores unicos`

    2. **Search area** (sticky):
       - Wrapper div: `px-4 pb-3 border-b`
       - `Input` with `placeholder="Buscar valores..."`, value=searchInput, onChange sets searchInput
       - Below input: result count paragraph `text-xs text-muted-foreground mt-2`
         - If debouncedSearch is truthy: `Mostrando {matchingCount} de {totalCount} valores`
         - Else: `{totalCount} valores unicos`
       - Only show count paragraph when data exists (not during initial load)

    3. **Value list** (scrollable):
       - Outer div: `flex-1 overflow-y-auto` with ref={scrollRef}
       - **Loading state** (isFetching && !data): Show 10 Skeleton elements (`h-12 w-full`) in a `space-y-0 p-0` container, each with `px-4 py-3 border-b` wrapper
       - **Empty state** (data exists but matchingCount === 0):
         - Centered container with `py-16 px-4`
         - Rounded icon container: `rounded-full border-2 border-dashed border-muted-foreground/25 bg-muted/50 p-6 mb-4`
         - `FileQuestion` icon: `h-10 w-10 text-muted-foreground/50`
         - If debouncedSearch: heading "Nenhum valor corresponde a busca" + `Button variant="ghost"` "Limpar busca" that sets searchInput to ''
         - If no search: heading "Nenhum valor encontrado" + description "Todos os registros tem valores vazios para este campo."
       - **Values list** (has data and matchingCount > 0):
         - Map over `allValues` rendering `FieldValueRow` for each. Key: `${value}-${index}` (values may repeat across pages but index keeps unique).
           - For count: Phase 18 endpoint returns `values: string[]` WITHOUT per-value counts. Pass `count={0}` for now and hide count display when count is 0. Actually — re-check: the backend `FieldValuesResult` has `values: string[]` only, no per-value counts. So DO NOT display occurrence count. Instead, only show the value text and the copy button. Adjust FieldValueRow to conditionally hide count when count === 0 or omit count entirely.

           **CORRECTION on FieldValueRow:** Since the backend doesn't return per-value occurrence counts, make the `count` prop optional (`count?: number`). When count is undefined or 0, don't render the count span. The row just shows value + copy button.
         - After all values: sentinel div with `ref={loadMoreRef}` and `py-4 text-center`
           - If `isFetchingNextPage`: `<span className="text-xs text-muted-foreground">Carregando mais...</span>`
           - Else if `hasNextPage`: empty (IntersectionObserver will trigger)
           - Else (no more pages, and allValues.length > 0): `<span className="text-xs text-muted-foreground">Fim da lista</span>`
  </action>
  <verify>
    Run `cd apps/web && npx tsc --noEmit` — no type errors.
    Verify `field-value-row.tsx` exports `FieldValueRow` with copy functionality.
    Verify `field-values-side-sheet.tsx` exports `FieldValuesSideSheet` with search, infinite scroll, and empty states.
    Check that react-intersection-observer is in package.json.
  </verify>
  <done>
    FieldValueRow renders value text with copy button (icon swap to CheckCheck for 1.5s on copy), hidden on desktop until hover, always visible on mobile.
    FieldValuesSideSheet renders header with field name + type badge + stats, sticky search input with debounced backend search, infinite scroll value list with FieldValueRow items, loading skeletons, empty state with "Limpar busca" button when searching, and "Fim da lista" sentinel.
    Search resets when switching fields. Scroll resets to top when switching fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Sheet into BatchFieldInventory and update FieldCard onClick</name>
  <files>
    apps/web/components/projects/batch-field-inventory.tsx
    apps/web/components/projects/field-card.tsx
  </files>
  <action>
    **1. Update `apps/web/components/projects/field-card.tsx`:**

    The FieldCard onClick currently passes no field data to the parent. The parent needs to know WHICH field was clicked AND its stats for the sheet header. Two approaches:
    - Option A: Parent already has the field data (it maps over `data.fields`), so onClick just needs the fieldName
    - Option B: Pass full field object through onClick

    Choose Option A — the parent already holds the full field array. FieldCard's `onClick` prop stays as `() => void`. The parent constructs the callback with the field's name. No changes needed to FieldCard's interface.

    Actually, FieldCard's interface already has `onClick?: () => void` — this is sufficient. The parent will pass `() => handleFieldClick(field)` where field has all the stats. **No changes needed to field-card.tsx.**

    **2. Update `apps/web/components/projects/batch-field-inventory.tsx`:**

    Add Sheet state management and render the Sheet + FieldValuesSideSheet.

    New imports:
    - `{ Sheet, SheetContent }` from '@/components/ui/sheet'
    - `{ FieldValuesSideSheet }` from './field-values-side-sheet'
    - Import `FieldStatsItem` type from '@/lib/api/schemas/field-stats.schema' (for typing selectedField state)

    New state:
    - `const [isSheetOpen, setIsSheetOpen] = useState(false)`
    - `const [selectedField, setSelectedField] = useState<FieldStatsItem | null>(null)`

    New handler:
    ```typescript
    const handleFieldClick = (field: FieldStatsItem) => {
      setSelectedField(field);
      setIsSheetOpen(true);
    };
    ```

    Update FieldCard rendering — change `onClick={() => {}}` to `onClick={() => handleFieldClick(field)}`.

    Add Sheet after the closing `</div>` of the field grid, but inside the outer fragment. Wrap the entire return in a fragment `<>...</>`:

    ```tsx
    <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
      <SheetContent side="right" className="w-[400px] sm:w-[540px] p-0 flex flex-col">
        {selectedField && (
          <FieldValuesSideSheet
            projectId={projectId}
            batchId={batchId}
            fieldName={selectedField.fieldName}
            inferredType={selectedField.inferredType}
            presenceCount={selectedField.presenceCount}
            uniqueCount={selectedField.uniqueCount}
          />
        )}
      </SheetContent>
    </Sheet>
    ```

    Key details:
    - SheetContent className adds `p-0` to remove default padding (FieldValuesSideSheet manages its own padding) and `flex flex-col` for full-height layout
    - Sheet width: `w-[400px] sm:w-[540px]` — wider than default sm:max-w-sm to accommodate value text
    - `side="right"` for right overlay
    - `onOpenChange={setIsSheetOpen}` enables backdrop click and ESC to close
    - The Sheet renders even when on the empty state path — add it outside the conditional returns. Restructure: instead of early-returning for empty state, use conditional rendering within the main return so the Sheet is always rendered.

    IMPORTANT: Currently the component early-returns for the empty state (line 43-57). This must be restructured so the Sheet is always mounted. Move the empty state into the main return's conditional, so the Sheet element is always rendered at the bottom. Pattern:

    ```tsx
    return (
      <>
        {/* Empty state */}
        {!isLoading && data && (data.fields.length === 0 || totalRows === 0) ? (
          <div>...empty state...</div>
        ) : (
          <div className="space-y-4">
            <Input ... />
            {isLoading ? (...skeletons...) : searchQuery && filteredFields.length === 0 ? (...no search results...) : (...field grid...)}
          </div>
        )}

        <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
          <SheetContent ...>
            {selectedField && <FieldValuesSideSheet ... />}
          </SheetContent>
        </Sheet>
      </>
    );
    ```

    This ensures the Sheet is always in the component tree regardless of empty state.
  </action>
  <verify>
    Run `cd apps/web && npx tsc --noEmit` — no type errors.
    Run `cd apps/web && npx next lint` — no lint errors.
    Verify `batch-field-inventory.tsx` imports and renders Sheet with FieldValuesSideSheet.
    Verify FieldCard onClick now calls handleFieldClick with the field data.
    Verify Sheet is rendered outside conditional returns so it's always mounted.
  </verify>
  <done>
    Clicking any FieldCard opens the side sheet from the right with that field's values.
    Sheet shows field name, type badge, presence/unique stats in header.
    Clicking a different FieldCard swaps sheet content (selectedField changes, Sheet stays open).
    Sheet closes via X button, backdrop click, or Escape key.
    Sheet is always in the DOM (no early returns bypass it).
    The empty state for "no fields" still renders correctly.
  </done>
</task>

</tasks>

<verification>
1. `cd apps/web && npx tsc --noEmit` passes with zero errors
2. `cd apps/web && npx next lint` passes with no new warnings
3. react-intersection-observer is in apps/web/package.json dependencies
4. Clicking a FieldCard opens the Sheet with correct field name in header
5. Search input in sheet filters values via debounced backend call
6. Scrolling to bottom of value list triggers fetchNextPage
7. Copy button shows checkmark for 1.5s after copying value
8. Switching fields resets search input and scroll position
9. Sheet closes on ESC, X button, and backdrop click
10. Empty state displays when field has no values
</verification>

<success_criteria>
- User can click any field card to open a right-side sheet with field name, type badge, and stats
- Sheet includes sticky search input with 300ms debounce hitting backend search endpoint
- Values load via infinite scroll (50 per page), auto-fetching as user scrolls
- Copy button on each row copies value text to clipboard with inline checkmark feedback
- Clicking different field cards swaps content without close/reopen animation
- All three dismiss methods work: X button, backdrop click, Escape key
- Loading skeletons shown during initial fetch
- Empty state shown when no values exist
- No-results state shown when search matches nothing, with "Limpar busca" button
- TypeScript compilation and linting pass with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/20-view-values-side-sheet/20-02-SUMMARY.md`
</output>
