---
phase: 21-domain-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/entities/mapping.entity.ts
  - apps/api/src/core/entities/index.ts
  - apps/api/src/core/repositories/mapping.repository.ts
  - apps/api/src/core/repositories/index.ts
  - apps/api/src/infrastructure/database/drizzle/schema/mappings.schema.ts
  - apps/api/src/infrastructure/database/drizzle/schema/index.ts
  - apps/api/src/infrastructure/database/drizzle/mappers/mapping.mapper.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-mapping.repository.ts
autonomous: true

must_haves:
  truths:
    - "Mapping entity interface exists with all required fields including successTrigger and successConfig"
    - "Mapping Drizzle schema defines mappings table with foreign key to projects, pgEnum for success_trigger, jsonb for successConfig, and soft-delete timestamp"
    - "MappingRepository abstract class defines CRUD + soft-delete method signatures"
    - "DrizzleMappingRepository implements all methods with isNull(deletedAt) filtering on every read query"
    - "MappingMapper converts database rows to domain entities with correct enum and jsonb casting"
  artifacts:
    - path: "apps/api/src/core/entities/mapping.entity.ts"
      provides: "Mapping, CreateMappingData, UpdateMappingData interfaces + SuccessTrigger enum + SuccessConfig interface"
    - path: "apps/api/src/core/repositories/mapping.repository.ts"
      provides: "Abstract MappingRepository class"
      exports: ["MappingRepository"]
    - path: "apps/api/src/infrastructure/database/drizzle/schema/mappings.schema.ts"
      provides: "mappings pgTable + successTriggerEnum + MappingRow/MappingInsert types"
      exports: ["mappings", "successTriggerEnum", "MappingRow", "MappingInsert"]
    - path: "apps/api/src/infrastructure/database/drizzle/mappers/mapping.mapper.ts"
      provides: "Static toDomain method for MappingRow -> Mapping"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-mapping.repository.ts"
      provides: "DrizzleMappingRepository with soft-delete aware queries"
  key_links:
    - from: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-mapping.repository.ts"
      to: "apps/api/src/infrastructure/database/drizzle/schema/mappings.schema.ts"
      via: "import mappings table for queries"
      pattern: "from.*schema"
    - from: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-mapping.repository.ts"
      to: "apps/api/src/infrastructure/database/drizzle/mappers/mapping.mapper.ts"
      via: "MappingMapper.toDomain() for row conversion"
      pattern: "MappingMapper\\.toDomain"
    - from: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-mapping.repository.ts"
      to: "apps/api/src/core/repositories/mapping.repository.ts"
      via: "extends MappingRepository"
      pattern: "extends MappingRepository"
---

<objective>
Create the Mapping domain layer: entity interface, Drizzle schema, repository abstract class, mapper, and Drizzle repository implementation.

Purpose: Establishes the Mapping data model and persistence layer that Phase 22 (Mapping CRUD) will build use cases and endpoints on top of. This is a vertical slice through Clean Architecture for the Mapping entity only.

Output: 5 new files (entity, schema, repository interface, mapper, repository implementation) + 2 updated index files.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Codebase Reference Files (follow these patterns EXACTLY)

Entity pattern: @apps/api/src/core/entities/project.entity.ts
Repository interface pattern: @apps/api/src/core/repositories/project.repository.ts
Schema pattern: @apps/api/src/infrastructure/database/drizzle/schema/projects.schema.ts
Mapper pattern: @apps/api/src/infrastructure/database/drizzle/mappers/project.mapper.ts
Repository implementation pattern: @apps/api/src/infrastructure/database/drizzle/repositories/drizzle-project.repository.ts

## Phase Context
@.planning/phases/21-domain-foundation/21-CONTEXT.md
@.planning/phases/21-domain-foundation/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mapping entity, schema, and repository interface</name>
  <files>
    apps/api/src/core/entities/mapping.entity.ts
    apps/api/src/core/entities/index.ts
    apps/api/src/core/repositories/mapping.repository.ts
    apps/api/src/core/repositories/index.ts
    apps/api/src/infrastructure/database/drizzle/schema/mappings.schema.ts
    apps/api/src/infrastructure/database/drizzle/schema/index.ts
  </files>
  <action>
    Create the Mapping entity, Drizzle schema, and repository interface following established patterns.

    **1. Entity file** (`mapping.entity.ts`):
    Follow the exact pattern of `project.entity.ts`. Define:
    - `SuccessTrigger` enum with values `UrlChange = 'url_change'` and `ElementAppears = 'element_appears'` (lowercase matching pgEnum convention like ProjectStatus)
    - `SuccessConfig` interface with optional `selector?: string` field (CSS selector for element_appears trigger)
    - `Mapping` interface: `id: string`, `projectId: string`, `name: string`, `targetUrl: string`, `isActive: boolean`, `successTrigger: SuccessTrigger | null`, `successConfig: SuccessConfig | null`, `createdAt: Date`, `updatedAt: Date`, `deletedAt: Date | null`
    - `CreateMappingData` interface: `projectId: string`, `name: string`, `targetUrl: string`, `successTrigger?: SuccessTrigger | null`, `successConfig?: SuccessConfig | null`
    - `UpdateMappingData` interface: all fields optional -- `name?: string`, `targetUrl?: string`, `isActive?: boolean`, `successTrigger?: SuccessTrigger | null`, `successConfig?: SuccessConfig | null`

    **2. Schema file** (`mappings.schema.ts`):
    Follow the exact pattern of `projects.schema.ts`. Define:
    - `successTriggerEnum` using `pgEnum('success_trigger', ['url_change', 'element_appears'])`
    - `mappings` pgTable with columns:
      - `id`: `uuid('id').primaryKey().defaultRandom()`
      - `projectId`: `uuid('project_id').notNull().references(() => projects.id)`
      - `name`: `text('name').notNull()`
      - `targetUrl`: `text('target_url').notNull()`
      - `isActive`: `boolean('is_active').notNull().default(true)`
      - `successTrigger`: `successTriggerEnum('success_trigger')` (nullable by default -- no `.notNull()`)
      - `successConfig`: `jsonb('success_config').$type<{ selector?: string }>()` (nullable by default)
      - `createdAt`: `timestamp('created_at', { withTimezone: true }).defaultNow()`
      - `updatedAt`: `timestamp('updated_at', { withTimezone: true }).defaultNow()`
      - `deletedAt`: `timestamp('deleted_at', { withTimezone: true })`
    - Indexes:
      - `index('idx_mappings_project_id').on(table.projectId)`
      - `index('idx_mappings_project_active').on(table.projectId, table.isActive).where(sql\`deleted_at IS NULL\`)`
    - Export `MappingRow` and `MappingInsert` type aliases using `$inferSelect` and `$inferInsert`
    - Import `projects` from `./projects.schema` and `sql` from `drizzle-orm`
    - Import `boolean` from `drizzle-orm/pg-core` (not in projects.schema -- new column type for this schema)

    **3. Repository interface** (`mapping.repository.ts`):
    Follow the exact pattern of `project.repository.ts`. Define abstract class `MappingRepository`:
    - `findById(id: string): Promise<Mapping | null>` -- note: NO userId param (ownership validation happens in use-case layer in Phase 22)
    - `findByProjectId(projectId: string): Promise<Mapping[]>` -- returns all active mappings for a project
    - `create(data: CreateMappingData): Promise<Mapping>`
    - `update(id: string, data: UpdateMappingData): Promise<Mapping | null>`
    - `softDelete(id: string): Promise<void>`

    **4. Update index files:**
    - Add `export * from './mapping.entity'` to `core/entities/index.ts`
    - Add `export * from './mapping.repository'` to `core/repositories/index.ts`
    - Add `export * from './mappings.schema'` to `infrastructure/database/drizzle/schema/index.ts`
  </action>
  <verify>Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit -p apps/api/tsconfig.json` -- should have no errors related to the new mapping files. Minor pre-existing errors are acceptable.</verify>
  <done>Mapping entity, schema, and repository interface exist. Schema index re-exports mappings. Entity and repository indexes re-export mapping types.</done>
</task>

<task type="auto">
  <name>Task 2: Mapping mapper and Drizzle repository implementation</name>
  <files>
    apps/api/src/infrastructure/database/drizzle/mappers/mapping.mapper.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-mapping.repository.ts
  </files>
  <action>
    Create the mapper and repository implementation following established patterns.

    **1. Mapper** (`mapping.mapper.ts`):
    Follow the exact pattern of `project.mapper.ts`. Define class `MappingMapper`:
    - Static `toDomain(row: MappingRow): Mapping` method
    - Import `Mapping`, `SuccessTrigger`, `SuccessConfig` from `../../../../core/entities/mapping.entity`
    - Import `MappingRow` from `../schema/mappings.schema` (use `import type`)
    - Map all fields:
      - `id`, `projectId`, `name`, `targetUrl` -- direct pass-through
      - `isActive` -- direct pass-through (boolean)
      - `successTrigger` -- cast: `row.successTrigger as SuccessTrigger | null` (nullable enum, same pattern as ProjectStatus cast but allowing null)
      - `successConfig` -- cast: `(row.successConfig ?? null) as SuccessConfig | null` (jsonb nullable)
      - `createdAt` -- `row.createdAt ?? new Date()` (same pattern as project mapper)
      - `updatedAt` -- `row.updatedAt ?? new Date()`
      - `deletedAt` -- `row.deletedAt` (nullable, direct pass-through like project mapper)

    **2. Drizzle Repository** (`drizzle-mapping.repository.ts`):
    Follow the exact pattern of `drizzle-project.repository.ts`. Define:
    - `@Injectable()` class `DrizzleMappingRepository extends MappingRepository`
    - Constructor: `public constructor(private readonly drizzle: DrizzleService) { super(); }`
    - Import from `drizzle-orm`: `and`, `eq`, `isNull`, `asc`
    - Import `DrizzleService` from `../drizzle.service`
    - Import `mappings` from `../schema` (barrel import)
    - Import `MappingMapper` from `../mappers/mapping.mapper`
    - Import entity types from `../../../../core/entities/mapping.entity`
    - Import `MappingRepository` from `../../../../core/repositories/mapping.repository`

    **Methods:**

    `findById(id: string)`:
    - Query: `select().from(mappings).where(and(eq(mappings.id, id), isNull(mappings.deletedAt))).limit(1)`
    - Access `result[0]`, return `row ? MappingMapper.toDomain(row) : null`
    - CRITICAL: Include `isNull(mappings.deletedAt)` -- soft-delete filtering

    `findByProjectId(projectId: string)`:
    - Query: `select().from(mappings).where(and(eq(mappings.projectId, projectId), isNull(mappings.deletedAt))).orderBy(asc(mappings.createdAt))`
    - Return `result.map(row => MappingMapper.toDomain(row))`
    - CRITICAL: Include `isNull(mappings.deletedAt)` -- soft-delete filtering

    `create(data: CreateMappingData)`:
    - Query: `insert(mappings).values({ projectId: data.projectId, name: data.name, targetUrl: data.targetUrl, successTrigger: data.successTrigger ?? null, successConfig: data.successConfig ?? null }).returning()`
    - Access `result[0]`, throw `new Error('Failed to create mapping')` if null
    - Return `MappingMapper.toDomain(row)`

    `update(id: string, data: UpdateMappingData)`:
    - Build set object using spread pattern from project repository:
      `...(data.name !== undefined && { name: data.name })` for each optional field
    - Always include `updatedAt: new Date()` in set
    - WHERE: `and(eq(mappings.id, id), isNull(mappings.deletedAt))`
    - Use `.returning()`, return mapped result or null

    `softDelete(id: string)`:
    - Query: `update(mappings).set({ deletedAt: new Date(), updatedAt: new Date() }).where(and(eq(mappings.id, id), isNull(mappings.deletedAt)))`
    - No return value (void)
    - Note: No userId check here -- ownership validation is in use-case layer (Phase 22)
  </action>
  <verify>Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit -p apps/api/tsconfig.json` -- should compile with no new errors related to mapping files.</verify>
  <done>MappingMapper.toDomain correctly converts MappingRow to Mapping. DrizzleMappingRepository implements all 5 abstract methods with soft-delete filtering on every read query.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit -p apps/api/tsconfig.json` compiles without new errors
- All 5 new files exist at the expected paths
- Both index files (entities, repositories, schema) re-export the new mapping modules
- The schema uses `pgEnum` for `success_trigger` with values `['url_change', 'element_appears']`
- Every read query in `DrizzleMappingRepository` includes `isNull(mappings.deletedAt)`
- Entity interface has `successTrigger: SuccessTrigger | null` and `successConfig: SuccessConfig | null`
</verification>

<success_criteria>
- Mapping entity, schema, abstract repository, mapper, and Drizzle repository exist
- TypeScript compilation passes
- Soft-delete filtering is present on all read queries
- Schema defines proper foreign key to projects table
- Schema index re-exports mappings schema
</success_criteria>

<output>
After completion, create `.planning/phases/21-domain-foundation/21-01-SUMMARY.md`
</output>
