---
phase: 21-domain-foundation
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - apps/api/src/core/entities/step.entity.ts
  - apps/api/src/core/entities/index.ts
  - apps/api/src/core/repositories/step.repository.ts
  - apps/api/src/core/repositories/index.ts
  - apps/api/src/infrastructure/database/drizzle/schema/steps.schema.ts
  - apps/api/src/infrastructure/database/drizzle/schema/index.ts
  - apps/api/src/infrastructure/database/drizzle/mappers/step.mapper.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts
  - apps/api/src/infrastructure/database/drizzle/drizzle.module.ts
autonomous: true

must_haves:
  truths:
    - "Step entity interface exists with action enum (fill/click/wait), typed selector, selectorFallbacks array, mutually exclusive sourceFieldKey/fixedValue, stepOrder, and config options"
    - "Step Drizzle schema defines steps table with foreign key to mappings, pgEnum for step_action, jsonb for selector and selectorFallbacks, and no deletedAt column"
    - "StepRepository abstract class defines CRUD + reorder method signatures"
    - "DrizzleStepRepository implements all methods including hard-delete and bulk reorder"
    - "StepMapper converts database rows to domain entities with correct jsonb and enum casting"
    - "DrizzleModule registers both MappingRepository and StepRepository provider bindings"
    - "Drizzle migration is generated and applied creating both mappings and steps tables"
  artifacts:
    - path: "apps/api/src/core/entities/step.entity.ts"
      provides: "Step, CreateStepData, UpdateStepData interfaces + StepAction, SelectorType enums + SelectorEntry interface"
    - path: "apps/api/src/core/repositories/step.repository.ts"
      provides: "Abstract StepRepository class"
      exports: ["StepRepository"]
    - path: "apps/api/src/infrastructure/database/drizzle/schema/steps.schema.ts"
      provides: "steps pgTable + stepActionEnum + StepRow/StepInsert types"
      exports: ["steps", "stepActionEnum", "StepRow", "StepInsert"]
    - path: "apps/api/src/infrastructure/database/drizzle/mappers/step.mapper.ts"
      provides: "Static toDomain method for StepRow -> Step"
    - path: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts"
      provides: "DrizzleStepRepository with hard-delete and reorder support"
    - path: "apps/api/src/infrastructure/database/drizzle/drizzle.module.ts"
      provides: "DI bindings for MappingRepository + StepRepository"
  key_links:
    - from: "apps/api/src/infrastructure/database/drizzle/schema/steps.schema.ts"
      to: "apps/api/src/infrastructure/database/drizzle/schema/mappings.schema.ts"
      via: "foreign key reference to mappings table"
      pattern: "references.*mappings\\.id"
    - from: "apps/api/src/infrastructure/database/drizzle/drizzle.module.ts"
      to: "apps/api/src/core/repositories/mapping.repository.ts"
      via: "provide: MappingRepository binding"
      pattern: "provide.*MappingRepository"
    - from: "apps/api/src/infrastructure/database/drizzle/drizzle.module.ts"
      to: "apps/api/src/core/repositories/step.repository.ts"
      via: "provide: StepRepository binding"
      pattern: "provide.*StepRepository"
    - from: "apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts"
      to: "apps/api/src/infrastructure/database/drizzle/mappers/step.mapper.ts"
      via: "StepMapper.toDomain() for row conversion"
      pattern: "StepMapper\\.toDomain"
---

<objective>
Create the Step domain layer (entity, schema, repository, mapper, implementation), register both Mapping and Step repositories in DrizzleModule, and generate + apply the Drizzle migration for both new tables.

Purpose: Completes the Phase 21 data layer foundation. After this plan, both Mapping and Step persistence layers are fully operational, and Phase 22 can build use cases and endpoints directly.

Output: 5 new files (step entity, schema, repository interface, mapper, repository implementation) + 3 updated files (entity index, repository index, schema index, DrizzleModule) + database migration.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-domain-foundation/21-01-SUMMARY.md

## Codebase Reference Files (follow these patterns EXACTLY)

Entity pattern: @apps/api/src/core/entities/batch.entity.ts (has jsonb types like ColumnMetadata)
Repository interface pattern: @apps/api/src/core/repositories/row.repository.ts (child entity with parent FK)
Schema pattern: @apps/api/src/infrastructure/database/drizzle/schema/ingestion-rows.schema.ts (child table with FK)
Mapper pattern: @apps/api/src/infrastructure/database/drizzle/mappers/row.mapper.ts (has jsonb casting)
Repository implementation pattern: @apps/api/src/infrastructure/database/drizzle/repositories/drizzle-row.repository.ts
DrizzleModule: @apps/api/src/infrastructure/database/drizzle/drizzle.module.ts

## Prior Plan Outputs (from 21-01)
@apps/api/src/infrastructure/database/drizzle/schema/mappings.schema.ts
@apps/api/src/core/entities/mapping.entity.ts

## Phase Context
@.planning/phases/21-domain-foundation/21-CONTEXT.md
@.planning/phases/21-domain-foundation/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Step entity, schema, repository interface, mapper, and implementation</name>
  <files>
    apps/api/src/core/entities/step.entity.ts
    apps/api/src/core/entities/index.ts
    apps/api/src/core/repositories/step.repository.ts
    apps/api/src/core/repositories/index.ts
    apps/api/src/infrastructure/database/drizzle/schema/steps.schema.ts
    apps/api/src/infrastructure/database/drizzle/schema/index.ts
    apps/api/src/infrastructure/database/drizzle/mappers/step.mapper.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts
  </files>
  <action>
    Create the full Step domain layer following established patterns.

    **1. Entity file** (`step.entity.ts`):
    Follow the pattern of `batch.entity.ts` (has enum + interface for jsonb types).
    - `StepAction` enum: `Fill = 'fill'`, `Click = 'click'`, `Wait = 'wait'` (lowercase, matching pgEnum)
    - `SelectorType` enum: `Css = 'css'`, `Xpath = 'xpath'` (lowercase)
    - `SelectorEntry` interface: `{ type: SelectorType; value: string }` -- used for both primary selector and fallbacks
    - `Step` interface:
      - `id: string`, `mappingId: string`
      - `action: StepAction`
      - `selector: SelectorEntry` (primary selector, always present)
      - `selectorFallbacks: SelectorEntry[]` (ordered array, max 5 enforced at use-case level)
      - `sourceFieldKey: string | null` (XOR with fixedValue, enforced at use-case level)
      - `fixedValue: string | null` (XOR with sourceFieldKey)
      - `stepOrder: number`
      - `optional: boolean`, `clearBefore: boolean`, `pressEnter: boolean`
      - `waitMs: number | null` (required only for wait action, enforced at use-case level)
      - `createdAt: Date`, `updatedAt: Date`
      - NO `deletedAt` -- steps use hard-delete per CONTEXT decisions
    - `CreateStepData` interface:
      - `mappingId: string`, `action: StepAction`, `selector: SelectorEntry`, `stepOrder: number` (required)
      - `selectorFallbacks?: SelectorEntry[]`, `sourceFieldKey?: string | null`, `fixedValue?: string | null` (optional)
      - `optional?: boolean`, `clearBefore?: boolean`, `pressEnter?: boolean`, `waitMs?: number | null` (optional)
    - `UpdateStepData` interface: all fields optional (same as CreateStepData minus mappingId, all with `?`)

    **2. Schema file** (`steps.schema.ts`):
    Follow the pattern of `ingestion-rows.schema.ts` (child table with FK + jsonb columns).
    - `stepActionEnum` using `pgEnum('step_action', ['fill', 'click', 'wait'])`
    - Do NOT create a `selectorTypeEnum` pgEnum -- selector type lives inside jsonb, typed by `$type<>()` only
    - `steps` pgTable with columns:
      - `id`: `uuid('id').primaryKey().defaultRandom()`
      - `mappingId`: `uuid('mapping_id').notNull().references(() => mappings.id)` -- import `mappings` from `./mappings.schema`
      - `action`: `stepActionEnum('action').notNull()`
      - `selector`: `jsonb('selector').notNull().$type<{ type: 'css' | 'xpath'; value: string }>()` -- typed jsonb, NOT nullable
      - `selectorFallbacks`: `jsonb('selector_fallbacks').notNull().default([]).$type<Array<{ type: 'css' | 'xpath'; value: string }>>()` -- default empty array
      - `sourceFieldKey`: `text('source_field_key')` (nullable by default)
      - `fixedValue`: `text('fixed_value')` (nullable by default)
      - `stepOrder`: `integer('step_order').notNull()`
      - `optional`: `boolean('optional').notNull().default(false)`
      - `clearBefore`: `boolean('clear_before').notNull().default(false)`
      - `pressEnter`: `boolean('press_enter').notNull().default(false)`
      - `waitMs`: `integer('wait_ms')` (nullable by default)
      - `createdAt`: `timestamp('created_at', { withTimezone: true }).defaultNow()`
      - `updatedAt`: `timestamp('updated_at', { withTimezone: true }).defaultNow()`
      - NO `deletedAt` column -- steps use hard-delete
    - Indexes:
      - `index('idx_steps_mapping_id').on(table.mappingId)`
      - `index('idx_steps_mapping_order').on(table.mappingId, table.stepOrder)`
    - Export `StepRow` and `StepInsert` type aliases

    **3. Repository interface** (`step.repository.ts`):
    Follow the pattern of `row.repository.ts`. Define abstract class `StepRepository`:
    - `findById(id: string): Promise<Step | null>`
    - `findByMappingId(mappingId: string): Promise<Step[]>` -- returns steps ordered by stepOrder ascending
    - `create(data: CreateStepData): Promise<Step>`
    - `update(id: string, data: UpdateStepData): Promise<Step | null>`
    - `delete(id: string): Promise<void>` -- hard delete, permanent removal
    - `reorder(mappingId: string, orderedStepIds: string[]): Promise<void>` -- reassign stepOrder based on array position

    **4. Mapper** (`step.mapper.ts`):
    Follow the pattern of `row.mapper.ts` (has jsonb casting).
    - Static `toDomain(row: StepRow): Step` method
    - Import `Step`, `StepAction`, `SelectorEntry`, `SelectorType` from entity
    - Import `StepRow` from schema (use `import type`)
    - Map all fields:
      - `action` -- cast: `row.action as StepAction`
      - `selector` -- cast: `row.selector as SelectorEntry` (jsonb to typed interface). Note: The SelectorEntry in the entity uses `SelectorType` enum while the DB stores string literals. Since `SelectorType.Css = 'css'` and `SelectorType.Xpath = 'xpath'` match the DB values, a direct cast is safe.
      - `selectorFallbacks` -- cast: `(row.selectorFallbacks ?? []) as SelectorEntry[]`
      - `sourceFieldKey`, `fixedValue` -- `row.sourceFieldKey ?? null`, `row.fixedValue ?? null`
      - `stepOrder` -- direct pass-through
      - `optional`, `clearBefore`, `pressEnter` -- direct pass-through (booleans)
      - `waitMs` -- `row.waitMs ?? null`
      - `createdAt` -- `row.createdAt ?? new Date()`
      - `updatedAt` -- `row.updatedAt ?? new Date()`

    **5. Drizzle Repository** (`drizzle-step.repository.ts`):
    Follow the pattern of `drizzle-row.repository.ts`.
    - `@Injectable()` class `DrizzleStepRepository extends StepRepository`
    - Constructor: `public constructor(private readonly drizzle: DrizzleService) { super(); }`
    - Import from `drizzle-orm`: `and`, `eq`, `asc`
    - Import `steps` from `../schema` (barrel import)
    - Import `StepMapper` from `../mappers/step.mapper`

    **Methods:**

    `findById(id: string)`:
    - Query: `select().from(steps).where(eq(steps.id, id)).limit(1)`
    - NO soft-delete filter -- steps don't have deletedAt
    - Return `row ? StepMapper.toDomain(row) : null`

    `findByMappingId(mappingId: string)`:
    - Query: `select().from(steps).where(eq(steps.mappingId, mappingId)).orderBy(asc(steps.stepOrder))`
    - Return `result.map(row => StepMapper.toDomain(row))`

    `create(data: CreateStepData)`:
    - Query: `insert(steps).values({ mappingId: data.mappingId, action: data.action, selector: data.selector, selectorFallbacks: data.selectorFallbacks ?? [], sourceFieldKey: data.sourceFieldKey ?? null, fixedValue: data.fixedValue ?? null, stepOrder: data.stepOrder, optional: data.optional ?? false, clearBefore: data.clearBefore ?? false, pressEnter: data.pressEnter ?? false, waitMs: data.waitMs ?? null }).returning()`
    - Access `result[0]`, throw `new Error('Failed to create step')` if null
    - Return `StepMapper.toDomain(row)`
    - NOTE: The `selector` and `selectorFallbacks` values are passed directly as JS objects/arrays -- Drizzle serializes jsonb automatically. The `.$type<>()` on the column ensures type safety at compile time.

    `update(id: string, data: UpdateStepData)`:
    - Build set object using spread pattern:
      `...(data.action !== undefined && { action: data.action })` for each optional field
    - For jsonb fields (`selector`, `selectorFallbacks`), same spread pattern works -- Drizzle handles serialization
    - Always include `updatedAt: new Date()`
    - WHERE: `eq(steps.id, id)`
    - Use `.returning()`, return mapped result or null

    `delete(id: string)`:
    - Query: `delete(steps).where(eq(steps.id, id))` -- HARD delete, no soft-delete
    - No return value

    `reorder(mappingId: string, orderedStepIds: string[])`:
    - Loop through `orderedStepIds` with index
    - For each `(stepId, i)`: `update(steps).set({ stepOrder: i + 1, updatedAt: new Date() }).where(and(eq(steps.id, stepId), eq(steps.mappingId, mappingId)))`
    - Use `noUncheckedIndexedAccess`-safe access: check `const stepId = orderedStepIds[i]; if (stepId) { ... }`
    - This is sequential updates, not a transaction -- acceptable for v3.0 scope

    **6. Update index files:**
    - Add `export * from './step.entity'` to `core/entities/index.ts` (already has mapping export from Plan 01)
    - Add `export * from './step.repository'` to `core/repositories/index.ts`
    - Add `export * from './steps.schema'` to `infrastructure/database/drizzle/schema/index.ts`
  </action>
  <verify>Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit -p apps/api/tsconfig.json` -- should compile with no new errors.</verify>
  <done>Step entity, schema, repository interface, mapper, and Drizzle implementation all exist. Schema exports steps table. Entity and repository indexes export step types.</done>
</task>

<task type="auto">
  <name>Task 2: DrizzleModule registration and database migration</name>
  <files>
    apps/api/src/infrastructure/database/drizzle/drizzle.module.ts
  </files>
  <action>
    Register both repository pairs in DrizzleModule and generate + apply the Drizzle migration.

    **1. Update DrizzleModule** (`drizzle.module.ts`):
    Add two new provider bindings following the exact existing pattern:

    New imports at top:
    - `import { MappingRepository } from '../../../core/repositories/mapping.repository';`
    - `import { StepRepository } from '../../../core/repositories/step.repository';`
    - `import { DrizzleMappingRepository } from './repositories/drizzle-mapping.repository';`
    - `import { DrizzleStepRepository } from './repositories/drizzle-step.repository';`

    Add to `providers` array (after existing RowRepository provider):
    ```
    {
      provide: MappingRepository,
      useClass: DrizzleMappingRepository,
    },
    {
      provide: StepRepository,
      useClass: DrizzleStepRepository,
    },
    ```

    Add to `exports` array (after existing RowRepository export):
    ```
    MappingRepository,
    StepRepository,
    ```

    **2. Generate migration:**
    Run from the api directory:
    ```bash
    cd /Users/luanmartins/source/projects/populatte/apps/api && npm run db:generate
    ```
    This reads the schema changes (new mappings + steps tables) and generates a migration SQL file in the drizzle migrations directory.

    **3. Apply migration:**
    Run:
    ```bash
    cd /Users/luanmartins/source/projects/populatte/apps/api && npm run db:migrate
    ```
    This applies the generated migration to create both tables in the database.

    **4. Verify tables exist:**
    After migration, run `npm run db:studio` or verify via TypeScript compilation that the schema is consistent.

    NOTE: If db:migrate fails due to database connection issues (e.g., local Postgres not running), that is acceptable -- the migration file is generated and can be applied later. The critical deliverable is the migration SQL file existing and the DrizzleModule being correctly wired.
  </action>
  <verify>
    1. Run `cd /Users/luanmartins/source/projects/populatte && npx tsc --noEmit -p apps/api/tsconfig.json` -- full compilation passes.
    2. Run `cd /Users/luanmartins/source/projects/populatte && npm run lint --filter=@populatte/api` -- no new lint errors.
    3. Verify migration file exists: `ls apps/api/drizzle/*/` should show a new migration SQL file.
    4. DrizzleModule has 6 repository providers (User, Project, Batch, Row, Mapping, Step).
  </verify>
  <done>DrizzleModule registers MappingRepository and StepRepository. Migration file is generated creating both mappings and steps tables with all columns, constraints, and indexes. TypeScript compiles. Lint passes.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit -p apps/api/tsconfig.json` compiles cleanly
- `npm run lint --filter=@populatte/api` passes
- DrizzleModule exports MappingRepository and StepRepository
- Schema index re-exports both `mappings.schema` and `steps.schema`
- Entity index re-exports both `mapping.entity` and `step.entity`
- Repository index re-exports both `mapping.repository` and `step.repository`
- Migration SQL file exists in `apps/api/drizzle/` directory
- Steps schema references mappings table via FK on `mapping_id`
- Steps schema has NO `deletedAt` column (hard-delete only)
- Mappings schema HAS `deletedAt` column (soft-delete)
- Step repository `findById` and `findByMappingId` have NO `isNull(deletedAt)` filter (steps are hard-deleted)
- Mapping repository queries ALL have `isNull(deletedAt)` filter
</verification>

<success_criteria>
- Both domain models (Mapping + Step) have complete Clean Architecture layers: entity, schema, repository interface, mapper, repository implementation
- DrizzleModule DI bindings are registered for both repositories
- Database migration is generated (and ideally applied)
- TypeScript compiles and lint passes
- Phase 22 can immediately build use cases importing MappingRepository and StepRepository
</success_criteria>

<output>
After completion, create `.planning/phases/21-domain-foundation/21-02-SUMMARY.md`
</output>
