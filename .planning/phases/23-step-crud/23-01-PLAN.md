---
phase: 23-step-crud
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/core/use-cases/step/create-step.use-case.ts
  - apps/api/src/core/use-cases/step/update-step.use-case.ts
  - apps/api/src/core/use-cases/step/delete-step.use-case.ts
  - apps/api/src/core/use-cases/step/reorder-steps.use-case.ts
  - apps/api/src/core/use-cases/step/index.ts
  - apps/api/src/core/use-cases/index.ts
  - apps/api/src/core/repositories/step.repository.ts
  - apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts
autonomous: true

must_haves:
  truths:
    - "User can create a step for a mapping they own"
    - "User can update a step in a mapping they own"
    - "User can delete a step from a mapping they own"
    - "User can reorder steps within a mapping they own"
    - "All step operations validate full ownership chain (step -> mapping -> project -> user)"
  artifacts:
    - path: "apps/api/src/core/use-cases/step/create-step.use-case.ts"
      provides: "CreateStepUseCase with ownership validation"
      exports: ["CreateStepUseCase", "CreateStepInput"]
    - path: "apps/api/src/core/use-cases/step/update-step.use-case.ts"
      provides: "UpdateStepUseCase with ownership validation"
      exports: ["UpdateStepUseCase", "UpdateStepInput"]
    - path: "apps/api/src/core/use-cases/step/delete-step.use-case.ts"
      provides: "DeleteStepUseCase with ownership validation"
      exports: ["DeleteStepUseCase", "DeleteStepInput"]
    - path: "apps/api/src/core/use-cases/step/reorder-steps.use-case.ts"
      provides: "ReorderStepsUseCase with strict validation"
      exports: ["ReorderStepsUseCase", "ReorderStepsInput"]
  key_links:
    - from: "CreateStepUseCase"
      to: "MappingRepository.findById"
      via: "ownership validation"
      pattern: "mappingRepository\\.findById"
    - from: "UpdateStepUseCase"
      to: "StepRepository.findById"
      via: "step lookup for mapping ownership"
      pattern: "stepRepository\\.findById"
    - from: "ReorderStepsUseCase"
      to: "StepRepository.findByMappingId"
      via: "all steps validation"
      pattern: "stepRepository\\.findByMappingId"
---

<objective>
Create 4 step CRUD use cases (create, update, delete, reorder) with defense-in-depth ownership validation and extend StepRepository with required methods.

Purpose: Enable step lifecycle management with full security chain validation before Phase 23-02 wires the controller.
Output: 4 injectable use cases ready for controller consumption, updated StepRepository interface and implementation.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-step-crud/23-CONTEXT.md

# Reference patterns
@apps/api/src/core/use-cases/mapping/create-mapping.use-case.ts
@apps/api/src/core/entities/step.entity.ts
@apps/api/src/core/repositories/step.repository.ts
@apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StepRepository with getMaxStepOrder and enhanced reorder</name>
  <files>
    apps/api/src/core/repositories/step.repository.ts
    apps/api/src/infrastructure/database/drizzle/repositories/drizzle-step.repository.ts
  </files>
  <action>
1. In step.repository.ts, add two abstract methods:
   - `getMaxStepOrder(mappingId: string): Promise<number>` - returns highest stepOrder for a mapping (0 if no steps)
   - Update `reorder` signature to return `Promise<Step[]>` (returns all updated steps)

2. In drizzle-step.repository.ts:
   - Implement `getMaxStepOrder`: SELECT COALESCE(MAX(step_order), 0) FROM steps WHERE mapping_id = ?
   - Update `reorder` to return all steps after reordering by calling findByMappingId at the end
  </action>
  <verify>
Run `npm run type-check --filter=@populatte/api` - no TypeScript errors
  </verify>
  <done>
StepRepository has getMaxStepOrder method and reorder returns Step[]
  </done>
</task>

<task type="auto">
  <name>Task 2: Create 4 step CRUD use cases with defense-in-depth ownership</name>
  <files>
    apps/api/src/core/use-cases/step/create-step.use-case.ts
    apps/api/src/core/use-cases/step/update-step.use-case.ts
    apps/api/src/core/use-cases/step/delete-step.use-case.ts
    apps/api/src/core/use-cases/step/reorder-steps.use-case.ts
    apps/api/src/core/use-cases/step/index.ts
    apps/api/src/core/use-cases/index.ts
  </files>
  <action>
Create 4 use cases following established MappingUseCase patterns with defense-in-depth:

**CreateStepUseCase:**
- Input: { mappingId, userId, action, selector, selectorFallbacks?, sourceFieldKey?, fixedValue?, optional?, clearBefore?, pressEnter?, waitMs? }
- Validation: sourceFieldKey and fixedValue cannot BOTH be provided (400 if both provided)
- Ownership chain: MappingRepository.findById -> 404 if null -> check deletedAt -> 404 if deleted -> get projectId -> ProjectRepository.findByIdOnly -> check project.userId === userId -> 403 if not
- Auto-assign stepOrder: StepRepository.getMaxStepOrder(mappingId) + 1
- Return: created Step

**UpdateStepUseCase:**
- Input: { stepId, mappingId, userId, action?, selector?, selectorFallbacks?, sourceFieldKey?, fixedValue?, optional?, clearBefore?, pressEnter?, waitMs? }
- Validation: same sourceFieldKey/fixedValue mutual exclusion
- Ownership chain: StepRepository.findById -> 404 if null -> verify step.mappingId === mappingId (defense-in-depth) -> MappingRepository.findById -> 404/deletedAt check -> ProjectRepository.findByIdOnly -> userId check -> 403 if not
- Return: updated Step

**DeleteStepUseCase:**
- Input: { stepId, mappingId, userId }
- Ownership chain: same as UpdateStepUseCase
- Hard delete via StepRepository.delete
- Return: void

**ReorderStepsUseCase:**
- Input: { mappingId, userId, orderedStepIds: string[] }
- Ownership chain: validate mapping exists and user owns project (same pattern)
- Strict validation:
  - Get all steps via StepRepository.findByMappingId(mappingId)
  - Extract IDs, check orderedStepIds has same length
  - Check for duplicates in orderedStepIds (400 if any)
  - Check orderedStepIds contains ALL existing step IDs (400 if missing any)
  - Check orderedStepIds contains NO extra IDs (400 if any extra)
- Call StepRepository.reorder(mappingId, orderedStepIds)
- Return: Step[] (all steps with new order)

**Barrel exports:**
- Create index.ts exporting all 4 use cases
- Add step export to core/use-cases/index.ts

All use cases:
- @Injectable decorator
- Logger for security audit on 403
- Follow exact error message pattern from mapping use cases
  </action>
  <verify>
Run `npm run type-check --filter=@populatte/api` - no TypeScript errors
Run `npm run lint --filter=@populatte/api` - no linting errors
  </verify>
  <done>
4 step use cases exist with defense-in-depth ownership validation and proper barrel exports
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npm run type-check --filter=@populatte/api`
2. Linting passes: `npm run lint --filter=@populatte/api`
3. Files exist at expected paths with proper exports
</verification>

<success_criteria>
- StepRepository has getMaxStepOrder method
- StepRepository.reorder returns Step[]
- CreateStepUseCase validates ownership chain and auto-assigns stepOrder
- UpdateStepUseCase validates step belongs to mapping (defense-in-depth)
- DeleteStepUseCase performs hard delete with ownership validation
- ReorderStepsUseCase strictly validates orderedStepIds array
- All use cases handle sourceFieldKey/fixedValue mutual exclusion (both can be null, but not both provided)
</success_criteria>

<output>
After completion, create `.planning/phases/23-step-crud/23-01-SUMMARY.md`
</output>
