---
phase: 24-extension-foundation
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - apps/extension/src/storage/index.ts
  - apps/extension/src/storage/types.ts
  - apps/extension/src/storage/auth.ts
  - apps/extension/src/storage/selection.ts
  - apps/extension/src/storage/preferences.ts
autonomous: true

must_haves:
  truths:
    - "Storage operations persist data across popup closes"
    - "Storage operations work in both background and popup contexts"
    - "Type-safe accessors exist for auth, selection, and preferences"
    - "Storage uses chrome.storage.local via WXT abstraction"
  artifacts:
    - path: "apps/extension/src/storage/index.ts"
      provides: "Storage module exports"
      exports: ["storage", "initializeStorage"]
    - path: "apps/extension/src/storage/types.ts"
      provides: "Storage type definitions"
      contains: "AuthState"
    - path: "apps/extension/src/storage/auth.ts"
      provides: "Auth storage accessors"
      contains: "getAuth"
    - path: "apps/extension/src/storage/selection.ts"
      provides: "Selection storage accessors"
      contains: "getSelectedProject"
  key_links:
    - from: "apps/extension/src/storage/auth.ts"
      to: "wxt/storage"
      via: "import storage.defineItem"
      pattern: "storage\\.defineItem"
---

<objective>
Implement the storage abstraction layer using WXT's built-in storage API with type-safe accessors for auth, selection, and preferences.

Purpose: Provide persistent state management that survives popup closes and service worker restarts. This is critical for maintaining user session and selections.

Output: A storage module with explicit typed methods (getAuth, setSelectedProject, etc.) that wraps chrome.storage.local.

Note: This plan creates ONLY the storage module files. The background.ts integration happens in Plan 24-03 which consolidates both storage initialization and messaging into the final background.ts.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-extension-foundation/24-CONTEXT.md
@.planning/research/STACK-extension.md
@.planning/phases/24-extension-foundation/24-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define storage types</name>
  <files>
    apps/extension/src/storage/types.ts
  </files>
  <action>
Create `apps/extension/src/storage/types.ts` with the storage state types.

Per CONTEXT.md decisions:
- Single root object structure: `{ auth: {...}, selection: {...}, preferences: {...} }`
- Flat sections (one level deep), not deeply nested

```typescript
/**
 * Storage Types
 *
 * Storage is organized into three flat sections:
 * - auth: Authentication state (token, user info)
 * - selection: Current project/batch/row selection
 * - preferences: User preferences
 *
 * Each section is persisted independently in chrome.storage.local
 */

/**
 * Authentication state
 * Persisted to survive browser restarts
 */
export interface AuthState {
  /** JWT token from extension auth flow */
  token: string | null;
  /** User ID from Populatte API */
  userId: string | null;
  /** User email for display */
  userEmail: string | null;
  /** Token expiry timestamp (ms since epoch) */
  expiresAt: number | null;
}

/**
 * Current selection state
 * Persisted to restore user's last position
 */
export interface SelectionState {
  /** Currently selected project ID */
  projectId: string | null;
  /** Currently selected batch ID */
  batchId: string | null;
  /** Current row index within batch (0-based) */
  rowIndex: number;
  /** Total rows in current batch (cached) */
  rowTotal: number;
}

/**
 * User preferences
 * Persisted across sessions
 */
export interface PreferencesState {
  /** Last used project ID (for quick restore) */
  lastProjectId: string | null;
}

/**
 * Default values for storage initialization
 */
export const DEFAULT_AUTH: AuthState = {
  token: null,
  userId: null,
  userEmail: null,
  expiresAt: null,
};

export const DEFAULT_SELECTION: SelectionState = {
  projectId: null,
  batchId: null,
  rowIndex: 0,
  rowTotal: 0,
};

export const DEFAULT_PREFERENCES: PreferencesState = {
  lastProjectId: null,
};
```
  </action>
  <verify>
    `cat apps/extension/src/storage/types.ts | grep -E "(AuthState|SelectionState|PreferencesState)"`
  </verify>
  <done>Storage type definitions created with AuthState, SelectionState, PreferencesState interfaces</done>
</task>

<task type="auto">
  <name>Task 2: Create storage accessors</name>
  <files>
    apps/extension/src/storage/auth.ts
    apps/extension/src/storage/selection.ts
    apps/extension/src/storage/preferences.ts
  </files>
  <action>
Create typed storage accessors using WXT's storage API.

**Important API note:** CONTEXT.md mentions "defineStorage()" but WXT's actual API is `storage.defineItem<T>()`. This IS the WXT storage abstraction - the CONTEXT.md wording was imprecise. We use `storage.defineItem()` which is WXT's built-in typed storage over chrome.storage.local.

Per CONTEXT.md decisions:
- Type-safe accessors: `storage.getAuth()`, `storage.setSelectedProject()` -- explicit methods per data type
- Silent fallback on errors: use in-memory defaults, log error, continue working
- Read-on-demand, no reactive subscriptions
- Last write wins: simple overwrite

1. Create `apps/extension/src/storage/auth.ts`:
```typescript
import { storage } from 'wxt/storage';
import type { AuthState } from './types';
import { DEFAULT_AUTH } from './types';

const AUTH_KEY = 'local:populatte:auth';

const authItem = storage.defineItem<AuthState>(AUTH_KEY, {
  fallback: DEFAULT_AUTH,
});

/**
 * Auth storage accessors
 */
export const authStorage = {
  /**
   * Get current auth state
   */
  async getAuth(): Promise<AuthState> {
    try {
      return await authItem.getValue();
    } catch (error) {
      console.error('[Storage] Failed to get auth:', error);
      return DEFAULT_AUTH;
    }
  },

  /**
   * Set auth state (full replacement)
   */
  async setAuth(auth: AuthState): Promise<void> {
    try {
      await authItem.setValue(auth);
    } catch (error) {
      console.error('[Storage] Failed to set auth:', error);
    }
  },

  /**
   * Update auth token
   */
  async setToken(token: string, expiresAt: number): Promise<void> {
    const current = await this.getAuth();
    await this.setAuth({
      ...current,
      token,
      expiresAt,
    });
  },

  /**
   * Set user info after token validation
   */
  async setUser(userId: string, userEmail: string): Promise<void> {
    const current = await this.getAuth();
    await this.setAuth({
      ...current,
      userId,
      userEmail,
    });
  },

  /**
   * Clear auth state (logout)
   */
  async clearAuth(): Promise<void> {
    await this.setAuth(DEFAULT_AUTH);
  },

  /**
   * Check if token is expired
   */
  async isExpired(): Promise<boolean> {
    const auth = await this.getAuth();
    if (!auth.token || !auth.expiresAt) {
      return true;
    }
    // Consider expired if less than 1 minute remaining
    return Date.now() > auth.expiresAt - 60000;
  },

  /**
   * Check if user is authenticated
   */
  async isAuthenticated(): Promise<boolean> {
    const auth = await this.getAuth();
    return auth.token !== null && !(await this.isExpired());
  },
};
```

2. Create `apps/extension/src/storage/selection.ts`:
```typescript
import { storage } from 'wxt/storage';
import type { SelectionState } from './types';
import { DEFAULT_SELECTION } from './types';

const SELECTION_KEY = 'local:populatte:selection';

const selectionItem = storage.defineItem<SelectionState>(SELECTION_KEY, {
  fallback: DEFAULT_SELECTION,
});

/**
 * Selection storage accessors
 */
export const selectionStorage = {
  /**
   * Get current selection state
   */
  async getSelection(): Promise<SelectionState> {
    try {
      return await selectionItem.getValue();
    } catch (error) {
      console.error('[Storage] Failed to get selection:', error);
      return DEFAULT_SELECTION;
    }
  },

  /**
   * Set selection state (full replacement)
   */
  async setSelection(selection: SelectionState): Promise<void> {
    try {
      await selectionItem.setValue(selection);
    } catch (error) {
      console.error('[Storage] Failed to set selection:', error);
    }
  },

  /**
   * Get selected project ID
   */
  async getSelectedProject(): Promise<string | null> {
    const selection = await this.getSelection();
    return selection.projectId;
  },

  /**
   * Set selected project (clears batch/row selection)
   */
  async setSelectedProject(projectId: string | null): Promise<void> {
    await this.setSelection({
      projectId,
      batchId: null,
      rowIndex: 0,
      rowTotal: 0,
    });
  },

  /**
   * Get selected batch ID
   */
  async getSelectedBatch(): Promise<string | null> {
    const selection = await this.getSelection();
    return selection.batchId;
  },

  /**
   * Set selected batch (resets row index)
   */
  async setSelectedBatch(batchId: string | null, rowTotal: number = 0): Promise<void> {
    const current = await this.getSelection();
    await this.setSelection({
      ...current,
      batchId,
      rowIndex: 0,
      rowTotal,
    });
  },

  /**
   * Get current row index
   */
  async getRowIndex(): Promise<number> {
    const selection = await this.getSelection();
    return selection.rowIndex;
  },

  /**
   * Set current row index
   */
  async setRowIndex(rowIndex: number): Promise<void> {
    const current = await this.getSelection();
    await this.setSelection({
      ...current,
      rowIndex: Math.max(0, Math.min(rowIndex, current.rowTotal - 1)),
    });
  },

  /**
   * Advance to next row
   */
  async nextRow(): Promise<number> {
    const current = await this.getSelection();
    const newIndex = Math.min(current.rowIndex + 1, current.rowTotal - 1);
    await this.setRowIndex(newIndex);
    return newIndex;
  },

  /**
   * Go to previous row
   */
  async prevRow(): Promise<number> {
    const current = await this.getSelection();
    const newIndex = Math.max(current.rowIndex - 1, 0);
    await this.setRowIndex(newIndex);
    return newIndex;
  },

  /**
   * Clear selection state
   */
  async clearSelection(): Promise<void> {
    await this.setSelection(DEFAULT_SELECTION);
  },
};
```

3. Create `apps/extension/src/storage/preferences.ts`:
```typescript
import { storage } from 'wxt/storage';
import type { PreferencesState } from './types';
import { DEFAULT_PREFERENCES } from './types';

const PREFERENCES_KEY = 'local:populatte:preferences';

const preferencesItem = storage.defineItem<PreferencesState>(PREFERENCES_KEY, {
  fallback: DEFAULT_PREFERENCES,
});

/**
 * Preferences storage accessors
 */
export const preferencesStorage = {
  /**
   * Get preferences state
   */
  async getPreferences(): Promise<PreferencesState> {
    try {
      return await preferencesItem.getValue();
    } catch (error) {
      console.error('[Storage] Failed to get preferences:', error);
      return DEFAULT_PREFERENCES;
    }
  },

  /**
   * Set preferences state
   */
  async setPreferences(preferences: PreferencesState): Promise<void> {
    try {
      await preferencesItem.setValue(preferences);
    } catch (error) {
      console.error('[Storage] Failed to set preferences:', error);
    }
  },

  /**
   * Get last project ID (for quick restore)
   */
  async getLastProjectId(): Promise<string | null> {
    const prefs = await this.getPreferences();
    return prefs.lastProjectId;
  },

  /**
   * Set last project ID
   */
  async setLastProjectId(projectId: string | null): Promise<void> {
    const current = await this.getPreferences();
    await this.setPreferences({
      ...current,
      lastProjectId: projectId,
    });
  },
};
```
  </action>
  <verify>
    `cat apps/extension/src/storage/auth.ts | grep "async getAuth"` and `cat apps/extension/src/storage/selection.ts | grep "async getSelectedProject"`
  </verify>
  <done>Auth, selection, and preferences storage accessors created with explicit typed methods</done>
</task>

<task type="auto">
  <name>Task 3: Create storage module index</name>
  <files>
    apps/extension/src/storage/index.ts
  </files>
  <action>
Create the storage module index file that exports all storage accessors.

Note: This task does NOT modify background.ts. Plan 24-03 will create the complete background.ts with both storage initialization AND messaging handlers.

Create `apps/extension/src/storage/index.ts`:
```typescript
/**
 * Storage Module
 *
 * Provides type-safe storage accessors for the extension.
 * Uses WXT's storage.defineItem() API over chrome.storage.local.
 *
 * Usage:
 *   import { storage } from '@/storage';
 *   const auth = await storage.auth.getAuth();
 *   await storage.selection.setSelectedProject('project-123');
 */

export * from './types';
export { authStorage } from './auth';
export { selectionStorage } from './selection';
export { preferencesStorage } from './preferences';

import { authStorage } from './auth';
import { selectionStorage } from './selection';
import { preferencesStorage } from './preferences';

/**
 * Unified storage accessor
 * Provides namespaced access to all storage domains
 */
export const storage = {
  auth: authStorage,
  selection: selectionStorage,
  preferences: preferencesStorage,
};

/**
 * Initialize storage with eager load
 * Called on service worker startup to warm cache
 *
 * Per CONTEXT.md: Eager initialization - load full state into memory when service worker starts
 */
export async function initializeStorage(): Promise<void> {
  console.log('[Storage] Initializing...');

  // Pre-load all storage values to verify they're accessible
  const [auth, selection, preferences] = await Promise.all([
    authStorage.getAuth(),
    selectionStorage.getSelection(),
    preferencesStorage.getPreferences(),
  ]);

  console.log('[Storage] Initialized:', {
    authenticated: auth.token !== null,
    hasProject: selection.projectId !== null,
    lastProject: preferences.lastProjectId,
  });
}
```
  </action>
  <verify>
    `cat apps/extension/src/storage/index.ts | grep "export const storage"` and `cat apps/extension/src/storage/index.ts | grep "initializeStorage"`
  </verify>
  <done>Storage module index exports unified storage object and initializeStorage function</done>
</task>

</tasks>

<verification>
1. `apps/extension/src/storage/types.ts` defines AuthState, SelectionState, PreferencesState
2. `apps/extension/src/storage/auth.ts` exports authStorage with getAuth, setAuth, setToken, clearAuth
3. `apps/extension/src/storage/selection.ts` exports selectionStorage with getSelectedProject, setSelectedBatch
4. `apps/extension/src/storage/preferences.ts` exports preferencesStorage with getLastProjectId
5. `apps/extension/src/storage/index.ts` exports unified storage object and initializeStorage
6. Extension still builds: `cd apps/extension && npm run build`
</verification>

<success_criteria>
- Storage types defined with AuthState, SelectionState, PreferencesState
- Type-safe accessors created for each storage domain
- Storage uses WXT's storage.defineItem() with fallback defaults
- Storage module exports unified accessor and initialization function
- Extension builds successfully with storage module
</success_criteria>

<output>
After completion, create `.planning/phases/24-extension-foundation/24-02-SUMMARY.md`
</output>
