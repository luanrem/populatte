---
phase: 24-extension-foundation
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - apps/extension/src/types/messages.ts
  - apps/extension/src/types/responses.ts
  - apps/extension/src/types/index.ts
  - apps/extension/src/messaging/send.ts
  - apps/extension/src/messaging/handlers.ts
  - apps/extension/src/messaging/index.ts
  - apps/extension/entrypoints/background.ts
  - apps/extension/entrypoints/content.ts
  - apps/extension/entrypoints/popup/App.tsx
autonomous: true

must_haves:
  truths:
    - "Popup can send typed messages to background and receive typed responses"
    - "Background can send typed messages to content script"
    - "Messages use discriminated union types with explicit type field"
    - "Error responses follow { success: false, error: string } pattern"
  artifacts:
    - path: "apps/extension/src/types/messages.ts"
      provides: "Message type definitions"
      contains: "type ExtensionMessage"
    - path: "apps/extension/src/messaging/send.ts"
      provides: "Type-safe message sending"
      exports: ["sendToBackground", "sendToContent"]
    - path: "apps/extension/src/messaging/handlers.ts"
      provides: "Message handler registry"
      contains: "MessageHandler"
  key_links:
    - from: "apps/extension/entrypoints/popup/App.tsx"
      to: "apps/extension/src/messaging/send.ts"
      via: "import sendToBackground"
      pattern: "sendToBackground"
    - from: "apps/extension/entrypoints/background.ts"
      to: "apps/extension/src/messaging/handlers.ts"
      via: "import handlers"
      pattern: "handleMessage"
---

<objective>
Implement the type-safe message bus for communication between popup, background, and content script contexts.

Purpose: Enable reliable, type-safe communication between extension contexts. This is the backbone for all user actions flowing through the extension.

Output: A messaging module with discriminated union message types, typed send functions, and a handler registry pattern.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-extension-foundation/24-CONTEXT.md
@.planning/research/STACK-extension.md
@.planning/research/ARCHITECTURE-extension.md
@.planning/phases/24-extension-foundation/24-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define message types</name>
  <files>
    apps/extension/src/types/messages.ts
    apps/extension/src/types/responses.ts
    apps/extension/src/types/index.ts
  </files>
  <action>
Create message type definitions using discriminated unions per CONTEXT.md decisions.

1. Create `apps/extension/src/types/messages.ts`:
```typescript
/**
 * Extension Message Types
 *
 * All messages use discriminated unions with explicit `type` field.
 * Per CONTEXT.md: Strict discriminated unions: `{ type: 'FILL', payload: FillPayload }`
 *
 * Message naming convention:
 * - Commands (popup -> background): ACTION_VERB (e.g., AUTH_LOGIN, PROJECT_SELECT)
 * - Queries (popup -> background): GET_NOUN (e.g., GET_AUTH, GET_PROJECTS)
 * - Events (background -> popup/content): NOUN_EVENT (e.g., STATE_UPDATED, FILL_PROGRESS)
 */

// ============================================================================
// Auth Messages
// ============================================================================

export interface AuthLoginMessage {
  type: 'AUTH_LOGIN';
  payload: {
    code: string; // Connection code from web app
  };
}

export interface AuthLogoutMessage {
  type: 'AUTH_LOGOUT';
}

export interface GetAuthMessage {
  type: 'GET_AUTH';
}

// ============================================================================
// Project Messages
// ============================================================================

export interface GetProjectsMessage {
  type: 'GET_PROJECTS';
}

export interface ProjectSelectMessage {
  type: 'PROJECT_SELECT';
  payload: {
    projectId: string;
  };
}

// ============================================================================
// Batch Messages
// ============================================================================

export interface GetBatchesMessage {
  type: 'GET_BATCHES';
  payload: {
    projectId: string;
  };
}

export interface BatchSelectMessage {
  type: 'BATCH_SELECT';
  payload: {
    batchId: string;
  };
}

// ============================================================================
// Row Messages
// ============================================================================

export interface GetRowsMessage {
  type: 'GET_ROWS';
  payload: {
    batchId: string;
    page: number;
    limit: number;
  };
}

export interface RowSelectMessage {
  type: 'ROW_SELECT';
  payload: {
    rowIndex: number;
  };
}

export interface RowNextMessage {
  type: 'ROW_NEXT';
}

export interface RowPrevMessage {
  type: 'ROW_PREV';
}

// ============================================================================
// Fill Messages (Background <-> Content Script)
// ============================================================================

export interface FillStartMessage {
  type: 'FILL_START';
}

export interface FillExecuteMessage {
  type: 'FILL_EXECUTE';
  payload: {
    steps: FillStep[];
    rowData: Record<string, unknown>;
  };
}

export interface FillStep {
  id: string;
  stepOrder: number;
  action: 'fill' | 'click' | 'wait';
  selector: {
    type: 'css' | 'xpath';
    value: string;
  };
  selectorFallbacks?: Array<{
    type: 'css' | 'xpath';
    value: string;
  }>;
  sourceFieldKey?: string;
  fixedValue?: string;
  clearBefore?: boolean;
  pressEnter?: boolean;
  waitMs?: number;
  optional?: boolean;
}

export interface FillResultMessage {
  type: 'FILL_RESULT';
  payload: {
    success: boolean;
    stepResults: StepResult[];
    error?: string;
  };
}

export interface StepResult {
  stepId: string;
  success: boolean;
  skipped?: boolean;
  reason?: string;
  error?: string;
  duration?: number;
}

// ============================================================================
// State Messages (Background -> Popup)
// ============================================================================

export interface StateUpdatedMessage {
  type: 'STATE_UPDATED';
  payload: ExtensionState;
}

export interface ExtensionState {
  isAuthenticated: boolean;
  userEmail: string | null;
  projectId: string | null;
  batchId: string | null;
  rowIndex: number;
  rowTotal: number;
  fillStatus: FillStatus;
}

export type FillStatus = 'idle' | 'pending' | 'filling' | 'success' | 'partial' | 'failed';

// ============================================================================
// Progress Messages (Background -> Popup)
// ============================================================================

export interface FillProgressMessage {
  type: 'FILL_PROGRESS';
  payload: {
    currentStep: number;
    totalSteps: number;
    status: string;
  };
}

// ============================================================================
// Utility Messages
// ============================================================================

export interface PingMessage {
  type: 'PING';
}

export interface GetStateMessage {
  type: 'GET_STATE';
}

// ============================================================================
// Union Types
// ============================================================================

/**
 * Messages sent from Popup to Background
 */
export type PopupToBackgroundMessage =
  | AuthLoginMessage
  | AuthLogoutMessage
  | GetAuthMessage
  | GetProjectsMessage
  | ProjectSelectMessage
  | GetBatchesMessage
  | BatchSelectMessage
  | GetRowsMessage
  | RowSelectMessage
  | RowNextMessage
  | RowPrevMessage
  | FillStartMessage
  | GetStateMessage
  | PingMessage;

/**
 * Messages sent from Background to Content Script
 */
export type BackgroundToContentMessage =
  | FillExecuteMessage
  | PingMessage;

/**
 * Messages sent from Content Script to Background
 */
export type ContentToBackgroundMessage =
  | FillResultMessage
  | PingMessage;

/**
 * Messages broadcast from Background to Popup
 */
export type BackgroundToPopupMessage =
  | StateUpdatedMessage
  | FillProgressMessage;

/**
 * All extension messages (for handler type)
 */
export type ExtensionMessage =
  | PopupToBackgroundMessage
  | BackgroundToContentMessage
  | ContentToBackgroundMessage
  | BackgroundToPopupMessage;
```

2. Create `apps/extension/src/types/responses.ts`:
```typescript
/**
 * Response Types
 *
 * Per CONTEXT.md: Return error objects: `{ success: false, error: 'message' }`
 * Caller decides how to display errors.
 */

import type { ExtensionState, StepResult } from './messages';

/**
 * Base response wrapper
 */
export type Response<T> =
  | { success: true; data: T }
  | { success: false; error: string };

/**
 * Void response (for commands that don't return data)
 */
export type VoidResponse =
  | { success: true }
  | { success: false; error: string };

// ============================================================================
// Specific Response Types
// ============================================================================

export type AuthResponse = Response<{
  token: string | null;
  userId: string | null;
  userEmail: string | null;
  isExpired: boolean;
}>;

export type ProjectsResponse = Response<{
  projects: ProjectSummary[];
}>;

export interface ProjectSummary {
  id: string;
  name: string;
  batchCount: number;
}

export type BatchesResponse = Response<{
  batches: BatchSummary[];
}>;

export interface BatchSummary {
  id: string;
  name: string;
  filename: string;
  rowCount: number;
  createdAt: string;
}

export type RowsResponse = Response<{
  rows: RowData[];
  total: number;
  page: number;
}>;

export interface RowData {
  id: string;
  rowNumber: number;
  data: Record<string, unknown>;
  fillStatus?: string;
}

export type StateResponse = Response<ExtensionState>;

export type FillResponse = Response<{
  stepResults: StepResult[];
}>;

export type PingResponse = Response<{
  pong: true;
  context: 'background' | 'content';
}>;
```

3. Create `apps/extension/src/types/index.ts`:
```typescript
/**
 * Extension Types
 *
 * Re-exports all type definitions for convenient imports.
 */

export * from './messages';
export * from './responses';
```
  </action>
  <verify>
    `cat apps/extension/src/types/messages.ts | grep "type ExtensionMessage"` and `cat apps/extension/src/types/responses.ts | grep "type Response"`
  </verify>
  <done>Message types defined with discriminated unions and response wrapper types</done>
</task>

<task type="auto">
  <name>Task 2: Create messaging utilities</name>
  <files>
    apps/extension/src/messaging/send.ts
    apps/extension/src/messaging/handlers.ts
    apps/extension/src/messaging/index.ts
  </files>
  <action>
Create messaging utilities for type-safe sending and handling.

Per CONTEXT.md:
- Configurable timeouts: messages timeout after N seconds, return timeout error
- Dev-only logging: log messages in development, silent in production

1. Create `apps/extension/src/messaging/send.ts`:
```typescript
/**
 * Message Sending Utilities
 *
 * Type-safe functions for sending messages between extension contexts.
 */

import type {
  PopupToBackgroundMessage,
  BackgroundToContentMessage,
} from '@/types';

const DEFAULT_TIMEOUT_MS = 10000; // 10 seconds
const isDev = import.meta.env.DEV;

/**
 * Send message from Popup to Background
 *
 * @param message - Typed message to send
 * @param timeoutMs - Timeout in milliseconds (default: 10000)
 * @returns Promise resolving to response or rejecting on timeout/error
 */
export async function sendToBackground<T>(
  message: PopupToBackgroundMessage,
  timeoutMs: number = DEFAULT_TIMEOUT_MS
): Promise<T> {
  if (isDev) {
    console.log('[Messaging] Popup -> Background:', message.type);
  }

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`Message timeout: ${message.type} (${timeoutMs}ms)`));
    }, timeoutMs);

    browser.runtime
      .sendMessage(message)
      .then((response) => {
        clearTimeout(timeout);
        if (isDev) {
          console.log('[Messaging] Background response:', response);
        }
        resolve(response as T);
      })
      .catch((error) => {
        clearTimeout(timeout);
        console.error('[Messaging] Send error:', error);
        reject(error);
      });
  });
}

/**
 * Send message from Background to Content Script
 *
 * @param tabId - Tab ID to send message to
 * @param message - Typed message to send
 * @param timeoutMs - Timeout in milliseconds (default: 10000)
 * @returns Promise resolving to response or rejecting on timeout/error
 */
export async function sendToContent<T>(
  tabId: number,
  message: BackgroundToContentMessage,
  timeoutMs: number = DEFAULT_TIMEOUT_MS
): Promise<T> {
  if (isDev) {
    console.log('[Messaging] Background -> Content:', message.type, 'tab:', tabId);
  }

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`Message timeout: ${message.type} (${timeoutMs}ms)`));
    }, timeoutMs);

    browser.tabs
      .sendMessage(tabId, message)
      .then((response) => {
        clearTimeout(timeout);
        if (isDev) {
          console.log('[Messaging] Content response:', response);
        }
        resolve(response as T);
      })
      .catch((error) => {
        clearTimeout(timeout);
        console.error('[Messaging] Send to content error:', error);
        reject(error);
      });
  });
}

/**
 * Broadcast message to all extension contexts (popup)
 *
 * Used by background to push state updates.
 * Silently ignores errors (popup may not be open).
 */
export async function broadcast(message: { type: string; payload: unknown }): Promise<void> {
  if (isDev) {
    console.log('[Messaging] Broadcast:', message.type);
  }

  try {
    await browser.runtime.sendMessage(message);
  } catch {
    // Popup not open, ignore
  }
}
```

2. Create `apps/extension/src/messaging/handlers.ts`:
```typescript
/**
 * Message Handler Registry
 *
 * Pattern for registering typed message handlers in background service worker.
 */

import type {
  ExtensionMessage,
  PopupToBackgroundMessage,
  ContentToBackgroundMessage,
} from '@/types';
import type { Response, VoidResponse } from '@/types';

const isDev = import.meta.env.DEV;

/**
 * Message handler function type
 */
export type MessageHandler<M extends ExtensionMessage, R> = (
  message: M,
  sender: browser.Runtime.MessageSender
) => Promise<R>;

/**
 * Handler registry type
 */
export type HandlerRegistry = {
  [K in ExtensionMessage['type']]?: MessageHandler<
    Extract<ExtensionMessage, { type: K }>,
    unknown
  >;
};

/**
 * Create a message handler that routes messages to registered handlers
 *
 * @param handlers - Object mapping message types to handler functions
 * @returns Listener function for browser.runtime.onMessage
 */
export function createMessageRouter(handlers: HandlerRegistry) {
  return (
    message: ExtensionMessage,
    sender: browser.Runtime.MessageSender
  ): Promise<unknown> | false => {
    const handler = handlers[message.type];

    if (!handler) {
      if (isDev) {
        console.warn('[Handler] No handler for message:', message.type);
      }
      return false;
    }

    if (isDev) {
      console.log('[Handler] Handling:', message.type);
    }

    // Execute handler and return promise
    return (handler as MessageHandler<typeof message, unknown>)(message, sender)
      .catch((error) => {
        console.error('[Handler] Error in', message.type, ':', error);
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        } as Response<never>;
      });
  };
}

/**
 * Helper to create a success response
 */
export function success<T>(data: T): Response<T> {
  return { success: true, data };
}

/**
 * Helper to create a void success response
 */
export function ok(): VoidResponse {
  return { success: true };
}

/**
 * Helper to create an error response
 */
export function error(message: string): Response<never> {
  return { success: false, error: message };
}
```

3. Create `apps/extension/src/messaging/index.ts`:
```typescript
/**
 * Messaging Module
 *
 * Provides type-safe message passing between extension contexts.
 *
 * Usage in Popup:
 *   import { sendToBackground } from '@/messaging';
 *   const response = await sendToBackground<AuthResponse>({ type: 'GET_AUTH' });
 *
 * Usage in Background:
 *   import { createMessageRouter, success, error } from '@/messaging';
 *   const router = createMessageRouter({
 *     'GET_AUTH': async () => success({ ... }),
 *     'AUTH_LOGIN': async (msg) => { ... },
 *   });
 *   browser.runtime.onMessage.addListener(router);
 */

export { sendToBackground, sendToContent, broadcast } from './send';
export { createMessageRouter, success, ok, error } from './handlers';
export type { MessageHandler, HandlerRegistry } from './handlers';
```
  </action>
  <verify>
    `cat apps/extension/src/messaging/send.ts | grep "export async function sendToBackground"` and `cat apps/extension/src/messaging/handlers.ts | grep "export function createMessageRouter"`
  </verify>
  <done>Messaging utilities created with typed send functions and handler registry</done>
</task>

<task type="auto">
  <name>Task 3: Wire up messaging in all contexts</name>
  <files>
    apps/extension/entrypoints/background.ts
    apps/extension/entrypoints/content.ts
    apps/extension/entrypoints/popup/App.tsx
  </files>
  <action>
Update all three contexts to use the messaging system.

1. Update `apps/extension/entrypoints/background.ts`:
```typescript
import { storage, initializeStorage } from '@/storage';
import { createMessageRouter, success, error, broadcast } from '@/messaging';
import type { ExtensionState, PingResponse, StateResponse, AuthResponse } from '@/types';

export default defineBackground(() => {
  console.log('[Populatte] Service worker initialized');

  // Eager initialization of storage
  initializeStorage().catch((err) => {
    console.error('[Populatte] Storage initialization failed:', err);
  });

  // Build current state from storage
  async function buildState(): Promise<ExtensionState> {
    const [auth, selection] = await Promise.all([
      storage.auth.getAuth(),
      storage.selection.getSelection(),
    ]);

    return {
      isAuthenticated: auth.token !== null && !(await storage.auth.isExpired()),
      userEmail: auth.userEmail,
      projectId: selection.projectId,
      batchId: selection.batchId,
      rowIndex: selection.rowIndex,
      rowTotal: selection.rowTotal,
      fillStatus: 'idle',
    };
  }

  // Broadcast state update to popup
  async function notifyStateUpdate(): Promise<void> {
    const state = await buildState();
    broadcast({ type: 'STATE_UPDATED', payload: state });
  }

  // Create message router with handlers
  const router = createMessageRouter({
    // Ping handler (for testing connectivity)
    PING: async () => {
      return success({ pong: true, context: 'background' }) as PingResponse;
    },

    // Get current extension state
    GET_STATE: async () => {
      const state = await buildState();
      return success(state) as StateResponse;
    },

    // Get auth state
    GET_AUTH: async () => {
      const auth = await storage.auth.getAuth();
      const isExpired = await storage.auth.isExpired();
      return success({
        token: auth.token,
        userId: auth.userId,
        userEmail: auth.userEmail,
        isExpired,
      }) as AuthResponse;
    },

    // Logout
    AUTH_LOGOUT: async () => {
      await storage.auth.clearAuth();
      await storage.selection.clearSelection();
      await notifyStateUpdate();
      return success(undefined);
    },

    // Project selection
    PROJECT_SELECT: async (message) => {
      const { projectId } = message.payload;
      await storage.selection.setSelectedProject(projectId);
      await storage.preferences.setLastProjectId(projectId);
      await notifyStateUpdate();
      return success(undefined);
    },

    // Batch selection
    BATCH_SELECT: async (message) => {
      const { batchId } = message.payload;
      // TODO: Fetch row count from API in Phase 27
      await storage.selection.setSelectedBatch(batchId, 0);
      await notifyStateUpdate();
      return success(undefined);
    },

    // Row navigation
    ROW_NEXT: async () => {
      const newIndex = await storage.selection.nextRow();
      await notifyStateUpdate();
      return success({ rowIndex: newIndex });
    },

    ROW_PREV: async () => {
      const newIndex = await storage.selection.prevRow();
      await notifyStateUpdate();
      return success({ rowIndex: newIndex });
    },
  });

  // Register message listener
  browser.runtime.onMessage.addListener(router);

  // Log when extension is installed or updated
  browser.runtime.onInstalled.addListener((details) => {
    console.log('[Populatte] Extension installed/updated:', details.reason);
  });
});
```

2. Update `apps/extension/entrypoints/content.ts`:
```typescript
import type { FillExecuteMessage, FillResultMessage, PingResponse, StepResult } from '@/types';

export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_idle',

  main() {
    console.log('[Populatte] Content script loaded on:', window.location.hostname);

    // Register message listener
    browser.runtime.onMessage.addListener((message, sender) => {
      console.log('[Populatte] Content script received:', message.type);

      // Ping handler
      if (message.type === 'PING') {
        return Promise.resolve({
          success: true,
          data: { pong: true, context: 'content' },
        } as PingResponse);
      }

      // Fill execute handler (placeholder for Phase 28)
      if (message.type === 'FILL_EXECUTE') {
        const msg = message as FillExecuteMessage;
        console.log('[Populatte] Execute fill with', msg.payload.steps.length, 'steps');

        // Placeholder: Return mock success
        const results: StepResult[] = msg.payload.steps.map((step) => ({
          stepId: step.id,
          success: true,
          duration: 100,
        }));

        return Promise.resolve({
          success: true,
          data: { stepResults: results },
        });
      }

      return false;
    });
  },
});
```

3. Update `apps/extension/entrypoints/popup/App.tsx`:
```tsx
import { useEffect, useState } from 'react';
import { Coffee, RefreshCw } from 'lucide-react';
import { sendToBackground } from '@/messaging';
import type { StateResponse, PingResponse, ExtensionState } from '@/types';

export default function App() {
  const [state, setState] = useState<ExtensionState | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Load initial state
  useEffect(() => {
    loadState();

    // Listen for state updates from background
    const listener = (message: { type: string; payload: unknown }) => {
      if (message.type === 'STATE_UPDATED') {
        setState(message.payload as ExtensionState);
      }
    };

    browser.runtime.onMessage.addListener(listener);
    return () => browser.runtime.onMessage.removeListener(listener);
  }, []);

  async function loadState() {
    setLoading(true);
    setError(null);

    try {
      const response = await sendToBackground<StateResponse>({ type: 'GET_STATE' });

      if (response.success) {
        setState(response.data);
      } else {
        setError(response.error);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load state');
    } finally {
      setLoading(false);
    }
  }

  async function testPing() {
    try {
      const response = await sendToBackground<PingResponse>({ type: 'PING' });
      if (response.success) {
        console.log('Ping success:', response.data);
        alert('Ping successful! Background is responsive.');
      } else {
        alert('Ping failed: ' + response.error);
      }
    } catch (err) {
      alert('Ping error: ' + (err instanceof Error ? err.message : 'Unknown'));
    }
  }

  return (
    <div className="w-[350px] h-[500px] bg-white p-4 flex flex-col">
      <header className="flex items-center gap-2 mb-4 pb-3 border-b">
        <Coffee className="w-6 h-6 text-amber-700" />
        <h1 className="text-lg font-semibold text-gray-900">Populatte</h1>
        <button
          onClick={loadState}
          className="ml-auto p-1 hover:bg-gray-100 rounded"
          title="Refresh state"
        >
          <RefreshCw className={`w-4 h-4 text-gray-500 ${loading ? 'animate-spin' : ''}`} />
        </button>
      </header>

      <main className="flex-1 space-y-4">
        {loading && (
          <div className="p-3 bg-gray-50 rounded-lg border">
            <p className="text-sm text-gray-600">Loading...</p>
          </div>
        )}

        {error && (
          <div className="p-3 bg-red-50 rounded-lg border border-red-200">
            <p className="text-sm text-red-800">Error: {error}</p>
          </div>
        )}

        {state && !loading && (
          <>
            <div className="p-3 bg-amber-50 rounded-lg border border-amber-200">
              <p className="text-sm text-amber-800">
                {state.isAuthenticated
                  ? `Connected as ${state.userEmail || 'user'}`
                  : 'Not connected. Auth integration pending.'}
              </p>
            </div>

            <div className="space-y-2">
              <div className="flex justify-between text-sm">
                <span className="text-gray-500">Status:</span>
                <span className={state.isAuthenticated ? 'text-green-600' : 'text-gray-600'}>
                  {state.isAuthenticated ? 'Connected' : 'Disconnected'}
                </span>
              </div>
              <div className="flex justify-between text-sm">
                <span className="text-gray-500">Project:</span>
                <span className="text-gray-900">{state.projectId || 'None selected'}</span>
              </div>
              <div className="flex justify-between text-sm">
                <span className="text-gray-500">Batch:</span>
                <span className="text-gray-900">{state.batchId || 'None selected'}</span>
              </div>
              <div className="flex justify-between text-sm">
                <span className="text-gray-500">Row:</span>
                <span className="text-gray-900">
                  {state.rowTotal > 0 ? `${state.rowIndex + 1} of ${state.rowTotal}` : 'N/A'}
                </span>
              </div>
            </div>
          </>
        )}

        <button
          onClick={testPing}
          className="w-full px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition-colors text-sm font-medium"
        >
          Test Connection
        </button>
      </main>

      <footer className="pt-3 border-t text-xs text-gray-400">
        <p>Version 0.1.0 - Foundation</p>
      </footer>
    </div>
  );
}
```
  </action>
  <verify>
    `cat apps/extension/entrypoints/background.ts | grep "createMessageRouter"` and `cat apps/extension/entrypoints/popup/App.tsx | grep "sendToBackground"` and `cd apps/extension && npm run build`
  </verify>
  <done>All contexts wired with messaging system, popup can communicate with background</done>
</task>

</tasks>

<verification>
1. `apps/extension/src/types/messages.ts` defines ExtensionMessage union type
2. `apps/extension/src/types/responses.ts` defines Response<T> wrapper type
3. `apps/extension/src/messaging/send.ts` exports sendToBackground, sendToContent
4. `apps/extension/src/messaging/handlers.ts` exports createMessageRouter
5. `apps/extension/entrypoints/background.ts` uses createMessageRouter
6. `apps/extension/entrypoints/popup/App.tsx` uses sendToBackground
7. Extension builds: `cd apps/extension && npm run build`
</verification>

<success_criteria>
- Message types use discriminated unions with explicit type field
- Response types follow { success: true, data } | { success: false, error } pattern
- Popup can send typed messages to background
- Background routes messages to handlers
- Content script responds to messages
- Extension builds successfully with messaging module
</success_criteria>

<output>
After completion, create `.planning/phases/24-extension-foundation/24-03-SUMMARY.md`
</output>
