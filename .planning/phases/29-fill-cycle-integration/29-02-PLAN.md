---
phase: 29-fill-cycle-integration
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - apps/extension/src/api/rows.ts
  - apps/extension/src/api/index.ts
  - apps/extension/entrypoints/background.ts
  - apps/extension/src/types/messages.ts
autonomous: true

must_haves:
  truths:
    - "User clicks Fill and steps execute on the page"
    - "Popup shows fill progress (current step / total)"
    - "Fill result shows success or failure"
    - "Row data is fetched and substituted into fill steps"
  artifacts:
    - path: "apps/extension/src/api/rows.ts"
      provides: "API function to fetch row data by index"
      exports: ["fetchRowByIndex"]
    - path: "apps/extension/entrypoints/background.ts"
      provides: "FILL_START handler that orchestrates the fill cycle"
  key_links:
    - from: "apps/extension/entrypoints/background.ts"
      to: "content script"
      via: "browser.tabs.sendMessage FILL_EXECUTE"
      pattern: "tabs.sendMessage.*FILL_EXECUTE"
    - from: "apps/extension/entrypoints/background.ts"
      to: "popup"
      via: "broadcast FILL_PROGRESS"
      pattern: "broadcast.*FILL_PROGRESS"
---

<objective>
Implement fill orchestration flow from Fill button click to step execution

Purpose: Enable the core COPILOTO workflow where user clicks Fill and form fields are populated
Output: Complete fill cycle from button click through step execution with progress feedback
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-fill-cycle-integration/29-CONTEXT.md
@.planning/phases/29-fill-cycle-integration/29-01-SUMMARY.md

# Existing extension code
@apps/extension/entrypoints/background.ts
@apps/extension/entrypoints/content.ts
@apps/extension/src/api/index.ts
@apps/extension/src/api/mappings.ts
@apps/extension/src/types/messages.ts
@apps/extension/src/content/executor.ts

# Backend row API reference
@apps/api/src/core/entities/row.entity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rows API client</name>
  <files>
    apps/extension/src/api/rows.ts
    apps/extension/src/api/index.ts
  </files>
  <action>
Create rows.ts API client module:

1. Create fetchRowByIndex function:
   - Takes batchId and rowIndex (0-based)
   - Calls GET /projects/{projectId}/batches/{batchId}/rows?limit=1&offset={rowIndex}
   - Note: We need projectId too, so either:
     a) Accept projectId as parameter, or
     b) Fetch batch first to get projectId (inefficient)
   - Accept projectId, batchId, rowIndex as parameters
   - Returns the single row's data object (Record<string, unknown>)
   - Uses fetchWithAuth from client.ts

2. Add response type:
   ```typescript
   interface RowData {
     id: string;
     data: Record<string, unknown>;
     fillStatus: 'PENDING' | 'VALID' | 'ERROR';
   }
   ```

3. Export from index.ts:
   - Add `export { fetchRowByIndex } from './rows';`

Error handling: Throw if row not found (offset out of bounds returns empty items array).
  </action>
  <verify>
TypeScript compiles: `cd apps/extension && npm run type-check`
  </verify>
  <done>
fetchRowByIndex function exists, returns row data for given index
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FILL_START handler in background</name>
  <files>
    apps/extension/entrypoints/background.ts
    apps/extension/src/types/messages.ts
  </files>
  <action>
Implement the complete fill orchestration in background.ts:

1. Add module-level state tracking:
```typescript
let currentFillStatus: FillStatus = 'idle';
let lastMappingMatches: Array<{ id: string; name: string; stepCount: number }> = [];
```

2. Update buildState to include fillStatus:
   - Return currentFillStatus instead of hardcoded 'idle'

3. Implement FILL_START handler:
```typescript
case 'FILL_START': {
  try {
    // 1. Validate prerequisites
    const selection = await storage.selection.getSelection();
    const prefs = await storage.preferences.getPreferences();

    if (!selection.projectId || !selection.batchId) {
      sendResponse({ success: false, error: 'No project/batch selected' });
      break;
    }

    const mappingId = prefs.lastMappingIdByProject[selection.projectId];
    if (!mappingId) {
      sendResponse({ success: false, error: 'No mapping selected' });
      break;
    }

    // 2. Update state to filling
    currentFillStatus = 'filling';
    await notifyStateUpdate();

    // 3. Fetch mapping with steps
    const mapping = await fetchMappingWithSteps(selection.projectId, mappingId);
    if (!mapping || mapping.steps.length === 0) {
      currentFillStatus = 'failed';
      await notifyStateUpdate();
      sendResponse({ success: false, error: 'Mapping has no steps' });
      break;
    }

    // 4. Fetch current row data
    const row = await fetchRowByIndex(selection.projectId, selection.batchId, selection.rowIndex);

    // 5. Broadcast initial progress
    broadcast({
      type: 'FILL_PROGRESS',
      payload: { currentStep: 0, totalSteps: mapping.steps.length, status: 'Starting...' }
    });

    // 6. Get active tab and send FILL_EXECUTE to content script
    const [activeTab] = await browser.tabs.query({ active: true, currentWindow: true });
    if (!activeTab?.id) {
      currentFillStatus = 'failed';
      await notifyStateUpdate();
      sendResponse({ success: false, error: 'No active tab' });
      break;
    }

    // 7. Transform steps for content script (map backend Step to FillStep)
    const fillSteps = mapping.steps.map(step => ({
      id: step.id,
      stepOrder: step.stepOrder,
      action: step.action,
      selector: step.selector,
      selectorFallbacks: step.selectorFallbacks,
      sourceFieldKey: step.sourceFieldKey,
      fixedValue: step.fixedValue,
      clearBefore: step.clearBefore,
      pressEnter: step.pressEnter,
      waitMs: step.waitMs,
      optional: step.optional,
    }));

    // 8. Send to content script
    const result = await browser.tabs.sendMessage(activeTab.id, {
      type: 'FILL_EXECUTE',
      payload: { steps: fillSteps, rowData: row.data }
    });

    // 9. Process result
    if (result.success) {
      currentFillStatus = 'success';
      broadcast({
        type: 'FILL_PROGRESS',
        payload: { currentStep: mapping.steps.length, totalSteps: mapping.steps.length, status: 'Complete' }
      });
    } else {
      // Check if partial success (some steps succeeded)
      const successCount = result.data?.stepResults?.filter(r => r.success).length ?? 0;
      currentFillStatus = successCount > 0 ? 'partial' : 'failed';
      broadcast({
        type: 'FILL_PROGRESS',
        payload: {
          currentStep: successCount,
          totalSteps: mapping.steps.length,
          status: result.error ?? 'Fill failed'
        }
      });
    }

    await notifyStateUpdate();
    sendResponse({ success: result.success, data: result.data });
  } catch (err) {
    currentFillStatus = 'failed';
    await notifyStateUpdate();
    console.error('[Background] FILL_START error:', err);
    sendResponse({ success: false, error: err instanceof Error ? err.message : 'Fill failed' });
  }
  break;
}
```

4. Add imports at top of file:
   - import { fetchMappingWithSteps } from '../src/api';
   - import { fetchRowByIndex } from '../src/api';
  </action>
  <verify>
1. TypeScript compiles: `cd apps/extension && npm run type-check`
2. Extension builds: `cd apps/extension && npm run build`
  </verify>
  <done>
FILL_START handler fetches mapping+steps, fetches row data, sends FILL_EXECUTE to content script, handles result
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire progress updates to popup state</name>
  <files>
    apps/extension/entrypoints/background.ts
  </files>
  <action>
Ensure fill progress flows through to popup:

1. Verify FILL_PROGRESS message is properly typed and broadcast:
   - The broadcast call in FILL_START should already trigger popup listener
   - Popup already listens for FILL_PROGRESS in App.tsx useEffect

2. Add per-step progress broadcasts during fill (optional enhancement):
   - The content script's executeSteps doesn't report per-step progress back
   - For MVP, report 0 -> N -> done is sufficient
   - Per-step progress would require content script to broadcast during execution

3. Verify fillStatus is included in STATE_UPDATED:
   - buildState() must return currentFillStatus
   - Already done in Task 2

4. Test the flow:
   - Click Fill in popup
   - Background sets fillStatus to 'filling', broadcasts STATE_UPDATED
   - Popup receives and shows "Filling..."
   - Background sends FILL_EXECUTE to content
   - Content executes, returns result
   - Background sets fillStatus to success/partial/failed
   - Background broadcasts FILL_PROGRESS with final status
   - Popup shows result

5. Handle edge cases in FILL_START:
   - If content script not loaded: catch error from sendMessage, set failed state
   - If API errors: set failed state with error message

The popup's FillControls.tsx already handles fillStatus and fillProgress props.
Just ensure background properly updates these.
  </action>
  <verify>
Manual test:
1. Load extension, connect, select project with mapping, select batch
2. Navigate to mapped URL
3. Click Fill button
4. Verify popup shows progress (filling -> success/failed)
5. Verify form fields are populated on the page
  </verify>
  <done>
Fill flow works end-to-end: button click -> progress update -> step execution -> result display
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd apps/extension && npm run type-check`
2. Extension builds successfully: `cd apps/extension && npm run build`
3. Manual verification:
   - Create a test mapping with steps in the dashboard
   - Upload a batch with test data
   - Load extension, select project and batch
   - Navigate to the mapped URL
   - Click Fill button
   - Verify:
     a. Button shows "Filling..." state
     b. Form fields are populated with row data
     c. Button returns to normal state after completion
     d. FILL_PROGRESS message received (check console)
</verification>

<success_criteria>
- FILL-02 requirement satisfied: Background fetches mapping detail with steps
- FILL-03 requirement satisfied: Background sends steps and row data to content script
- FILL-04 requirement satisfied: Content script reports success/failure to background
- FILL-06 requirement satisfied: Popup shows fill progress
- Complete fill cycle works from button click to form population
</success_criteria>

<output>
After completion, create `.planning/phases/29-fill-cycle-integration/29-02-SUMMARY.md`
</output>
