---
phase: 29-fill-cycle-integration
plan: 03
type: execute
wave: 3
depends_on: ["29-02"]
files_modified:
  - apps/extension/src/api/rows.ts
  - apps/extension/src/api/index.ts
  - apps/extension/entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "Row status updates to VALID or ERROR after fill attempt"
    - "Mark Error button calls API to update row status to ERROR"
    - "User can retry a row by navigating to previous row and filling again"
    - "Error reason is stored in database"
  artifacts:
    - path: "apps/extension/src/api/rows.ts"
      provides: "API function to update row status"
      exports: ["updateRowStatus"]
  key_links:
    - from: "apps/extension/entrypoints/background.ts"
      to: "apps/extension/src/api/rows.ts"
      via: "updateRowStatus call in MARK_ERROR and after fill"
      pattern: "updateRowStatus"
---

<objective>
Implement row status updates to persist fill results to the database

Purpose: Track which rows have been filled successfully vs failed, enabling progress tracking and retry
Output: Row fillStatus updates to VALID/ERROR after fill attempts, persisted via API
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-fill-cycle-integration/29-CONTEXT.md
@.planning/phases/29-fill-cycle-integration/29-01-SUMMARY.md
@.planning/phases/29-fill-cycle-integration/29-02-SUMMARY.md

# Existing extension code
@apps/extension/entrypoints/background.ts
@apps/extension/src/api/rows.ts
@apps/extension/src/api/index.ts

# Backend row API reference
@apps/api/src/core/entities/row.entity.ts
@apps/api/src/presentation/dto/row.dto.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create updateRowStatus API function</name>
  <files>
    apps/extension/src/api/rows.ts
    apps/extension/src/api/index.ts
  </files>
  <action>
Add row status update function to rows.ts:

1. Add updateRowStatus function:
```typescript
/**
 * Update row fill status
 * @param projectId - Project ID (for ownership validation)
 * @param batchId - Batch ID containing the row
 * @param rowId - Row ID to update
 * @param status - New fill status (PENDING, VALID, ERROR)
 * @param errorMessage - Optional error message (only for ERROR status)
 * @param errorStep - Optional step ID that failed (only for ERROR status)
 */
export async function updateRowStatus(
  projectId: string,
  batchId: string,
  rowId: string,
  status: 'PENDING' | 'VALID' | 'ERROR',
  errorMessage?: string,
  errorStep?: string
): Promise<void> {
  const response = await fetchWithAuth(
    `${API_BASE_URL}/projects/${projectId}/batches/${batchId}/rows/${rowId}/status`,
    {
      method: 'PATCH',
      body: JSON.stringify({
        fillStatus: status,
        ...(errorMessage && { fillErrorMessage: errorMessage }),
        ...(errorStep && { fillErrorStep: errorStep }),
      }),
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message ?? `Failed to update row status: ${response.status}`);
  }
}
```

2. Export from index.ts:
   - Add `updateRowStatus` to the export from './rows'

3. Update fetchRowByIndex to also return the row ID:
   - Modify return type to include `id` field (already shown in Task 1 of plan 02)
   - Verify it returns the row ID needed for status updates
  </action>
  <verify>
TypeScript compiles: `cd apps/extension && npm run type-check`
  </verify>
  <done>
updateRowStatus function exists and accepts projectId, batchId, rowId, status, optional error fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire MARK_ERROR to call API</name>
  <files>
    apps/extension/entrypoints/background.ts
  </files>
  <action>
Update MARK_ERROR handler to call the real API:

1. Replace the stub implementation with real API call:
```typescript
case 'MARK_ERROR': {
  const { reason } = message.payload;
  try {
    const selection = await storage.selection.getSelection();

    if (!selection.projectId || !selection.batchId) {
      sendResponse({ success: false, error: 'No project/batch selected' });
      break;
    }

    // Fetch current row to get its ID
    const row = await fetchRowByIndex(
      selection.projectId,
      selection.batchId,
      selection.rowIndex
    );

    // Update row status to ERROR
    await updateRowStatus(
      selection.projectId,
      selection.batchId,
      row.id,
      'ERROR',
      reason ?? 'Manually marked as error'
    );

    console.log('[Background] MARK_ERROR: Row marked as error');

    // Advance to next row
    const newIndex = await storage.selection.nextRow();
    await notifyStateUpdate();
    sendResponse({ success: true, data: { rowIndex: newIndex } });
  } catch (err) {
    console.error('[Background] MARK_ERROR error:', err);
    // Still try to advance even if API call fails
    const newIndex = await storage.selection.nextRow();
    await notifyStateUpdate();
    sendResponse({
      success: false,
      error: err instanceof Error ? err.message : 'Failed to mark error',
      data: { rowIndex: newIndex }
    });
  }
  break;
}
```

2. Add import for updateRowStatus at top of file:
   - import { updateRowStatus } from '../src/api';
  </action>
  <verify>
1. TypeScript compiles: `cd apps/extension && npm run type-check`
2. Extension builds: `cd apps/extension && npm run build`
  </verify>
  <done>
MARK_ERROR handler calls updateRowStatus API, stores error reason, advances to next row
  </done>
</task>

<task type="auto">
  <name>Task 3: Update row status after fill attempt</name>
  <files>
    apps/extension/entrypoints/background.ts
  </files>
  <action>
Add row status update after fill execution in FILL_START handler:

1. After processing fill result, update row status:

```typescript
// Inside FILL_START handler, after processing result (step 9)

// 10. Update row status in database
const row = await fetchRowByIndex(selection.projectId, selection.batchId, selection.rowIndex);
try {
  if (result.success) {
    // All steps succeeded -> VALID
    await updateRowStatus(selection.projectId, selection.batchId, row.id, 'VALID');
  } else {
    // Find first failed step for error tracking
    const failedStep = result.data?.stepResults?.find(r => !r.success && !r.skipped);
    await updateRowStatus(
      selection.projectId,
      selection.batchId,
      row.id,
      'ERROR',
      result.error ?? failedStep?.error ?? 'Fill failed',
      failedStep?.stepId
    );
  }
} catch (statusErr) {
  // Log but don't fail the entire operation
  console.error('[Background] Failed to update row status:', statusErr);
}
```

2. Move the row fetch earlier in FILL_START (before sending to content):
   - We already fetch row data for fill execution
   - Store row.id in a variable to use for status update
   - This avoids fetching row twice

3. Structure of FILL_START handler with row ID tracking:
```typescript
// Step 4: Fetch current row data (with ID for later status update)
const row = await fetchRowByIndex(selection.projectId, selection.batchId, selection.rowIndex);
const currentRowId = row.id;  // Save for status update

// ... steps 5-9 ...

// Step 10: Update row status
try {
  if (result.success) {
    await updateRowStatus(selection.projectId, selection.batchId, currentRowId, 'VALID');
  } else {
    const failedStep = result.data?.stepResults?.find(r => !r.success && !r.skipped);
    await updateRowStatus(
      selection.projectId,
      selection.batchId,
      currentRowId,
      'ERROR',
      result.error ?? failedStep?.error ?? 'Fill failed',
      failedStep?.stepId
    );
  }
} catch (statusErr) {
  console.error('[Background] Failed to update row status:', statusErr);
}
```

This ensures:
- Successful fills mark row as VALID
- Failed fills mark row as ERROR with error message and failed step
- Status update errors don't break the fill flow

**Retry behavior (FILL-07 clarification):**
The retry mechanism uses row navigation, not a dedicated Retry button:
- User fills a row -> fill fails -> row marked ERROR -> user clicks Next
- Later, user can navigate back using ROW_PREV or ROW_SELECT
- When on the same row again, clicking Fill retries the operation
- Row status can change from ERROR back to VALID on successful retry
This is consistent with COPILOTO mode where user has manual control.
  </action>
  <verify>
1. TypeScript compiles: `cd apps/extension && npm run type-check`
2. Extension builds: `cd apps/extension && npm run build`
3. Manual test:
   - Fill a row successfully -> row.fillStatus should be VALID
   - Fill a row that fails -> row.fillStatus should be ERROR with message
   - Navigate to previous row and fill again -> verify status updates
   - Check database to verify status updates
  </verify>
  <done>
Row status automatically updates to VALID on success, ERROR on failure, with error details stored. Retry via row navigation works.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd apps/extension && npm run type-check`
2. Extension builds successfully: `cd apps/extension && npm run build`
3. API integration test:
   - Mark Error flow: Click Mark Error -> verify PATCH request sent -> verify row status in DB
   - Fill success flow: Execute fill -> verify row status changes to VALID
   - Fill failure flow: Execute fill with invalid selector -> verify row status changes to ERROR with message
4. Verify error messages are stored in fillErrorMessage field
5. Verify fillErrorStep contains the failing step ID when applicable
6. Verify retry works: Navigate to ERROR row, click Fill, verify status can change to VALID
</verification>

<success_criteria>
- FILL-05 requirement satisfied: Background updates row status via API after fill attempt
- FILL-07 requirement satisfied: Error state shows retry option via row navigation (not dedicated button)
- FILL-08 requirement satisfied: User can manually advance to next row after verification
- BROW-03 requirement validated: errorMessage field stores failure reason
- Complete flow: Fill -> status update -> Next -> repeat (or retry via navigation)
</success_criteria>

<output>
After completion, create `.planning/phases/29-fill-cycle-integration/29-03-SUMMARY.md`
</output>
