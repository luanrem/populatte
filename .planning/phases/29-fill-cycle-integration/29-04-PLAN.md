---
phase: 29-fill-cycle-integration
plan: 04
type: execute
wave: 4
depends_on: ["29-03"]
files_modified:
  - apps/extension/src/content/success-monitor.ts
  - apps/extension/entrypoints/content.ts
  - apps/extension/entrypoints/background.ts
  - apps/extension/src/types/messages.ts
autonomous: true

must_haves:
  truths:
    - "URL change trigger detects when page navigates to success URL pattern"
    - "Text appears trigger detects when success message appears on page"
    - "Element disappears trigger detects when form/modal is removed"
    - "Timeout prevents infinite waiting (default 30s)"
    - "COPILOTO mode (no successTrigger) allows manual Next click"
    - "Auto-detection mode (with successTrigger) auto-advances on success"
  artifacts:
    - path: "apps/extension/src/content/success-monitor.ts"
      provides: "Success detection with three trigger types + timeout"
      exports: ["SuccessMonitor", "startSuccessMonitor", "stopSuccessMonitor"]
  key_links:
    - from: "apps/extension/entrypoints/background.ts"
      to: "apps/extension/entrypoints/content.ts"
      via: "MONITOR_SUCCESS message to start monitoring"
      pattern: "tabs.sendMessage.*MONITOR_SUCCESS"
    - from: "apps/extension/src/content/success-monitor.ts"
      to: "apps/extension/entrypoints/background.ts"
      via: "SUCCESS_DETECTED message when trigger fires"
      pattern: "sendMessage.*SUCCESS_DETECTED"
---

<objective>
Implement success monitoring for auto-detection mode with three trigger types

Purpose: Per CONTEXT.md, MVP supports both COPILOTO mode (manual) AND auto-detect via successTrigger. This plan implements the auto-detection side.
Output: Content script monitors for success conditions (URL change, text appears, element disappears) and signals background when detected
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-fill-cycle-integration/29-CONTEXT.md
@.planning/phases/29-fill-cycle-integration/29-02-SUMMARY.md
@.planning/phases/29-fill-cycle-integration/29-03-SUMMARY.md

# Mapping entity with successTrigger
@apps/api/src/core/entities/mapping.entity.ts

# Existing extension code
@apps/extension/entrypoints/content.ts
@apps/extension/entrypoints/background.ts
@apps/extension/src/types/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SuccessMonitor class in content script</name>
  <files>
    apps/extension/src/content/success-monitor.ts
  </files>
  <action>
Create success-monitor.ts with three trigger detection strategies:

```typescript
/**
 * Success Monitor
 *
 * Monitors for success conditions after form fill:
 * - url_change: Page navigates to a different URL
 * - text_appears: Specific text appears in the DOM
 * - element_disappears: A specific element is removed from DOM
 *
 * Per CONTEXT.md: MVP supports both COPILOTO (manual) AND auto-detect modes
 */

export type SuccessTriggerType = 'url_change' | 'text_appears' | 'element_disappears';

export interface SuccessConfig {
  selector?: string;  // CSS selector for text_appears or element_disappears
  pattern?: string;   // URL pattern for url_change, text pattern for text_appears
}

export interface MonitorOptions {
  trigger: SuccessTriggerType;
  config: SuccessConfig;
  timeoutMs?: number;  // Default 30000ms (30 seconds)
}

type MonitorCallback = (success: boolean, reason: string) => void;

export class SuccessMonitor {
  private trigger: SuccessTriggerType;
  private config: SuccessConfig;
  private timeoutMs: number;
  private callback: MonitorCallback | null = null;
  private timeoutId: ReturnType<typeof setTimeout> | null = null;
  private observer: MutationObserver | null = null;
  private initialUrl: string;
  private stopped = false;

  constructor(options: MonitorOptions) {
    this.trigger = options.trigger;
    this.config = options.config;
    this.timeoutMs = options.timeoutMs ?? 30000;
    this.initialUrl = window.location.href;
  }

  start(callback: MonitorCallback): void {
    this.callback = callback;
    this.stopped = false;

    // Start timeout
    this.timeoutId = setTimeout(() => {
      this.stop();
      callback(false, `Timeout after ${this.timeoutMs}ms waiting for success`);
    }, this.timeoutMs);

    // Start appropriate monitor based on trigger type
    switch (this.trigger) {
      case 'url_change':
        this.startUrlMonitor();
        break;
      case 'text_appears':
        this.startTextMonitor();
        break;
      case 'element_disappears':
        this.startElementMonitor();
        break;
    }
  }

  stop(): void {
    this.stopped = true;
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
  }

  private onSuccess(reason: string): void {
    if (this.stopped) return;
    this.stop();
    this.callback?.(true, reason);
  }

  // URL Change Monitor
  private startUrlMonitor(): void {
    const checkUrl = () => {
      if (this.stopped) return;
      const currentUrl = window.location.href;
      if (currentUrl !== this.initialUrl) {
        // If pattern specified, check if new URL matches
        if (this.config.pattern) {
          if (currentUrl.includes(this.config.pattern)) {
            this.onSuccess(`URL changed to match pattern: ${this.config.pattern}`);
          }
          // URL changed but doesn't match pattern - keep watching
        } else {
          // No pattern - any URL change is success
          this.onSuccess(`URL changed from ${this.initialUrl} to ${currentUrl}`);
        }
      }
    };

    // Poll every 100ms (navigation events are unreliable in content scripts)
    const pollId = setInterval(() => {
      if (this.stopped) {
        clearInterval(pollId);
        return;
      }
      checkUrl();
    }, 100);

    // Store cleanup
    const originalStop = this.stop.bind(this);
    this.stop = () => {
      clearInterval(pollId);
      originalStop();
    };
  }

  // Text Appears Monitor
  private startTextMonitor(): void {
    const pattern = this.config.pattern ?? this.config.selector;
    if (!pattern) {
      this.callback?.(false, 'No text pattern specified for text_appears trigger');
      return;
    }

    const checkText = () => {
      if (this.stopped) return;
      // Check if text appears anywhere in the document
      if (document.body.textContent?.includes(pattern)) {
        this.onSuccess(`Text appeared: "${pattern}"`);
      }
    };

    // Check immediately
    checkText();

    // Watch for DOM changes
    this.observer = new MutationObserver(() => checkText());
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      characterData: true,
    });
  }

  // Element Disappears Monitor
  private startElementMonitor(): void {
    const selector = this.config.selector;
    if (!selector) {
      this.callback?.(false, 'No selector specified for element_disappears trigger');
      return;
    }

    // Check if element exists initially
    const element = document.querySelector(selector);
    if (!element) {
      // Element already doesn't exist - immediate success
      this.onSuccess(`Element not found: ${selector}`);
      return;
    }

    // Watch for removal
    this.observer = new MutationObserver(() => {
      if (this.stopped) return;
      if (!document.querySelector(selector)) {
        this.onSuccess(`Element disappeared: ${selector}`);
      }
    });

    // Watch parent for child removals
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }
}

// Module-level instance for singleton pattern
let activeMonitor: SuccessMonitor | null = null;

export function startSuccessMonitor(
  options: MonitorOptions,
  callback: MonitorCallback
): void {
  // Stop any existing monitor
  stopSuccessMonitor();

  activeMonitor = new SuccessMonitor(options);
  activeMonitor.start(callback);
}

export function stopSuccessMonitor(): void {
  if (activeMonitor) {
    activeMonitor.stop();
    activeMonitor = null;
  }
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/extension && npm run type-check`
  </verify>
  <done>
SuccessMonitor class implements url_change, text_appears, and element_disappears triggers with 30s timeout
  </done>
</task>

<task type="auto">
  <name>Task 2: Add success monitoring messages and wire content script</name>
  <files>
    apps/extension/src/types/messages.ts
    apps/extension/entrypoints/content.ts
  </files>
  <action>
1. Add new message types to messages.ts:

```typescript
// ============================================================================
// Success Monitoring Messages
// ============================================================================

export interface MonitorSuccessMessage {
  type: 'MONITOR_SUCCESS';
  payload: {
    trigger: 'url_change' | 'text_appears' | 'element_disappears';
    config: {
      selector?: string;
      pattern?: string;
    };
    timeoutMs?: number;
  };
}

export interface StopMonitorMessage {
  type: 'STOP_MONITOR';
}

export interface SuccessDetectedMessage {
  type: 'SUCCESS_DETECTED';
  payload: {
    success: boolean;
    reason: string;
  };
}
```

2. Add to BackgroundToContentMessage union:
```typescript
export type BackgroundToContentMessage =
  | FillExecuteMessage
  | MonitorSuccessMessage
  | StopMonitorMessage
  | PingMessage;
```

3. Add SuccessDetectedMessage to ContentToBackgroundMessage:
```typescript
export type ContentToBackgroundMessage =
  | FillResultMessage
  | SuccessDetectedMessage
  | PingMessage;
```

4. Update content.ts to handle MONITOR_SUCCESS:

```typescript
import { startSuccessMonitor, stopSuccessMonitor } from '../src/content/success-monitor';

// In message listener, add cases:

case 'MONITOR_SUCCESS': {
  const { trigger, config, timeoutMs } = message.payload;
  console.log('[Content] Starting success monitor:', trigger);

  startSuccessMonitor(
    { trigger, config, timeoutMs },
    (success, reason) => {
      console.log('[Content] Success monitor result:', success, reason);
      // Send result back to background
      browser.runtime.sendMessage({
        type: 'SUCCESS_DETECTED',
        payload: { success, reason }
      });
    }
  );

  sendResponse({ success: true });
  break;
}

case 'STOP_MONITOR': {
  console.log('[Content] Stopping success monitor');
  stopSuccessMonitor();
  sendResponse({ success: true });
  break;
}
```
  </action>
  <verify>
TypeScript compiles: `cd apps/extension && npm run type-check`
  </verify>
  <done>
Content script handles MONITOR_SUCCESS and STOP_MONITOR messages, SUCCESS_DETECTED sent back to background
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire success monitoring into fill flow in background</name>
  <files>
    apps/extension/entrypoints/background.ts
  </files>
  <action>
Integrate success monitoring into the FILL_START handler:

1. After successful fill (currentFillStatus === 'success'), check if mapping has successTrigger:

```typescript
// Inside FILL_START handler, after step 9 (process result) and before step 10:

// 9.5. Start success monitoring if mapping has successTrigger
if (result.success && mapping.successTrigger) {
  console.log('[Background] Starting success monitor:', mapping.successTrigger);

  // Send MONITOR_SUCCESS to content script
  await browser.tabs.sendMessage(activeTab.id, {
    type: 'MONITOR_SUCCESS',
    payload: {
      trigger: mapping.successTrigger,
      config: mapping.successConfig ?? {},
      timeoutMs: 30000,  // 30 second timeout per SUCC-04
    }
  });

  // Note: SUCCESS_DETECTED will be handled by a separate listener
  // Don't block here - let the user see success state
}

// Step 10 continues as before...
```

2. Add listener for SUCCESS_DETECTED from content script:

```typescript
// Add at module level or in the message switch:
case 'SUCCESS_DETECTED': {
  // This comes from content script when success trigger fires
  const { success, reason } = (message as SuccessDetectedMessage).payload;
  console.log('[Background] Success detected:', success, reason);

  if (success) {
    // Auto-advance to next row
    const newIndex = await storage.selection.nextRow();
    await notifyStateUpdate();

    // Optionally broadcast a "auto-advanced" message to popup
    broadcast({
      type: 'FILL_PROGRESS',
      payload: {
        currentStep: 0,
        totalSteps: 0,
        status: `Auto-advanced: ${reason}`
      }
    });
  } else {
    // Timeout or failure - stay on current row, user decides
    broadcast({
      type: 'FILL_PROGRESS',
      payload: {
        currentStep: 0,
        totalSteps: 0,
        status: `Monitor timeout: ${reason}`
      }
    });
  }

  sendResponse({ success: true });
  break;
}
```

3. Update fetchMappingWithSteps to include successTrigger and successConfig:
   - Ensure the mapping detail endpoint returns these fields
   - Add to MappingWithSteps type in mappings.ts

4. Stop any active monitor when navigating away or starting new fill:
   - At start of FILL_START, send STOP_MONITOR to clean up previous
   - This prevents lingering monitors from old fills

**COPILOTO vs Auto-detect behavior:**
- If mapping.successTrigger is null: COPILOTO mode, user clicks Next manually
- If mapping.successTrigger is set: Auto-detect mode, monitor runs and auto-advances on success
- Timeout (30s) allows fallback to manual mode if auto-detect fails
  </action>
  <verify>
1. TypeScript compiles: `cd apps/extension && npm run type-check`
2. Extension builds: `cd apps/extension && npm run build`
3. Manual test with auto-detect mapping:
   - Create mapping with successTrigger: 'url_change'
   - Fill form, submit
   - Verify auto-advance when URL changes
4. Manual test with COPILOTO mapping:
   - Create mapping with successTrigger: null
   - Fill form
   - Verify Next button required (no auto-advance)
  </verify>
  <done>
Success monitoring integrated: mappings with successTrigger auto-advance, mappings without require manual Next
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd apps/extension && npm run type-check`
2. Extension builds successfully: `cd apps/extension && npm run build`
3. Unit test scenarios (manual):
   - SUCC-01: Create mapping with successTrigger='url_change', fill form, navigate to /success, verify auto-advance
   - SUCC-02: Create mapping with successTrigger='text_appears' and pattern='Success', fill form, wait for text, verify auto-advance
   - SUCC-03: Create mapping with successTrigger='element_disappears' and selector='#form', fill form, remove form, verify auto-advance
   - SUCC-04: Start monitor, wait >30s, verify timeout fires and user can still click Next
4. COPILOTO mode: Create mapping with successTrigger=null, verify no auto-advance
</verification>

<success_criteria>
- SUCC-01 requirement satisfied: URL change trigger detects navigation to success URL pattern
- SUCC-02 requirement satisfied: Text appears trigger detects success message in DOM
- SUCC-03 requirement satisfied: Element disappears trigger detects form/modal removal
- SUCC-04 requirement satisfied: 30 second timeout prevents infinite waiting
- COPILOTO mode (successTrigger=null) works: manual Next required
- Auto-detect mode (successTrigger set) works: auto-advances on success
- Per CONTEXT.md: MVP supports both modes
</success_criteria>

<output>
After completion, create `.planning/phases/29-fill-cycle-integration/29-04-SUMMARY.md`
</output>
