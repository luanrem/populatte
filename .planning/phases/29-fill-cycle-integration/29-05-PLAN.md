---
phase: 29-fill-cycle-integration
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/extension/entrypoints/background.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Row status updates to VALID after successful fill"
    - "Fill fails gracefully when content script does not respond"
  artifacts:
    - path: "apps/extension/entrypoints/background.ts"
      provides: "Defensive handling of undefined sendMessage result"
      contains: "result === undefined"
  key_links:
    - from: "background.ts FILL_START"
      to: "content.ts FILL_EXECUTE"
      via: "browser.tabs.sendMessage"
      pattern: "if.*result.*undefined|!result"
---

<objective>
Fix message passing bug where browser.tabs.sendMessage returns undefined instead of content script response.

Purpose: Close UAT gap where fill works but row status doesn't update due to "Cannot read properties of undefined (reading 'success')" error at line 499.

Output: background.ts with defensive check for undefined sendMessage result.
</objective>

<execution_context>
@/Users/luanmartins/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luanmartins/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@apps/extension/entrypoints/background.ts
@apps/extension/entrypoints/content.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix undefined result handling in FILL_START</name>
  <files>apps/extension/entrypoints/background.ts</files>
  <action>
In the FILL_START handler (around line 489-562), add defensive check after the browser.tabs.sendMessage call.

Currently:
```typescript
const result = await browser.tabs.sendMessage(activeTab.id, {
  type: 'FILL_EXECUTE',
  payload: { steps: fillSteps, rowData: row.data },
}) as { success: boolean; ... };

// 9. Process result
if (result.success) { // <-- CRASHES if result is undefined
```

Change to:
```typescript
const result = await browser.tabs.sendMessage(activeTab.id, {
  type: 'FILL_EXECUTE',
  payload: { steps: fillSteps, rowData: row.data },
}) as { success: boolean; ... } | undefined;

// 9. Process result - handle undefined (content script not responding)
if (!result) {
  console.error('[Background] FILL_EXECUTE: No response from content script');
  currentFillStatus = 'failed';
  broadcast({
    type: 'FILL_PROGRESS',
    payload: {
      currentStep: 0,
      totalSteps: mapping.steps.length,
      status: 'Content script not responding',
    },
  });
  await notifyStateUpdate();
  sendResponse({ success: false, error: 'Content script not responding' });
  break;
}

if (result.success) {
  // existing success handling...
```

This ensures:
1. TypeScript knows result can be undefined (add `| undefined` to type assertion)
2. Undefined result is handled gracefully before accessing .success
3. User sees clear error message in popup
4. Fill status updates to 'failed' so retry is possible
  </action>
  <verify>
Run `npm run build --filter=@populatte/extension` and verify:
- Build completes without TypeScript errors
- Search background.ts for "No response from content script" to confirm the check was added
  </verify>
  <done>
- background.ts has defensive check for undefined result before accessing result.success
- Extension builds successfully
- Error "Cannot read properties of undefined" no longer possible at line 499
  </done>
</task>

</tasks>

<verification>
1. Extension builds: `npm run build --filter=@populatte/extension`
2. The defensive check exists in the compiled code
3. No TypeScript errors in the modified file
</verification>

<success_criteria>
- browser.tabs.sendMessage result is checked for undefined before use
- Undefined result shows user-friendly error in popup
- Fill flow continues to work when content script responds normally
- UAT Test 6 (Row Status Updated to VALID) will pass on retest
</success_criteria>

<output>
After completion, create `.planning/phases/29-fill-cycle-integration/29-05-SUMMARY.md`
</output>
